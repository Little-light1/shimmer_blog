{"meta":{"title":"Shimmer","subtitle":"向着未来前进!","description":"","author":"Shimmer","url":"https://gitee.com/shimmer612/myBlog","root":"/myBlog/"},"pages":[{"title":"留言板","date":"2021-04-23T12:43:50.203Z","updated":"2021-03-17T01:52:41.653Z","comments":true,"path":"message/index.html","permalink":"https://gitee.com/shimmer612/myBlog/message/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-23T09:07:02.000Z","updated":"2021-02-23T09:08:25.950Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/shimmer612/myBlog/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-07-04T06:51:08.624Z","updated":"2023-07-04T06:51:08.624Z","comments":true,"path":"photos/index.html","permalink":"https://gitee.com/shimmer612/myBlog/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"Nest学习记录（1）","slug":"2023-06-26-Nest学习记录（1）","date":"2023-06-25T16:00:00.000Z","updated":"2023-06-26T05:04:30.787Z","comments":true,"path":"2023/06/26/2023-06-26-Nest学习记录（1）/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/06/26/2023-06-26-Nest%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%881%EF%BC%89/","excerpt":"","text":"Nest学习记录（1）1、nest cli 的安装升级创建项目安装到全局 npm install -g @nestjs/cli 升级 npm update -g @nestjs/cli 创建项目 nest new 项目名 2、nest cli常用命令123456789101112// 新建项目nest new xxx// 查看命令有哪些选项nest xxx -h// 新建代码片段比如 controller、service、module 等。// xxx文件夹名称nest generate module xxxnest generate controller xxxnest generate service xxx// 也可以一下子生成整个模板nest generate resource xxx 可以选择生成那种风格的Api，nest支持http,websocket,graphql等风格的api。 是否生成CRUD（增删改查）代码 启动服务和打包 启动：nest start 打包：nest build 会在dist目录生成编译后的代码 默认是 tsc 编译，也可以切换成 webpack。 用tsc打包会对每个文件进行编译 nest build --tsc webpack只生成一个main.js文件 nest build --webpack 查看项目信息 这个就是查看项目信息的，包括系统信息、 node、npm 和依赖版本 nest info 3、五种Http数据传输方式 url param 直接在url地址后面get请求 query url ‘?’后面拼接参数get请求 form-urlencoded post请求参数 form-data 传输文件 json post请求json格式 1、url param 参数直接在url当中 12//123就是参数http://localhost:3000/aaa/123 2、query url中使用？分割后面就是参数， 其中非英文字符和中文字符会转码。 可以使用 encodeURIComponent 来编码 axios自带编码，不需要手动转 12// name和age是参数，值为123和456http://localhost:3000/aaa?name=123&amp;age=456 3、form-urlencoded 参数放在了body中 要指定content-type = application/x-www-form-urlencoded 123456789101112axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;; async function postBody() &#123; const res = await axios.post(&#x27;/api/aaa&#x27;, &#123; name: &#x27;王五&#x27;, age: 18, &#125;); console.log(&#x27;form-urlencoded&#x27;, res); &#125; postBody(); [ 4、form-data 用来传输文件和别的参数 要指定content-type = multipart/form-data 使用分隔符boundary来分割参数。如下 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- axios cdn --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;input id=&quot;fileInput&quot; type=&quot;file&quot; multiple /&gt; &lt;button onclick=&quot;fileData()&quot;&gt;点击&lt;/button&gt; &lt;/body&gt; &lt;script&gt; // file const fileInput = document.getElementById(&#x27;fileInput&#x27;); async function fileData() &#123; const data = new FormData(); data.set(&#x27;name&#x27;, &#x27;吕布&#x27;); data.set(&#x27;age&#x27;, 38); data.set(&#x27;file1&#x27;, fileInput.files[0]); const res = await axios(&#123; method: &#x27;post&#x27;, url: &#x27;/api/aaa/file&#x27;, data, headers: &#123; &#x27;content-type&#x27;: &#x27;multipart/form-data&#x27; &#125;, &#125;); console.log(&#x27;res: &#x27;, res); &#125; &lt;/script&gt;&lt;/html&gt; 5、json 上面几种都需要编码，转码 json就很好的解决了上面的问题 只需要指定content-type=application/json就行如下 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- axios cdn --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt; &lt;script&gt; async function postJsonBody() &#123; const res = await axios(&#123; method: &#x27;post&#x27;, url: &#x27;/api/aaa&#x27;, data: &#123; name: &#x27;王五&#x27;, age: 18, &#125;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, &#125;); console.log(&#x27;json&#x27;, res); &#125; postJsonBody(); &lt;/script&gt;&lt;/html&gt; 4、五种传输方式，接口实现首先通过nest generate controller aaa新建模板代码， 会自动在app.module.ts中引入该contorller form-data上传文件需要npm i -D @types/multer,引入相关类型声明 contorller代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Body, Controller, Param, Post, UploadedFiles, UseInterceptors,&#125; from &#x27;@nestjs/common&#x27;;import &#123; Get, Query &#125; from &#x27;@nestjs/common&#x27;;// 对于放在body中的参数，要使用@Body新建dto文件，nest会解析body，注入到dto对象中import &#123; CreateAaaDto &#125; from &#x27;./dto/create_aaa.dto&#x27;;// 多文件上传要使用下面的拦截器 AnyFilesInterceptor// 单文件直接使用FileInterceptor就行import &#123; AnyFilesInterceptor &#125; from &#x27;@nestjs/platform-express&#x27;;//请求的默认接口app/aaa@Controller(&#x27;api/aaa&#x27;)export class AaaController &#123; @Get(&#x27;:id&#x27;) urlParam(@Param(&#x27;id&#x27;) id: &#x27;string&#x27;) &#123; return `the urlParam is: $&#123;id&#125;`; &#125; @Get(&#x27;find&#x27;) getName(@Query(&#x27;name&#x27;) name: string) &#123; return `the queryParam is: name=$&#123;name&#125;`; &#125; @Post() body(@Body() CreateAaaDto: CreateAaaDto) &#123; return `the body is: $&#123;JSON.stringify(CreateAaaDto)&#125;`; &#125; // uploads文件上传后保存的目录 // body中别的数据，还是用body接收 @Post(&#x27;file&#x27;) @UseInterceptors(AnyFilesInterceptor(&#123; dest: &#x27;uploads/&#x27; &#125;)) bodyFile( @Body() CreateAaaDto: CreateAaaDto, @UploadedFiles() files: Array&lt;Express.Multer.File&gt;, ) &#123; console.log(&#x27;files: &#x27;, files); return `files: $&#123;JSON.stringify(CreateAaaDto)&#125;`; &#125;&#125; dto代码 就是用于封装传输的数据的对象 1234export class CreateAaaDto &#123; name: string; age: number;&#125;","categories":[],"tags":[{"name":"nest","slug":"nest","permalink":"https://gitee.com/shimmer612/myBlog/tags/nest/"}]},{"title":"React Native 多行展开收起功能","slug":"2023-06-16-React Native 多行展开收起功能","date":"2023-06-15T16:00:00.000Z","updated":"2023-06-26T05:04:26.457Z","comments":true,"path":"2023/06/16/2023-06-16-React Native 多行展开收起功能/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/06/16/2023-06-16-React%20Native%20%E5%A4%9A%E8%A1%8C%E5%B1%95%E5%BC%80%E6%94%B6%E8%B5%B7%E5%8A%9F%E8%83%BD/","excerpt":"","text":"React Native 多行展开收起功能1、前言对文章可以添加标签，在目录页面，可以显示该标签。宽度不满一行的直接显示 宽度超过一行的，显示展开按钮。点击展开按钮显示全部标签，加收起按钮。 效果如下： 一开始是准备固定高度，flex-wrap展示，点击展开取消固定高度。而且展开按钮不能直接跟在标签后面。而且不同的设备分辨率不一样。展示也有问题。 2、解决办法最后是使用Text标签的numberOfLines加ellipsizeMode=&quot;clip&quot;来实现。 一开始，每个item有个numberOfLines属性默认是undefind。 通过onLayout事件获取第一次渲染的高度。 然后记下来第一次渲染的高度，设置numberOfLines值为1， 再次渲染，比较前后的高度。如果第一次比第二次高，就表明超过一行，就设置expand为true，展示，“展开“按钮。点击展开设置numberOfLines值为999。同时记下来标签的数组的长度，点击的时候标签的长度等于记下来的长度就添加一个收起。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// height 是第一次渲染的高度// expand 代表是否展示展开按钮// tipLength 标签没有添加收起的长度&#123;tips &amp;&amp; ( &lt;View style=&#123;styles.literatureTagBox&#125;&gt; &lt;Text onLayout=&#123;evt =&gt; &#123; // 因为onLayout会在数据变化的时候调用 // 为了避免重复渲染，只有第一次和第二次才会走下面的逻辑 if ( numberOfLines !== undefined &amp;&amp; numberOfLines !== 1 ) &#123; return; &#125; const heightStart = evt.nativeEvent.layout.height; if (!height) &#123; arr[index].height = heightStart; &#125; arr[index].numberOfLines = 1; // 当第一次的高度大于第二次的时候，说明需要换行 if (height &amp;&amp; height &gt; heightStart) &#123; arr[index].expand = true; &#125; setDataList([...arr]); &#125;&#125; numberOfLines=&#123;numberOfLines&#125; ellipsizeMode=&quot;clip&quot; style=&#123;[styles.literatureTagView]&#125;&gt; &#123;tips.map((tip: any) =&gt; ( &lt;View key=&#123;tip.id&#125;&gt; &lt;Text numberOfLines=&#123;1&#125; ellipsizeMode=&quot;tail&quot; style=&#123;styles.literatureTag&#125; onPress=&#123;() =&gt; &#123; if (tip.id === &#x27;reduce&#x27;) &#123; arr[index].expand = true; arr[index].numberOfLines = 1; setDataList([...arr]); &#125; &#125;&#125;&gt; &#123;tip?.tipName&#125; &lt;/Text&gt; &lt;/View&gt; ))&#125; &lt;/Text&gt; &#123;expand &amp;&amp; ( &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; //点击展开，expand设置为false,numberOfLines为999，展示所有标签 //当标签的长度和初始长度一样时，添加收起，不一样代表添加过了不操作 arr[index].expand = false; arr[index].numberOfLines = 999; if (arr[index].tips.length === tipLength) &#123; arr[index].tips = [ ...arr[index].tips, &#123;tipName: &#x27;收起▲&#x27;, id: &#x27;reduce&#x27;&#125;, ]; &#125; setDataList([...arr]); &#125;&#125; style=&#123;[&#123;marginTop: pxToDp(4)&#125;]&#125;&gt; &lt;Text style=&#123;[styles.literatureTagExpand]&#125;&gt;展开▼&lt;/Text&gt; &lt;/TouchableOpacity&gt; )&#125; &lt;/View&gt; )&#125; //样式 export default StyleSheet.create(&#123; literatureTagBox: &#123; flexDirection: &#x27;row&#x27;, alignItems: &#x27;center&#x27;, &#125;, literatureTagView: &#123; marginTop: pxToDp(4), &#125;, literatureTag: &#123; paddingHorizontal: pxToDp(4), borderWidth: pxToDp(1), borderColor: &#x27;#D2D8DF&#x27;, borderStyle: &#x27;solid&#x27;, borderRadius: pxToDp(2), fontWeight: &#x27;400&#x27;, textAlign: &#x27;center&#x27;, color: &#x27;#A2A8B5&#x27;, fontSize: pxToDp(12), marginRight: pxToDp(6), marginTop: pxToDp(4), height: pxToDp(24), lineHeight: pxToDp(22), maxWidth: pxToDp(120), &#125;, literatureTagExpand: &#123; height: pxToDp(24), paddingHorizontal: pxToDp(4), paddingVertical: pxToDp(2), borderWidth: pxToDp(1), borderColor: &#x27;#D2D8DF&#x27;, borderStyle: &#x27;solid&#x27;, borderRadius: pxToDp(2), fontWeight: &#x27;400&#x27;, textAlign: &#x27;center&#x27;, color: &#x27;#A2A8B5&#x27;, fontSize: pxToDp(12), lineHeight: pxToDp(22), marginTop: pxToDp(4), &#125; &#125;","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-native/"}]},{"title":"useReColumnWidth自适应Table列宽hooks","slug":"2023-05-17-useReColumnWidth自适应Table列宽hooks","date":"2023-05-16T16:00:00.000Z","updated":"2023-06-26T05:04:18.989Z","comments":true,"path":"2023/05/17/2023-05-17-useReColumnWidth自适应Table列宽hooks/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/05/17/2023-05-17-useReColumnWidth%E8%87%AA%E9%80%82%E5%BA%94Table%E5%88%97%E5%AE%BDhooks/","excerpt":"","text":"useReColumnWidth自适应Table列宽hooks1、前言在使用antd中Table组件的时候，如果columns的总宽度不够容器的宽度，就会自适应，每个column的宽度会改变。 但是有的列不希望自适应，就应该展示设定的宽度。 当宽度不够撑满的时候，就让最后一列和没有设置宽度的column自适应。 2、实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * @Author: shimmer * @Date: 2023-05-17 13:26:32 * @LastEditors: shimmer * @LastEditTime: 2023-05-18 08:56:12 * */import &#123;useMemo&#125; from &#x27;react&#x27;;import &#123;useSize&#125; from &#x27;ahooks&#x27;;interface UseReColumnWidthProps &#123; columns: Record&lt;string:any&gt;[]; containerRef?: any;&#125;const useReColumnWidth = (props: UseReColumnWidthProps) =&gt; &#123; const &#123;columns, containerRef&#125; = props; // 获取容器宽度 const containerSize = useSize(containerRef); const &#123;width: tableWidth = 0&#125; = containerSize || &#123;&#125;; // 重新计算列宽 const adaptiveColumns = useMemo(() =&gt; &#123; const needAdaptiveColumnsIndex: number[] = []; let withoutWidthColumnCount = 0; columns.forEach((&#123;width&#125;, index) =&gt; &#123; if (!width) &#123; needAdaptiveColumnsIndex.push(index); withoutWidthColumnCount += 1; &#125; &#125;); let totalWidth = columns.reduce((total, column) =&gt; total + parseFloat(String(column.width || 0)), 0); // columns总宽度&lt;容器宽度 if (!withoutWidthColumnCount &amp;&amp; tableWidth &amp;&amp; totalWidth &lt; tableWidth) &#123; // 最后一列需要自适应 needAdaptiveColumnsIndex.push(columns.length - 1); withoutWidthColumnCount += 1; // 排除最后一列，重新计算 totalWidth = columns.reduce((total, c, i) =&gt; total + (i === columns.length - 1 ? 0 : parseFloat(String(c.width!))), 0); &#125; // columns总宽度&gt;容器宽度不做处理 return columns!.map((column, index) =&gt; &#123; column.ellipsis = true; if (column.width &amp;&amp; !needAdaptiveColumnsIndex.includes(index)) &#123; return column; &#125; return &#123; ...column, width: Math.floor((tableWidth - totalWidth) / withoutWidthColumnCount), &#125;; &#125;); &#125;, [columns, tableWidth]); return &#123; containerRef, adaptiveColumns, &#125;;&#125;;export default useReColumnWidth; 3、使用containerRef绑定到父元素上，或者绑定到Table上，Table要设置宽度。 1234567891011import &#123;Table&#125; from &quot;antd&quot;import useReColumnWidth form &quot;.&#x2F;useReColumnWidth&quot;const demo &#x3D; (&#123;columns,datasource&#125;)&#x3D;&gt;&#123; const &#123;adaptiveColumns,containerRef&#125; &#x3D; useReColumnWidth(&#123;columns&#125;); return &lt;div ref&#x3D;&#123;containerRef&#125;&gt; &lt;Table columns&#x3D;&#123;adaptiveColumns&#125; datasourec &#x3D; &#123;datasource&#125;&#x2F;&gt; &lt;&#x2F;div&gt;&#125;","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"设计模式：单例模式","slug":"2023-02-17-设计模式：单例模式","date":"2023-02-16T16:00:00.000Z","updated":"2023-05-22T08:07:16.646Z","comments":true,"path":"2023/02/17/2023-02-17-设计模式：单例模式/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/02/17/2023-02-17-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式：单例模式 单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建 在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象。 1234567891011121314151617181920212223242526272829303132333435363738394041class Single &#123; show() &#123; console.log(&quot;我是一个单例模式。&quot;); &#125; static getSingle() &#123; if (!Single.instance) &#123; Single.instance = new Single(); &#125; return Single.instance &#125;&#125;const s1 = Single.getSingle();const s2 = Single.getSingle();console.log(s1===s2);// trues1.name = &quot;test&quot;;console.log(&#x27;s2: &#x27;, s2);console.log(&#x27;s1: &#x27;, s1);// s2: Single &#123; name: &#x27;test&#x27; &#125;// s1: Single &#123; name: &#x27;test&#x27; &#125;Single.getInstance = (function()&#123; // 定义自由变量instance，模拟私有变量 let instance = null return function() &#123; // 判断自由变量是否为null if(!instance) &#123; // 如果为null则new出唯一实例 instance = new Single() &#125; return instance &#125;&#125;)()const c1 = new Single.getInstance();const c2 = new Single.getInstance();console.log(&#x27;c1===c2: &#x27;, c2===c1);// c1===c2: true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"设计模式：观察者模式","slug":"2023-02-16-设计模式：观察者模式","date":"2023-02-15T16:00:00.000Z","updated":"2023-05-22T08:05:48.133Z","comments":true,"path":"2023/02/16/2023-02-16-设计模式：观察者模式/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/02/16/2023-02-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式：观察者模式观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新 观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * @Author: zhangzhen * @Date: 2023-02-16 09:11:47 * @LastEditors: zhangzhen * @LastEditTime: 2023-02-16 09:21:50 * */// 观察者模式class Subject &#123; constructor() &#123; this.observerList = [] &#125; // 添加订阅者 addObserver(observer) &#123; this.observerList.push(observer) &#125; // 删除订阅者 removeObserver(observer) &#123; const currentIndex = this.observerList.findIndex(item,item.name===observer.name) this.observerList.splice(currentIndex,1) &#125; //发布任务 sendTask(task) &#123; const observers = this.observerList observers.forEach(item=&gt;item.update(task)) &#125; &#125;// 订阅者class Observer &#123; constructor(name,subject) &#123; this.name = name if(subject) &#123; subject.addObserver(this) &#125; &#125; // 接收订阅消息 update (task) &#123; console.log(&#x27;我订阅了:&#x27;, task); &#125;&#125;const subjectA = new Subject()const observer1 = new Observer(&quot;张三&quot;,subjectA)subjectA.sendTask(&quot;去吃饭&quot;)//我订阅了: 去吃饭","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"设计模式：发布订阅模式","slug":"2023-02-15-设计模式：发布订阅模式","date":"2023-02-14T16:00:00.000Z","updated":"2023-05-22T08:05:48.133Z","comments":true,"path":"2023/02/15/2023-02-15-设计模式：发布订阅模式/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/02/15/2023-02-15-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式：发布订阅模式发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* * @Author: zhangzhen * @Date: 2023-02-15 10:21:14 * @LastEditors: zhangzhen * @LastEditTime: 2023-02-15 15:53:16 * */// 发布订阅者模式// 中间处理发布订阅class Pubsub &#123; constructor() &#123; this.message = &#123;&#125;; this.listener = &#123;&#125;; &#125; // 添加发布者 publish(type, content) &#123; let nowPublisher = this.message[type]; if (!nowPublisher) &#123; this.message[type] = []; &#125; this.message[type].push(content); &#125; // 添加订阅者 subscribe(type, cb) &#123; let nowSubscriber = this.listener[type]; if (!nowSubscriber) &#123; this.listener[type] = []; &#125; this.listener[type].push(cb); &#125; // 发布消息 sendMessage(type) &#123; const message = this.message[type]; const subscriber = this.listener[type]; subscriber.forEach((cb) =&gt; cb(message.join(&#x27;,&#x27;))); &#125;&#125;// 发布者,只管发布class Publisher &#123; constructor(name, context) &#123; this.name = name; this.context = context; &#125; publish(type, content) &#123; this.context.publish(type, content); &#125;&#125;// 订阅者,只管订阅class Subscriber &#123; constructor(name, context) &#123; this.name = name; this.context = context; &#125; subscribe(type, cb) &#123; this.context.subscribe(type, cb); &#125;&#125;const TYPE_1 = &#x27;eat&#x27;;const TYPE_2 = &#x27;drink&#x27;;const TYPE_3 = &#x27;play&#x27;;const TYPE_4 = &#x27;happy&#x27;;const pubsubA = new Pubsub();const publishA = new Publisher(&#x27;pubA&#x27;, pubsubA);publishA.publish(TYPE_1, &#x27;吃炸鸡&#x27;);const publishB = new Publisher(&#x27;pubB&#x27;, pubsubA);publishB.publish(TYPE_1, &#x27;吃火锅&#x27;);publishB.publish(TYPE_2, &#x27;喝奶茶&#x27;);publishB.publish(TYPE_3, &#x27;玩游戏&#x27;);const publishC = new Publisher(&#x27;pubC&#x27;, pubsubA);publishC.publish(TYPE_3, &#x27;游乐园&#x27;);publishC.publish(TYPE_1, &#x27;吃烧烤&#x27;);const publishD = new Publisher(&#x27;pubD&#x27;, pubsubA);publishD.publish(TYPE_4, &#x27;看电影&#x27;);const subscribeA = new Subscriber(&#x27;subA&#x27;, pubsubA);subscribeA.subscribe(TYPE_1, (res) =&gt; &#123; console.log(`我订阅了$&#123;TYPE_1&#125;`, res);&#125;);subscribeA.subscribe(TYPE_2, (res) =&gt; &#123; console.log(`我订阅了$&#123;TYPE_2&#125;`, res);&#125;);subscribeA.subscribe(TYPE_3, (res) =&gt; &#123; console.log(`我订阅了$&#123;TYPE_3&#125;`, res);&#125;);subscribeA.subscribe(TYPE_4, (res) =&gt; &#123; console.log(`我订阅了$&#123;TYPE_4&#125;`, res);&#125;);console.log(pubsubA.message);pubsubA.sendMessage(TYPE_1);pubsubA.sendMessage(TYPE_2);pubsubA.sendMessage(TYPE_3);pubsubA.sendMessage(TYPE_4);// &#123;// eat: [ &#x27;吃炸鸡&#x27;, &#x27;吃火锅&#x27;, &#x27;吃烧烤&#x27; ],// drink: [ &#x27;喝奶茶&#x27; ],// play: [ &#x27;玩游戏&#x27;, &#x27;游乐园&#x27; ],// happy: [ &#x27;看电影&#x27; ]// &#125;/** * 我订阅了eat 吃炸鸡,吃火锅,吃烧烤 * 我订阅了drink 喝奶茶 * 我订阅了play 玩游戏,游乐园 * 我订阅了happy 看电影 * */","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"2023年猝不及防的来了","slug":"2023","date":"2022-12-31T16:00:00.000Z","updated":"2023-02-05T11:08:45.734Z","comments":true,"path":"2023/01/01/2023/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2023/01/01/2023/","excerpt":"","text":"2023年元旦一年的时间在眼前绕一下就过去了， 上班以后真的感觉时间是越过越快。 好在2022的末尾，持续了三年的疫情放开了， 再也没有隔离了，但是再也回不到2020年以前的那种状态了。 不过第一次“羊”的感觉是真的不好受，虽然现在杨康了， 但是还是觉得容易累，感觉肺里老有痰咳不出来。 不知道下一轮什么时候到来。 还是发现，身体健康最重要了，别的都是假的。 今年经历了换工作，从一个城市到另外一个城市。 没有想象中的那么麻烦。 但是刚开始那几天确实遇到了不少倒霉事， 好在都过去了。 和女朋友也见过家长了。 日子总是在往好的方向发展。 希望2023年，我爱的人和爱我的人， 一切都好，健康平安。 新年快乐！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"对react-toolkit赋值封装","slug":"2022-11-19-对react-toolkit赋值封装","date":"2022-11-18T16:00:00.000Z","updated":"2023-02-05T11:41:55.037Z","comments":true,"path":"2022/11/19/2022-11-19-对react-toolkit赋值封装/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/11/19/2022-11-19-%E5%AF%B9react-toolkit%E8%B5%8B%E5%80%BC%E5%B0%81%E8%A3%85/","excerpt":"","text":"对react-toolkit赋值封装。前言因为为了做keepalive，项目中页面的数据都是存在redux上面。 虽然用的react-tookit,但是每次取值、赋值都很麻烦，如下。 123456789101112131415161718192021222324import &#123; useAction,&#125; from &#x27;@gwaapp/ease&#x27;;import &#123;useAppDispatch, useAppSelector,&#125; from &#x27;@init/runtime&#x27;;const page = (props)=&gt;&#123; const &#123;id&#125; = props //取值 const &#123; pageNum, &#125; = useAppSelector( (state) =&gt; state[id] ); const dispatch = useAppDispatch(); const &#123;getPageSimpleActions&#125; = useAction(); const actions = getPageSimpleActions(id); return &lt;button onClick=&#123;()=&gt;&#123; //赋值 dispatch(actions.set(&#123;pageNum:1&#125;)) &#125;&#125;&gt;赋值&lt;/button&gt;&#125; 每次都要引用这些写那几行重复的代码，十分的繁琐，我就在想能不能像简便一点。 于是我想到了Proxy。 proxy是什么？Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 通俗的讲Proxy是一个对象操作的拦截器，拦截对目标对象的操作，进行一些自定义的行为。 1let p = new Proxy(target, handler); target用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler一个对象，其属性是当执行一个操作时定义代理的行为的函数 于是在对象赋值前，进行拦截，同时让页面的数据变化。 代码首先传入当前页面所有的redux数据，进行深拷贝，防止修改原数据。 然后进行拦截，为了防止直接对象赋值，为赋值写了一个方法。 加了泛型，有了代码提示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import _ from &#x27;lodash&#x27;;import &#123;useRef&#125; from &#x27;react&#x27;;import &#123;useAction&#125; from &#x27;@gwaapp/ease&#x27;;import &#123;useAppDispatch&#125; from &#x27;@init/runtime&#x27;; // Partial 作用是让传入类型中的所有属性变成都是可选的type PageStateProxyHandler&lt;T&gt; = (state: Partial&lt;T&gt;) =&gt; void;export interface PageStateProxyType&lt;T&gt; &#123; pageStateProxy: T; setPageStateProxy: PageStateProxyHandler&lt;T&gt;;&#125;export const usePageStateProxy = &lt;T extends Record&lt;string, any&gt;&gt;( initialState: T, id: string, search?: string,): PageStateProxyType&lt;T&gt; =&gt; &#123; const &#123;getPageSimpleActions&#125; = useAction(); const actions = getPageSimpleActions(id, search); const dispatch = useAppDispatch(); const changeRef = useRef&lt;boolean&gt;(false); const temValue = _.cloneDeep(initialState); const pageStateProxy = new Proxy(temValue, &#123; get(target, key: string) &#123; return target[key]; &#125;, set(target, key, newValue) &#123; if (changeRef.current) &#123; target[key] = newValue; return true; &#125; throw new Error(`$&#123;String(key)&#125;请使用setPageStateProxy方法赋值`); &#125;, &#125;); const setPageStateProxy = (state: Partial&lt;T&gt;) =&gt; &#123; changeRef.current = true; dispatch(actions.set(&#123;...state&#125;)); for (const item in state) &#123; if (state.hasOwnProperty(item)) &#123; pageStateProxy[item] = state[item] as any; &#125; &#125; changeRef.current = false; &#125;; return &#123; pageStateProxy, setPageStateProxy, &#125;;&#125;; 使用这样就很方便了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import React, &#123;FC&#125; from &#x27;react&#x27;;import &#123;PageProps, getUniqueKey, usePage&#125; from &#x27;@gwaapp/ease&#x27;;import &#123;useAppSelector, useAppDispatch&#125; from &#x27;@init/runtime&#x27;;import &#123;shallowEqual&#125; from &#x27;react-redux&#x27;;import &#123;usePageStateProxy&#125; from &#x27;@/common/hooks/usePageStateProxy&#x27;;import FormPage from &#x27;./form&#x27;;import ChartsInfo from &#x27;./echarts/charts_info&#x27;;import EchartsPage from &#x27;./echarts&#x27;;import TablePage from &#x27;./table&#x27;;import styles from &#x27;./styles.module.scss&#x27;;import &#123;PageStateType&#125; from &#x27;./types&#x27;;import &#123;initPage, dropDownFun&#125; from &#x27;./actions&#x27;;const ProductionPage: FC&lt;PageProps&gt; = (props) =&gt; &#123; const &#123;id, search&#125; = props; const dispatch = useAppDispatch(); const initState = useAppSelector( (state) =&gt; state[getUniqueKey(id, search)], shallowEqual, ); //1传入页面数据 const pageStateObserver = usePageStateProxy&lt;PageStateType&gt;( initState, id, search, ); //返回两个方法 const &#123;pageStateProxy,setPageStateProxy&#125; = pageStateObserver; usePage(&#123; ...props, // 页面初始化逻辑 init: () =&gt; &#123; if (search === &#x27;&#x27;) &#123; dispatch(initPage(pageStateObserver)); &#125; else &#123; // 下钻 dispatch(dropDownFun(pageStateObserver, props)); &#125; &#125;, &#125;); return ( &lt;div className=&#123;styles.pro_box&#125;&gt; &lt;div className=&#123;styles.scrollBox&#125;&gt; &#123;/* 查询表单 */&#125; &lt;FormPage &#123;...props&#125; pageStateObserver=&#123;pageStateObserver&#125; /&gt; &#123;/* 概览数据 */&#125; &#123;!pageStateProxy.isExpand &amp;&amp; ( &lt;ChartsInfo &#123;...props&#125; pageStateObserver=&#123;pageStateObserver&#125; /&gt; )&#125; &#123;/* 图表 */&#125; &#123;!pageStateProxy.isExpand &amp;&amp; ( &lt;EchartsPage &#123;...props&#125; pageStateObserver=&#123;pageStateObserver&#125; echartsData=&#123;pageStateProxy.echartsData&#125; activeTab=&#123;pageStateProxy.activeTab&#125; chartsOrder=&#123;pageStateProxy.chartsOrder&#125; /&gt; )&#125; &#123;/* 表格 */&#125; &lt;TablePage &#123;...props&#125; pageStateObserver=&#123;pageStateObserver&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default ProductionPage;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Rollup打包库文件","slug":"2022-10-26-Rollup打包库文件","date":"2022-10-25T16:00:00.000Z","updated":"2023-02-05T11:42:35.309Z","comments":true,"path":"2022/10/26/2022-10-26-Rollup打包库文件/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/10/26/2022-10-26-Rollup%E6%89%93%E5%8C%85%E5%BA%93%E6%96%87%E4%BB%B6/","excerpt":"","text":"Rollup打包库文件1、安装全局安装rollup npm i rollup -g 2、新建rollup.config.js文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//默认集成了对 scss、less、stylus 的支持。const postcss = require( &quot;rollup-plugin-postcss&quot;)//css加前缀const autoprefixer = require( &quot;autoprefixer&quot;)//css压缩const cssnano = require( &quot;cssnano&quot;)//生成类型文件const typescript = require( &quot;@rollup/plugin-typescript&quot;)//处理引入的外部依赖const &#123;nodeResolve&#125; = require( &quot;@rollup/plugin-node-resolve&quot;)// 自动生成externals属性const &#123;externals&#125; = require( &quot;rollup-plugin-node-externals&quot;)// 支持基于 CommonJS 模块方式 npm 包。const commonjs = require(&quot;@rollup/plugin-commonjs&quot;)// 处理图像文件const image = require(&#x27;@rollup/plugin-image&#x27;)const path = require( &#x27;path&#x27;) const config=&#123; input: &quot;src/index.ts&quot;, output: [&#123; dir: &#x27;dist&#x27;, format: &#x27;es&#x27;, exports: &#x27;named&#x27;, // 指定导出模式（自动、默认、命名、无） name:&quot;esae&quot;, preserveModules: true, // 保留模块结构 preserveModulesRoot: &#x27;src&#x27;, // 将保留的模块放在根级别的此路径下 &#125;], plugins: [ image(), commonjs(), postcss(&#123; plugins: [autoprefixer(), cssnano()], // 抽离单独的css文件，默认打包根目录 extract: &quot;style.css&quot;, &#125;), typescript(&#123; outDir: &quot;dist&quot;, declaration: true, declarationDir: &quot;dist&quot;, &#125;), // 处理外部依赖 nodeResolve(), // externals(&#123; // devDeps: false, // devDependencies 类型的依赖就不用加到 externals 了。 // &#125;), ], //不需要打包的依赖 external: [ &quot;ahooks&quot;, &quot;antd&quot;, &quot;react-redux&quot;, &quot;redux&quot;, &quot;@reduxjs/toolkit&quot;, &quot;react-router&quot;, &quot;react-router-dom&quot;, &quot;react&quot;, &quot;react-dom&quot;, &quot;i18nNext&quot;, &quot;react-i18next&quot;, &quot;i18next-browser-languagedetector&quot;, &quot;axios&quot;, &quot;moment&quot;, &quot;xlsx&quot;, &quot;react-resizable&quot;, &quot;react-dnd&quot;, &quot;react-window&quot;, &quot;react-contextmenu&quot;, &quot;react-sortable-hoc&quot;, &quot;react-dnd-html5-backend&quot;, &quot;react-draggable&quot;,],&#125; export default config 3、配置打包命令在package.json文件中 --bundleConfigAsCjs mjs并位于项目的根目录中。除非使用–configPlugin或–bundleConfigAsCjs选项，否则Rollup将直接使用Node导入文件 1234&quot;scripts&quot;: &#123; &quot;build-antd&quot;: &quot;rollup -c rollup.antd.config.js --bundleConfigAsCjs&quot;, &quot;build&quot;: &quot;rollup -c --bundleConfigAsCjs &amp;&amp; npm run build-antd&quot;,&#125;,","categories":[],"tags":[{"name":"Rollup","slug":"Rollup","permalink":"https://gitee.com/shimmer612/myBlog/tags/Rollup/"}]},{"title":"实现“羊了个羊”消消乐（react）","slug":"2022-09-19-实现“羊了个羊”消消乐（react）","date":"2022-09-18T16:00:00.000Z","updated":"2023-02-06T01:10:36.328Z","comments":true,"path":"2022/09/19/2022-09-19-实现“羊了个羊”消消乐（react）/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/09/19/2022-09-19-%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A%E2%80%9D%E6%B6%88%E6%B6%88%E4%B9%90%EF%BC%88react%EF%BC%89/","excerpt":"","text":"实现“羊了个羊”消消乐（react）体验地址：https://code.juejin.cn/pen/7143974476500172814?mode=light和文章的代码写的有点不同。 1、前言其实在羊了个羊出来的很久之前，我女朋友经常玩的一款游戏叫《方块物语》,就是一样的玩法，如下图。 当时看到的时候，就想着怎么去实现。也只是在脑海中构思了一下，没有动手行动起来。 然后看到了羊了个羊。诶，这不是和我女朋友之前玩的游戏一样吗？正好手头没什么事。就尝试了实现了一下。 2、实现1、开始准备由于懒得去搭项目，正好自己有个平时学习的react项目，就加个路由用react实现。 首先是布局，分为上中下三个部分，标题，游戏区域，操作区域。 就不说了。 2、游戏区域生成、是否被覆盖的判断。初始数据，这里用的是12个文字, name:文字 color:背景颜色 position:对应的位置分别是[第几层,第几行,第几个] 由于想偷懒，我直接每个同时放了三个。 1234567891011121314151617181920212223242526272829303132333435363738const gameItemsArr = [ &#123;name: &#x27;马&#x27;, color: &#x27;#5470c6&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;马&#x27;, color: &#x27;#5470c6&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;马&#x27;, color: &#x27;#5470c6&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;驰&#x27;, color: &#x27;#fac858&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;驰&#x27;, color: &#x27;#fac858&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;驰&#x27;, color: &#x27;#fac858&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;朱&#x27;, color: &#x27;#ee6666&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;朱&#x27;, color: &#x27;#ee6666&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;朱&#x27;, color: &#x27;#ee6666&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;振&#x27;, color: &#x27;#73c0de&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;振&#x27;, color: &#x27;#73c0de&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;振&#x27;, color: &#x27;#73c0de&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;骚&#x27;, color: &#x27;#3bd272&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;骚&#x27;, color: &#x27;#3bd272&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;骚&#x27;, color: &#x27;#3bd272&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;刘&#x27;, color: &#x27;#9a60b4&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;刘&#x27;, color: &#x27;#9a60b4&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;刘&#x27;, color: &#x27;#9a60b4&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;胖&#x27;, color: &#x27;#ea7ccc&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;胖&#x27;, color: &#x27;#ea7ccc&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;胖&#x27;, color: &#x27;#ea7ccc&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;邢&#x27;, color: &#x27;#c14cac&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;邢&#x27;, color: &#x27;#c14cac&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;邢&#x27;, color: &#x27;#c14cac&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;吊&#x27;, color: &#x27;#f08300&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;吊&#x27;, color: &#x27;#f08300&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;吊&#x27;, color: &#x27;#f08300&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;龙&#x27;, color: &#x27;#004eff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;龙&#x27;, color: &#x27;#004eff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;龙&#x27;, color: &#x27;#004eff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;楞&#x27;, color: &#x27;#00e4ff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;楞&#x27;, color: &#x27;#00e4ff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;楞&#x27;, color: &#x27;#00e4ff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;张&#x27;, color: &#x27;#c0e8ff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;张&#x27;, color: &#x27;#c0e8ff&#x27;, position: [null, null, null]&#125;, &#123;name: &#x27;张&#x27;, color: &#x27;#c0e8ff&#x27;, position: [null, null, null]&#125;,]; 接下来是生成游戏区域的items 这边简单说一下level当前的关卡。一共设置了6个关卡。 floorItemsArr:每层有多少个，第一层9个，3的平方，第二层16个,4的平方依次类推，第一关有两层。 每层就是个正方形。 因为还要有空缺。这边也是偷懒，每个等级有多少空的。剩下的数组是三的倍数就可以了。 然后从上面的gameItemsArr取数据，看看不是空的item是不是36的倍数。 这边图省事也是写死的。 然后和空item数组拼接一下。 使用sort(()=&gt;MathMath.random() - 0.5)打乱 然后依次从allItems取出每层的item 为了显示层级效果最上层的z-index值最大。这里也是偷懒写死的 最后判断每个元素的位置 每层的宽度和z-index。 第一关最后就得到了一个这样的数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 生成游戏itemsexport const itemsArr = (level) =&gt; &#123; let arr = [...gameItemsArr]; // 每层有多少item const floorItemsArr = [9, 16, 25, 36, 49, 64, 81]; const floorNumsArr = [3, 4, 5, 6, 7, 8, 9]; // 每个等级有多少空item数组 const noItemsNum = [7, 14, 14, 24, 49, 40]; // 每个等级有多少item数组 const itemsNum = [18, 36, 72, 111, 150, 240]; // 空item数组 const noItemsArr = []; let i = noItemsNum[level - 1]; while (i &gt; 0) &#123; noItemsArr.push(&#123;name: &#x27;&#x27;, color: &#x27;&#x27;, position: [null, null, null]&#125;); i--; &#125; // 最后不完整的取几个 const getArrItems = ((itemsNum[level - 1] / 3) % 12) * 3; const otherItemsArr = arr .map((i, index) =&gt; &#123; if (index &lt; getArrItems) &#123; return i; &#125; return null; &#125;) .filter((i) =&gt; i); let itemsNumsArr = []; if (level === 1) &#123; itemsNumsArr = otherItemsArr; &#125; if (level === 2) &#123; itemsNumsArr = arr; &#125; if (level === 3) &#123; itemsNumsArr = arr.concat(arr); &#125; if (level === 4) &#123; arr = [...gameItemsArr]; itemsNumsArr = arr.concat(arr, arr, otherItemsArr); &#125; if (level === 5) &#123; arr = [...gameItemsArr]; itemsNumsArr = arr.concat(arr, arr, arr, otherItemsArr); &#125; if (level === 6) &#123; arr = [...gameItemsArr]; itemsNumsArr = arr.concat(arr, arr, arr, arr, arr, otherItemsArr); &#125; //打乱数组 const allItems = itemsNumsArr.concat(noItemsArr).sort(() =&gt; Math.random() - 0.5); const resultArr = []; floorItemsArr.splice(0, level + 1).map((item, fIndex) =&gt; &#123; resultArr.push(allItems.splice(0, item)); &#125;); const zIndex = [6, 5, 4, 3, 2, 1]; return resultArr.map((item, index) =&gt; &#123; return &#123; arr: [ ...item.map((i, j) =&gt; &#123; i.position = [index + 1, parseInt(j / floorNumsArr[index]) + 1, (j + 1) % floorNumsArr[index] || floorNumsArr[index]]; return &#123;...i&#125;; &#125;), ], zIndex: zIndex[index], width: (index + 3) * 35, &#125;; &#125;);&#125;; 得到了数组以后，就可以渲染页面了,但是还要解决覆盖的问题。 像上面那样，每一个上一层的元素覆盖了下一层的4个元素。 上面我们设置的position就排上了用场。 例如第一层的第一个位置是[1,1,1],那它所覆盖的元素就是[2,1,1],[2,1,2],[2,2,1],[2,2,2] 以此类推循环判断，就得到了一个都是position数组。 然后通过findIndex或者filter判断当前点击的item在不在这个数组当中。 在就不能点击，不在就可以点击。 为了能点击到下层，有个这个属性pointer-events:none设置给父元素，点击可以穿透，为了子元素可以点击。item设置pointer-events:auto 代码如下。 123456789101112131415161718192021222324252627export const isItemCanClick = (item, allItems) =&gt; &#123; const nowItem = &#123;...item&#125;; const nowItemFloor = nowItem.position[0]; const upFloor = allItems[nowItemFloor - 2]?.arr.filter((itemNow) =&gt; itemNow.name !== &#x27;&#x27;) || []; // 最底下层不判断 if (upFloor.length === 0) return true; let midArr = []; upFloor.map((itemNowM) =&gt; &#123; const position = itemNowM.position; const a = [position[0] + 1, position[1], position[2]]; const b = [position[0] + 1, position[1], position[2] + 1]; const c = [position[0] + 1, position[1] + 1, position[2]]; const d = [position[0] + 1, position[1] + 1, position[2] + 1]; midArr.push(a); midArr.push(b); midArr.push(c); midArr.push(d); &#125;); const isCanClick = midArr.filter((mItem) =&gt; nowItem.position[0] === mItem[0] &amp;&amp; nowItem.position[1] === mItem[1] &amp;&amp; nowItem.position[2] === mItem[2]) .length === 0; return isCanClick;&#125;; 这样就可以完美生成我们的游戏区域了 12345678910111213141516171819202122232425262728293031323334353637&lt;div className=&quot;gameArea&quot;&gt; &#123;gameItemsArr.map((item, index) =&gt; &#123; return ( &lt;div className=&quot;gameAreaFloor&quot; key=&#123;item.zIndex&#125; style=&#123; item.arr.filter((k) =&gt; k.name !== &#x27;&#x27;).length !== 0 ? &#123;zIndex: item.zIndex, width: item.width, height: item.width&#125; : &#123;display: &#x27;none&#x27;&#125; &#125;&gt; &#123;item.arr.map((gameItem, gameIndex) =&gt; &#123; return ( &lt;div onClick=&#123;() =&gt; &#123; if (gameItem.name === &#x27;&#x27; || !isItemCanClick(gameItem, gameItemsArr)) return; moveItem(gameItem, gameIndex, index); &#125;&#125; key=&#123;gameIndex&#125; style=&#123; gameItem.name === &#x27;&#x27; ? &#123;opacity: 0, pointerEvents: &#x27;none&#x27;&#125; : isItemCanClick(gameItem, gameItemsArr) ? &#123;background: gameItem.color&#125; : &#123;background: &#x27;#c2cbcbee&#x27;&#125; &#125; className=&quot;gameItem&quot;&gt; &#123;gameItem.name&#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; 3、操作判断这里就比较简单，判断当前点击的层数，和点击的item。 把item push到操作的数组里面。 通过splice删除当前点击的元素并添加一个name为&#39;&#39;的item 再判断当前点击的元素在不在操作的数组里，在就找到存在的数组，放到一起，不在就放到前面， 有三个一样就清除。都是通过findIndex和splice 当前层级都清除完了，就进入下一关 level+1,重新生成游戏区域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202import React, &#123;useState, useEffect&#125; from &#x27;react&#x27;;import &#123;itemsArr&#125; from &#x27;./content&#x27;;import &#x27;./page.css&#x27;;import &#123;isItemCanClick&#125; from &#x27;./action&#x27;;let hasThreeItem = 0;const GameBox = () =&gt; &#123; // 分数 const [score, setScore] = useState(0); // 第几关 const [level, setLevel] = useState(1); // 游戏的item const [gameItemsArr, setGameItemsArr] = useState(itemsArr(level)); // 操作的数组 const [operateArr, setOperateArr] = useState([null, null, null, null, null, null, null]); // 当前点击的item，撤回用 const [nowClickItemInfo, setNowClickItemInfo] = useState([null, null, null]); // 操作次数 const [isOperate, setIsOperate] = useState([0, 0, 0]); useEffect(() =&gt; &#123; if (operateArr.filter((item) =&gt; item).length === 7) &#123; alert(&#x27;游戏失败！&#x27;); window.location.reload(); &#125; &#125;, [operateArr]); // 判断游戏是否下一关 useEffect(() =&gt; &#123; if (gameItemsArr.length === 0) &#123; alert(`恭喜你通过第$&#123;level&#125;关了！！！`); if (level === 6) &#123; alert(&#x27;恭喜你通关了！！！&#x27;); return; &#125; setLevel((prev) =&gt; prev + 1); setGameItemsArr((prev) =&gt; &#123; prev = itemsArr(level + 1); return [...prev]; &#125;); &#125; &#125;, [gameItemsArr, level]); // 点击item const moveItem = (item, index, whichFloor) =&gt; &#123; hasThreeItem = 0; let hasThreeindex = 0; // 记录当前的点击item信息 const nowClickItem = [item, index, whichFloor]; setNowClickItemInfo(nowClickItem); // 放到操作区 setOperateArr((prev) =&gt; &#123; const currentIndex = prev.findIndex((k) =&gt; k &amp;&amp; k.name === item.name); prev.pop(); if (currentIndex &gt; -1) &#123; prev.splice(currentIndex, 0, item); &#125; else &#123; prev.unshift(item); &#125; return [...prev]; &#125;); // 操作原始数组 setGameItemsArr((prev) =&gt; &#123; prev[whichFloor].arr.splice(index, 1, &#123;...item, name: &#x27;&#x27;, color: &#x27;&#x27;&#125;); if (prev[prev.length - 1].arr.filter((item) =&gt; item.name !== &#x27;&#x27;).length === 0) &#123; return []; &#125; else &#123; return [...prev]; &#125; &#125;); // 判断清除逻辑 operateArr.map((newItem, newIndex) =&gt; &#123; if (newItem &amp;&amp; newItem.name === item.name) &#123; hasThreeItem++; hasThreeindex = newIndex; &#125; return null; &#125;); // 如果有三个一样的 if (hasThreeItem === 2) &#123; setOperateArr((prev) =&gt; &#123; prev.splice(hasThreeindex - 1, 3); prev.push(null); prev.push(null); prev.push(null); return [...prev]; &#125;); setScore((prev) =&gt; prev + 100); &#125; &#125;; return ( &lt;div className=&quot;gamebox&quot;&gt; &#123;/* 标题区域 */&#125; &lt;div className=&quot;titleArea&quot;&gt; &lt;div className=&quot;titleAreaTitle&quot;&gt;汉字方块&lt;/div&gt; &lt;div className=&quot;titleAreaScore&quot;&gt; &lt;span&gt;分数:&lt;/span&gt; &lt;span&gt;&#123;score&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;/* 游戏区域 */&#125; &lt;div className=&quot;gameArea&quot;&gt; &#123;gameItemsArr.map((item, index) =&gt; &#123; return ( &lt;div className=&quot;gameAreaFloor&quot; key=&#123;item.zIndex&#125; style=&#123; item.arr.filter((k) =&gt; k.name !== &#x27;&#x27;).length !== 0 ? &#123;zIndex: item.zIndex, width: item.width, height: item.width&#125; : &#123;display: &#x27;none&#x27;&#125; &#125;&gt; &#123;item.arr.map((gameItem, gameIndex) =&gt; &#123; return ( &lt;div onClick=&#123;() =&gt; &#123; if (gameItem.name === &#x27;&#x27; || !isItemCanClick(gameItem, gameItemsArr)) return; moveItem(gameItem, gameIndex, index); &#125;&#125; key=&#123;gameIndex&#125; style=&#123; gameItem.name === &#x27;&#x27; ? &#123;opacity: 0, pointerEvents: &#x27;none&#x27;&#125; : isItemCanClick(gameItem, gameItemsArr) ? &#123;background: gameItem.color&#125; : &#123;background: &#x27;#c2cbcbee&#x27;&#125; &#125; className=&quot;gameItem&quot;&gt; &#123;gameItem.name&#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; &#123;/* 下方格子 */&#125; &lt;div className=&quot;operateArea&quot;&gt; &#123;operateArr.map((item, index) =&gt; &#123; if (!item) &#123; return &lt;div key=&#123;index&#125; className=&quot;gameItemOperate&quot;&gt;&lt;/div&gt;; &#125; else &#123; return ( &lt;div key=&#123;index&#125; style=&#123;&#123;background: item.color&#125;&#125; className=&quot;gameItemOperate&quot;&gt; &#123;item.name&#125; &lt;/div&gt; ); &#125; &#125;)&#125; &lt;/div&gt; &lt;div className=&quot;operateBtnArr&quot;&gt; &lt;span className=&quot;operateBtn&quot; style=&#123;isOperate[0] === 1 ? &#123;background: &#x27;grey&#x27;&#125; : &#123;&#125;&#125; onClick=&#123;() =&gt; &#123; if (isOperate[0] === 1) return; setGameItemsArr((prev) =&gt; &#123; prev = itemsArr(level); return [...prev]; &#125;); setIsOperate((prev) =&gt; &#123; prev[0] = 1; return [...prev]; &#125;); &#125;&#125;&gt; 随机 &lt;/span&gt; &lt;span className=&quot;operateBtn&quot; style=&#123;isOperate[1] === 1 ? &#123;background: &#x27;grey&#x27;&#125; : &#123;&#125;&#125; onClick=&#123;() =&gt; &#123; if (isOperate[1] === 1) return; setOperateArr((prev) =&gt; &#123; const lastIndex = prev.findIndex((item) =&gt; item &amp;&amp; item.name === nowClickItemInfo[0].name); prev.splice(lastIndex, 1); return [...prev]; &#125;); setGameItemsArr((prev) =&gt; &#123; prev[nowClickItemInfo[2]].arr[nowClickItemInfo[1]] = nowClickItemInfo[0]; return [...prev]; &#125;); setIsOperate((prev) =&gt; &#123; prev[1] = 1; return [...prev]; &#125;); &#125;&#125;&gt; 撤回 &lt;/span&gt; &lt;span className=&quot;operateBtn&quot;&gt;加三个格子&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default GameBox;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"浏览器相同地址不同标签页的`localStorage、sessionStorage、cookie`","slug":"2022-09-09-浏览器相同地址不同标签页的localStorage、sessionStorage、cookie","date":"2022-09-08T16:00:00.000Z","updated":"2023-02-05T11:42:20.257Z","comments":true,"path":"2022/09/09/2022-09-09-浏览器相同地址不同标签页的localStorage、sessionStorage、cookie/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/09/09/2022-09-09-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%90%8C%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%90%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84localStorage%E3%80%81sessionStorage%E3%80%81cookie/","excerpt":"","text":"浏览器相同地址不同标签页的localStorage、sessionStorage、cookie1、同样的地址打开多个不同的标签页1、localStorage共用 2、cookie共用 3、sessionStorage不共用 2、关闭浏览器或者标签页1、sessionStorage清除 2、localStorage不清除，需要手动清除否则一直保留 3、cookie关闭标签页不清除，关闭浏览器清除","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"}]},{"title":"react自定义hook,useWebSocket","slug":"2022-08-09-react自定义hook,useWebSocket","date":"2022-08-08T16:00:00.000Z","updated":"2023-02-05T11:42:48.273Z","comments":true,"path":"2022/08/09/2022-08-09-react自定义hook,useWebSocket/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/08/09/2022-08-09-react%E8%87%AA%E5%AE%9A%E4%B9%89hook,useWebSocket/","excerpt":"","text":"react自定义hook,useWebSocket1、描述本来项目的告警和消息提醒是用的接口30秒调用一次，这次要改成webSocket传输。 因为前端是用的https，后端用的http，后端的socket只支持ws不支持wss,这里使用了webpack-dev-server的proxy代理了一下。 target：ws目标地址、pathRewrite:地址重写，这里是把/aapp_socket重写成aapp/websocket,ws：是否开启socket,secure： 默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false ，changeOrigin：是否跨域。差不多就这个意思 123456789&#x27;/aapp_socket&#x27;: &#123; target: `ws://xxx.xxx.xxx/`, pathRewrite: &#123; &#x27;^/aapp_socket&#x27;: &#x27;aapp/websocket&#x27;, &#125;, ws: true, secure: false, changeOrigin: true, &#125;, 使用连接的地址: 1`wss://localhost:3000/aapp_socket`; 实际的访问的地址就是： 1`ws://xxx.xxx.xxx/aapp/websocket 2、代码这里socket,没有配置心跳监测，还是通过我主动去推送来获取信息。这里是获取告警数和消息数量， 首先绑定websocket的事件。主要就是在message的事件中，连接成功后端返回的是sucess,就不做操作。后面就是判断返回的消息格式是否正确，如果不正确就重新连接。 还可以把获取消息的时间间隔，和重新连接间隔，地址等变量抽出来，作为参数传进来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import &#123;useCallback, useRef, useState, useEffect&#125; from &#x27;react&#x27;;const token = window.localStorage.getItem(&#x27;authorization&#x27;);const userId = JSON.parse(window.localStorage.getItem(&#x27;userInfo&#x27;) || &#x27;&#x27;)?.id;// 获取告警数量const UNREAD_WARN_COUNT = &#x27;UNREAD_WARN_COUNT&#x27;;// 获取消息数量const UNREAD_MSG_COUNT = &#x27;UNREAD_MSG_COUNT&#x27;;// 获取消息的间隔const INT_TIME = 5000;// websocket状态const webSocketStatus = &#123; CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3,&#125;;const useWebSocket = () =&gt; &#123; const [reset, setReset] = useState&lt;boolean&gt;(false); const socket = useRef&lt;WebSocket&gt;(); const sendCount = useRef&lt;number&gt;(1); const [alarmCount, setAlarmCount] = useState&lt;number&gt;(0); const [messageCount, setMessageCount] = useState&lt;number&gt;(0); // 开启事件,主动获取数据 const socketOnOpen = useCallback(() =&gt; &#123; // 判断连接状态是不是open if (socket?.current?.readyState === webSocketStatus.OPEN) &#123; // 第一次加载触发一次 socket?.current?.send(JSON.stringify(&#123;businessKey: [UNREAD_MSG_COUNT, UNREAD_WARN_COUNT]&#125;)); &#125; const timer = setInterval(() =&gt; &#123; if (socket?.current?.readyState === webSocketStatus.OPEN) &#123; socket?.current?.send(JSON.stringify(&#123;businessKey: [UNREAD_MSG_COUNT, UNREAD_WARN_COUNT]&#125;)); &#125; &#125;, INT_TIME); // 返回信息出错清除定时器 if (sendCount.current === 0) &#123; clearInterval(timer); setReset(true); &#125; &#125;, [sendCount]); // 关闭事件重新连接 const socketOnClose = useCallback(() =&gt; &#123; setReset(true); &#125;, []); // 出错事件 const socketOnError = useCallback((err: any) =&gt; &#123; console.log(&#x27;err: &#x27;, err); &#125;, []); // 收发信息 const socketOnMessage = useCallback( (e: any) =&gt; &#123; if (e.data === &#x27;success&#x27;) return; const alarmCountObj = JSON.parse(e.data); const paramNameArr = Object.keys(alarmCountObj); // 判断返回告警保持连接否则断开连接 if (paramNameArr[1] === &#x27;UNREAD_WARN_COUNT&#x27;) &#123; sendCount.current += 1; setAlarmCount(alarmCountObj.UNREAD_WARN_COUNT); setMessageCount(alarmCountObj.UNREAD_MSG_COUNT); &#125; else &#123; sendCount.current = 0; &#125; &#125;, [sendCount], ); // 初始化连接socket const socketInit = useCallback(() =&gt; &#123; try &#123; const scoketUrl = `wss://$&#123;window.location.host&#125;/aapp_socket/$&#123;userId&#125;/$&#123;token&#125;`; const socketObj = new WebSocket(scoketUrl); socketObj.addEventListener(&#x27;close&#x27;, socketOnClose); socketObj.addEventListener(&#x27;error&#x27;, socketOnError); socketObj.addEventListener(&#x27;message&#x27;, socketOnMessage); socketObj.addEventListener(&#x27;open&#x27;, socketOnOpen); socket.current = socketObj; sendCount.current = 1; &#125; catch (err) &#123; console.log(&#x27;err: &#x27;, err); &#125; &#125;, [socketOnClose, socketOnError, socketOnMessage, socketOnOpen]); // 初始化连接socket useEffect(() =&gt; &#123; socketInit(); &#125;, [socketInit]); // 断线重连 useEffect(() =&gt; &#123; if (!reset) return; setTimeout(() =&gt; &#123; socketInit(); setReset(false); &#125;, 30000); &#125;, [reset, socketInit]); return [alarmCount, messageCount];&#125;;export default useWebSocket; 使用 12//socket连接 const [alarmCount, messageCount] = useWebSocket();","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Echarts柱状极坐标风向玫瑰图的实现","slug":"2022-05-19-echarts实现风向玫瑰图","date":"2022-05-18T16:00:00.000Z","updated":"2023-02-06T01:11:44.197Z","comments":true,"path":"2022/05/19/2022-05-19-echarts实现风向玫瑰图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/05/19/2022-05-19-echarts%E5%AE%9E%E7%8E%B0%E9%A3%8E%E5%90%91%E7%8E%AB%E7%91%B0%E5%9B%BE/","excerpt":"","text":"Echarts柱状极坐标风向玫瑰图的实现echarts代码本来看到玫瑰图，就看到了echarts示例中饼图的南丁格尔玫瑰图。 发现不太像。后来发现是柱状图极坐标系堆叠图。 图例是自己实现的，因为是绑定到单个数据上。 eharts的配置项真的太难了。找的很头疼，实现的也很头疼。 效果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import React, &#123;FC, useEffect, useState&#125; from &#39;react&#39;;import ReactECharts from &#39;echarts-for-react&#39;;import styles from &#39;..&#x2F;styles.module.scss&#39;;import &#123;color, pathArr&#125; from &#39;..&#x2F;constant&#39;;interface Title &#123; title: string; flag: number;&#125;const EchartsPageB: FC&lt;any&gt; &#x3D; (&#123;picData&#125;) &#x3D;&gt; &#123; const [titleArr, setTitleArr] &#x3D; useState&lt;Title[]&gt;([]); const [echartsData, setEchartsData] &#x3D; useState&lt;any[]&gt;([]); const [page, setPage] &#x3D; useState&lt;number&gt;(1); const [currentPage, setCurrentPage] &#x3D; useState&lt;number&gt;(1); useEffect(() &#x3D;&gt; &#123; setEchartsData(picData.series); const count &#x3D; picData.series.length % 12; if (count &#x3D;&#x3D;&#x3D; 0) &#123; setPage(picData.series.length &#x2F; 12); &#125; else &#123; const str &#x3D; String(picData.series.length &#x2F; 12); setPage(Number(parseInt(str, 10)) + 1); &#125; setTitleArr(picData.series.map((item: Title) &#x3D;&gt; (&#123;title: item.title, flag: 1&#125;))); &#125;, [picData]); const option &#x3D; &#123; grid: &#123; left: 50, right: 50, bottom: 0, &#125;, angleAxis: &#123; type: &#39;category&#39;, axisTick: false, boundaryGap: false, splitLine: &#123; show: true, lineStyle: &#123; color: &#39;#8d979d&#39;, &#125;, &#125;, axisLabel: &#123;color: &#39;#8d979d&#39;&#125;, data: pathArr, &#125;, tooltip: &#123; trigger: &#39;item&#39;, position(pos: number[], params: any, dom: any, rect: any, size: any) &#123; &#x2F;&#x2F; 鼠标在左侧时 tooltip 显示到右侧，鼠标在右侧时 tooltip 显示到左侧。 interface Obj &#123; left: string | number; top: number | string; bottom: number | string; &#125; const obj: Obj &#x3D; &#123;left: &#39;&#39;, top: &#39;&#39;, bottom: &#39;&#39;&#125;; const count: boolean &#x3D; pos[1] &lt; size.viewSize[1] &#x2F; 2; if (count) &#123; obj.bottom &#x3D; 10; &#125; else &#123; obj.top &#x3D; 10; &#125; obj.left &#x3D; pos[0] &lt; size.viewSize[0] &#x2F; 2 ? pos[0] : pos[0] - size.contentSize[0]; return obj; &#125;, backgroundColor: &#39;rgba(1,9,13,0.7)&#39;, borderWidth: 1, borderColor: &#39;#2E3C44&#39;, formatter: (params: any) &#x3D;&gt; &#123; const data &#x3D; picData.series[params.dataIndex].tips[0]; const infoHtml &#x3D; &#96;&lt;div style&#x3D;&quot;width:250px;padding:0;&quot;&gt; &lt;div style&#x3D;&quot;color:white;padding:10px 9px 10px 9px;font-size:16px;font-weight:bold&quot;&gt;风向玫瑰图&lt;&#x2F;div&gt; &lt;div class&#x3D;$&#123;styles.tooltipHr&#125;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;$&#123;styles.styleA&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleE&#125;&gt;风向:&lt;&#x2F;span&gt; &lt;div class&#x3D;$&#123;styles.styleB&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleC&#125;&gt;$&#123;data[0].path&#125;&lt;&#x2F;span&gt; &lt;span class&#x3D;$&#123;styles.styleD&#125;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;$&#123;styles.styleA&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleE&#125;&gt;风速区间:&lt;&#x2F;span&gt; &lt;div class&#x3D;$&#123;styles.styleB&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleC&#125;&gt;$&#123;data[2].value&#125;&lt;&#x2F;span&gt; &lt;span class&#x3D;$&#123;styles.styleD&#125;&gt;m&#x2F;s&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;$&#123;styles.styleA&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleE&#125;&gt;频次:&lt;&#x2F;span&gt; &lt;div class&#x3D;$&#123;styles.styleB&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleC&#125;&gt;$&#123;data[0].value&#125;&lt;&#x2F;span&gt; &lt;span class&#x3D;$&#123;styles.styleD&#125;&gt;次&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;$&#123;styles.styleA&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleE&#125;&gt;频次占比:&lt;&#x2F;span&gt; &lt;div class&#x3D;$&#123;styles.styleB&#125;&gt; &lt;span class&#x3D;$&#123;styles.styleC&#125;&gt;$&#123;data[3].value&#125;&lt;&#x2F;span&gt; &lt;span class&#x3D;$&#123;styles.styleD&#125;&gt;%&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;; return infoHtml; &#125;, &#125;, polar: &#123; radius: &#39;80%&#39;, center: [&#39;42%&#39;, &#39;50%&#39;], &#125;, radiusAxis: &#123;&#125;, series: [ &#123; type: &#39;bar&#39;, data: echartsData.map((item: any) &#x3D;&gt; &#123; const pathIndex &#x3D; pathArr.findIndex((k) &#x3D;&gt; k &#x3D;&#x3D;&#x3D; item.tips[0][0].path); const newValue &#x3D; item.values[0]; const dataArr &#x3D; [newValue, pathIndex]; return dataArr; &#125;), coordinateSystem: &#39;polar&#39;, colorBy: &#39;data&#39;, stack: &#39;path&#39;, &#125;, ], color, &#125;; const changeLegend &#x3D; (item: Title, index: number) &#x3D;&gt; &#123; if (item.flag &#x3D;&#x3D;&#x3D; 1) &#123; const newTitleArr &#x3D; titleArr; newTitleArr[index].flag &#x3D; 0; setTitleArr(newTitleArr); const newArr &#x3D; echartsData.map((k: any, j: number) &#x3D;&gt; &#123; const obj &#x3D; &#123;...k&#125;; if (index &#x3D;&#x3D;&#x3D; j) &#123; obj.values &#x3D; [0]; &#125; return obj; &#125;); setEchartsData(Object.assign([...newArr])); &#125; else if (item.flag &#x3D;&#x3D;&#x3D; 0) &#123; const newTitleArr &#x3D; titleArr; newTitleArr[index].flag &#x3D; 1; setTitleArr(newTitleArr); const arr &#x3D; picData.series.filter((k: any) &#x3D;&gt; k.title &#x3D;&#x3D;&#x3D; item.title); const newArr &#x3D; echartsData.map((x: any, j: number) &#x3D;&gt; &#123; const obj &#x3D; &#123;...x&#125;; if (index &#x3D;&#x3D;&#x3D; j) &#123; obj.values &#x3D; arr[0].values; &#125; return obj; &#125;); setEchartsData(Object.assign([...newArr])); &#125; &#125;; return ( &lt;div className&#x3D;&#123;styles.windRose&#125;&gt; &lt;div className&#x3D;&#123;styles.title&#125;&gt; &lt;span className&#x3D;&#123;styles.dot&#125; &#x2F;&gt; &lt;span className&#x3D;&#123;styles.stationName&#125;&gt;&#123;picData.title&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;ReactECharts option&#x3D;&#123;option&#125; style&#x3D;&#123;&#123;height: &#39;400px&#39;&#125;&#125; &#x2F;&gt; &lt;div className&#x3D;&#123;styles.legend&#125;&gt; &#123;titleArr.map((item: Title, index: number) &#x3D;&gt; &#123; if (index + 1 &gt; (currentPage - 1) * 12 &amp;&amp; index + 1 &lt; currentPage * 12) &#123; return ( &lt;div className&#x3D;&#123;styles.legendItem&#125; key&#x3D;&#123;item.title&#125;&gt; &lt;span className&#x3D;&#123;styles.legendIcon&#125; style&#x3D;&#123;&#123;background: item.flag ? color[index] : &#39;#6c7379&#39;&#125;&#125; onClick&#x3D;&#123;() &#x3D;&gt; &#123; changeLegend(item, index); &#125;&#125; &#x2F;&gt; &lt;span className&#x3D;&#123;styles.legendName&#125;&gt;&#123;item.title&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; ); &#125; return &#39;&#39;; &#125;)&#125; &lt;div className&#x3D;&#123;styles.changePage&#125;&gt; &lt;span className&#x3D;&#123;styles.changePageA&#125; onClick&#x3D;&#123;() &#x3D;&gt; &#123; if (currentPage &#x3D;&#x3D;&#x3D; 1) &#123; return; &#125; setCurrentPage(currentPage - 1); &#125;&#125;&gt; &#123;&#39;&lt;&#39;&#125; &lt;&#x2F;span&gt; &lt;span className&#x3D;&#123;styles.changePageB&#125;&gt;&#123;currentPage&#125;&lt;&#x2F;span&gt; &lt;span className&#x3D;&#123;styles.changePageC&#125;&gt;&#123;&#96;&#x2F; $&#123;page&#125;&#96;&#125;&lt;&#x2F;span&gt; &lt;span className&#x3D;&#123;styles.changePageD&#125; onClick&#x3D;&#123;() &#x3D;&gt; &#123; if (currentPage &#x3D;&#x3D;&#x3D; page) &#123; return; &#125; setCurrentPage(currentPage + 1); &#125;&#125;&gt; &#123;&#39;&gt;&#39;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125;;export default EchartsPageB; 样式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 .windRose &#123; display: flex; position: relative; flex-direction: column; width: 32%; margin-bottom: 10px; .title &#123; background-color: #0a445a; display: flex; align-items: center; border-radius: 7px; height: 30px; margin-bottom: 10px; .dot &#123; background-color: #097488; margin-left: 10px; margin-right: 10px; border-radius: 2px; width: 5px; height: 17px; &#125; .stationName &#123; font-size: 17px; &#125; &#125; .legend &#123; position: absolute; right: 0px; top: 60px; display: flex; flex-direction: column; width: 110px; height: 350px; overflow: hidden; .legendItem &#123; display: flex; width: 110px; align-items: center; justify-content: space-between; margin-bottom: 7px; .legendIcon &#123; width: 12px; height: 12px; border-radius: 2px; cursor: pointer; &#125; .legendName &#123; color: #fff; width: 80px; &#125; &#125; .changePage &#123; display: flex; align-items: center; justify-content: space-between; height: 30px; width: 100%; position: absolute; bottom: 0; right: 0; background-color: #0a445a; .changePageA &#123; width: 25px; height: 25px; text-align: center; border: 1px solid #00e4ff; border-radius: 4px; color: #00e4ff; cursor: pointer; &#125; .changePageB &#123; width: 25px; height: 25px; text-align: center; border: 1px solid #00e4ff; border-radius: 4px; color: #fff; &#125; .changePageC &#123; color: #fff; &#125; .changePageD &#123; width: 25px; height: 25px; text-align: center; border: 1px solid #00e4ff; border-radius: 4px; color: #00e4ff; cursor: pointer; &#125; &#125; &#125; &#125; .echartsBox &#123; overflow-y: scroll; height: calc(100% - 48px); .windFrqBox &#123; display: flex; flex-wrap: wrap; justify-content: space-between; &#125; .windRoseBox &#123; display: flex; flex-wrap: wrap; justify-content: space-between; &#125; &#125;.tooltipHr &#123; background: #4c555a; width: 250px; height: 2px; margin-bottom: 15px;&#125;.styleA &#123; display: flex; justify-content: space-between; align-items: center; padding: 0 9px 0 9px; margin-bottom: 10px;&#125;.styleE &#123; color: #fff; font-size: 14px; font-weight: bold;&#125;.styleB &#123; display: flex; align-items: center;&#125;.styleC &#123; color: #00e4ff; font-size: 14px; margin-right: 8px;&#125;.styleD &#123; color: #6c7379; width: 30px;&#125;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"echarts","slug":"echarts","permalink":"https://gitee.com/shimmer612/myBlog/tags/echarts/"}]},{"title":"reduxjs/toolkit使用","slug":"2022-05-09-reduxjsToolkit使用","date":"2022-05-08T16:00:00.000Z","updated":"2022-05-09T05:33:34.976Z","comments":true,"path":"2022/05/09/2022-05-09-reduxjsToolkit使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/05/09/2022-05-09-reduxjsToolkit%E4%BD%BF%E7%94%A8/","excerpt":"","text":"reduxjs/toolkit 使用1、安装要和react-redux一起使用 cnpm i react-redux @reduxjs/toolkit -D 2、新建 redux 文件夹在下面新建store.ts、slice.ts、hook.ts三个文件 store.ts1234567891011121314151617import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import stateSlice from &quot;./slice&quot;;import otherSlice from &quot;./otherSlice&quot;;export const store = configureStore(&#123; // 每个reducer代表一个模块的状态管理器 reducer: &#123; state: stateSlice, other: otherSlice, &#125;,&#125;);// RootState作用是返回store的方法getState的类型 functionexport type RootState = ReturnType&lt;typeof store.getState&gt;;// AppDispatch 作用是拿到Store的dispatch方法的类型 functionexport type AppDispatch = typeof store.dispatch; slice.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; createSlice, createAsyncThunk, PayloadAction &#125; from &quot;@reduxjs/toolkit&quot;;interface InitialState &#123; count: number; text?: string;&#125;const initialState: InitialState = &#123; count: 0, text: &quot;我是文字&quot;,&#125;;interface PromiseNum &#123; number: number;&#125;const promise_one: Promise&lt;PromiseNum&gt; = new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(&#123; number: 10 &#125;); &#125;, 3000);&#125;);// 异步Actionexport const getAsyncInfo = createAsyncThunk(&quot;getAsyncInfo&quot;, async () =&gt; &#123; const data = await promise_one; return data;&#125;);export const stateSlice = createSlice(&#123; name: &quot;state&quot;, initialState, reducers: &#123; add: (state) =&gt; &#123; state.count += 1; &#125;, minus: (state) =&gt; &#123; state.count -= 1; &#125;, change: (state) =&gt; &#123; state.text = &quot;我是改变了的文字&quot;; &#125;, back: (state) =&gt; &#123; state.text = &quot;我是文字&quot;; &#125;, &#125;, extraReducers: (builder) =&gt; &#123; // 进行请求阶段的一些操作 builder.addCase(getAsyncInfo.pending, () =&gt; &#123; console.log(&quot;进行中&quot;); &#125;); builder.addCase(getAsyncInfo.fulfilled, (state, action) =&gt; &#123; console.log(&quot;action.payload: &quot;, action.payload); //&#123;number:&quot;10&quot;&#125; console.log(&quot;state: &quot;, state.text); //我是文字 state.count += action.payload.number; console.log(&quot;成功&quot;); &#125;); builder.addCase(getAsyncInfo.rejected, () =&gt; &#123; console.log(&quot;失败&quot;); &#125;); &#125;,&#125;);export const &#123; add, minus, change, back &#125; = stateSlice.actions;export default stateSlice.reducer; hook.ts12345678import &#123; TypedUseSelectorHook, useDispatch, useSelector &#125; from &quot;react-redux&quot;;import type &#123; RootState, AppDispatch &#125; from &quot;./store&quot;;// use hook 节约每次引入type的工作// useSelector: 节约配置RootState typeexport const useAppDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;();export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector; 4、使用首先是在根页面，引入store，Provider 123456789101112131415161718import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; store &#125; from &quot;./redux/store&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement);root.render( &lt;React.StrictMode&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;);reportWebVitals(); 然后在对应页面中使用： 123456789101112131415161718192021222324252627282930313233343536373839import React from &quot;react&quot;;import &#123; shallowEqual &#125; from &quot;react-redux&quot;;import &#123; useAppDispatch, useAppSelector &#125; from &quot;../redux/hook&quot;;import &#123; add, minus, getAsyncInfo &#125; from &quot;../redux/slice&quot;;export const APage = () =&gt; &#123; console.log(&quot;A渲染了&quot;); const &#123; count &#125; = useAppSelector((state: any) =&gt; (&#123; ...state.state &#125;), shallowEqual); const dispatch = useAppDispatch(); return ( &lt;div&gt; &lt;h1&gt;我是Apage&lt;/h1&gt; &lt;h2&gt;我是count:&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(add()); &#125;&#125; &gt; 加1 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(minus()); &#125;&#125; &gt; 减1 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(getAsyncInfo()); &#125;&#125; &gt; 异步加10 &lt;/button&gt; &lt;/div&gt; );&#125;; 注意:同一个 slice 中的 state 只要改变了，那么只要使用该 slice 中数据的页面就会重新渲染。 使用其他 slice 中 state 的页面不受影响","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"useState问题记录","slug":"2022-04-28-useState问题记录","date":"2022-04-27T16:00:00.000Z","updated":"2022-04-28T06:18:41.831Z","comments":true,"path":"2022/04/28/2022-04-28-useState问题记录/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/04/28/2022-04-28-useState%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"useState问题记录遇到这样一个问题，在一个新增页面，需要通过表单项，使table的columns动态的增加一列减少一列。 我就把columns放在useState中，对然后通过useEffect对columns的数组进行push和pop 因为columns的操作项中有打开新的tab页的功能，发现打开同一个tab页的时候不是覆盖，而是会出现多个相同的activekey 一开始很莫名其妙，觉得出鬼了，别的页面也是一样的，没有问题，就这个页面有问题，一步步debugger找了半天的原因，原来是框架的addTab事件使用了useState拿到的那个panes一直是打开新增页面的panes的值。 代码如下：差不多就是这么个场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const addPage = (props)=&gt;&#123; const columns = [ &#123; title: &quot;奖品名称&quot;, dataIndex: &quot;name&quot;, &#125;, &#123; title: &quot;操作&quot;, key: &quot;action&quot;, render: (record) =&gt; ( &lt;a onClick=&#123;() =&gt; &#123; props.addTab(&#123; initSetting: &#123; id: record.id, &#125;, path: &quot;/prize/add/detail&quot;, title: &quot;奖品详情&quot;, &#125;); &#125;&#125; &gt; 详情 &lt;/a&gt; ) &#125; ]; const priceColumn = &#123; title: &quot;价格&quot;, dataIndex: &quot;price&quot;, &#125;, const [columns,setColumns] = useState(columns) useEffect(()=&gt;&#123; if(props.addColumns===&quot;1&quot;) &#123; setColumns(prev=&gt;&#123; prev.push(priceColumn) return [...prev] &#125;) &#125;else if(props.addColumns===&quot;2&quot;)&#123; setColumns(prev=&gt;&#123; prev.pop() return [...prev] &#125;) &#125; &#125;,[props.addColumns]) return &lt;Table columns=&#123;columns&#125; dataSource=&#123;props.value&#125;&gt;&#125; addTab的方法如下： panes一直是之前的panes，导致existedPane一直为undefined useRef一直获取到的是最新的，所以就一直往panes里加入相同的tab页 123456789101112131415161718192021222324const AddTab = (props)=&gt;&#123; //省略了一些代码..... const [panes, setPanes] = useState([]); const cachePanesRef = useRef(panes); //addtab后会调用的函数，就错在这里 const handleTabAdd = ($route) =&gt; &#123; setActivityPane($route.key); const existedPane = panes.find((c) =&gt; c.key === $route.key); const currentPane = flatRoutes.find((el) =&gt; el.key === $route.key); if (!existedPane) &#123; setPanes([ ...cachePanesRef.current, &#123; key: currentPane.key, path: currentPane.path, C: currentPane.component, name: $route.titleText || currentPane.name, initSetting: $route?.initSetting, &#125;, ]); return; &#125; //省略了一些代码.....&#125; 这样就形成了闭包，传过去panes数组一直是第一次点击打开的那个。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"}]},{"title":"虚拟Dom","slug":"2022-04-02-虚拟Dom","date":"2022-04-01T16:00:00.000Z","updated":"2022-04-02T11:22:23.103Z","comments":true,"path":"2022/04/02/2022-04-02-虚拟Dom/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/04/02/2022-04-02-%E8%99%9A%E6%8B%9FDom/","excerpt":"","text":"虚拟Dom一直以来都知道虚拟dom这个概念就是用代码来生成Dom，可以用diff算法 今天自己来实现一下，如下 创建一个对象，包含元素的各种属性，我这里就写了标签名和文字。嵌套的加个个Child 然后循环数组创建元素插入到body中，如果有child就插入到父元素中。 因为是一个数组，每次改变的时候就可以对比上次和本次dom数组 判断哪里变化了，变化了才修改这就是diff算法 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const vDom = [ &#123; node: &quot;p&quot;, text: &quot;我是p标签&quot;, &#125;, &#123; node: &quot;div&quot;, text: &quot;我是div&quot;, &#125;, &#123; node: &quot;ul&quot;, text: &quot;我是ul&quot;, child: [&#123; node: &quot;td&quot;, text: &quot;我是td&quot; &#125;], &#125;, ]; let tree = document.body; const showDom = (vDom, dom) =&gt; &#123; vDom.map((item) =&gt; &#123; const node = document.createElement(item.node); node.innerHTML = item.text; if (item.child) &#123; showDom(item.child, node); &#125; dom.appendChild(node); &#125;); &#125;; showDom(vDom, tree); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 页面中和dom元素显示如下：","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://gitee.com/shimmer612/myBlog/tags/js/"}]},{"title":"js的内存机制、内存泄露","slug":"2022-04-01-Js内存机制、内存泄露","date":"2022-03-31T16:00:00.000Z","updated":"2022-04-01T11:01:22.173Z","comments":true,"path":"2022/04/01/2022-04-01-Js内存机制、内存泄露/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/04/01/2022-04-01-Js%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/","excerpt":"","text":"js 的内存机制、内存泄露面试被问到 Js 的内存机制，以为自己不会，其实就是问基础类型和引用类型的存储方式，栈和堆，很亏，记录一下 1、内存机制Js 的内存空间 分为栈和堆、还有池（一般归于堆中）。栈存储变量数字，字符等，堆存储复杂类型，对象数组等。池存储常量。 js 中的基础类型存储在栈中，闭包中除外。先进后出，后进先出，乒乓球盒子 引用类型存储在堆中。 2、内存泄露虽然 Js 有着垃圾回收机制，但是并不是随时都在执行的因为开销比较大。 所以日常开发中要注意代码的规范 123456const obj = &#123; name: 1 &#125;;//obj 存在栈中 &#123; name: 1 &#125;存在堆中//obj存的是&#123; name: 1 &#125;地址const newObj = obj;//newObj得到的其实是 &#123; name: 1 &#125;地址//此时修改newObj，obj的值也会别修改，因为指向的同一个地址 如下 123456789101112131415161718//不声明变量直接使用a = 1;//使用this,this指向window，因为在函数执行时判断thisconst fn = function () &#123; this.a = 1;&#125;;fn();//闭包,不及时清除function fn() &#123; let a = 1; return function () &#123; a += 1; &#125;;&#125;//定时器没有清除一直触发setInterval(() =&gt; &#123; console.log(&quot;a&quot;);&#125;, 2000); 怎么去解决内存泄露 写代码的过程中注意规范 ES6 有两个新的数据类型weakMap和weakSet。如果改类型的值不再使用，就会被自动回收。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://gitee.com/shimmer612/myBlog/tags/js/"}]},{"title":"css显示隐藏元素","slug":"2022-04-01-css显示隐藏元素","date":"2022-03-31T16:00:00.000Z","updated":"2022-04-01T10:59:43.686Z","comments":true,"path":"2022/04/01/2022-04-01-css显示隐藏元素/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/04/01/2022-04-01-css%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/","excerpt":"","text":"css 显示隐藏元素面试问到的,记录一下 1、display:none元素在页面不显示 但是在 dom 结构上能看到 触发回流和重绘 1、其余属性block: 块元素 inline: 行内元素（默认值） inline-block：行内块元素 inherit：继承父元素的 display 属性 2、opacity：0透明度为 0 只是看不到，但是还存在，点击事件可以触发 会触发页面的重绘，不会触发重排 3、visibility:hidden元素不可见，但是会占据空间 不会触发事件 会触发页面的重绘，不会触发重排 1、其余属性visible： 默认值，可见 collapse：用在 table 元素上，表现和display:none一致；用在其它元素上，表现和visibility:hidden一致 inherit： 继承父元素的 visibility 的属性","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"git撤销提交","slug":"2022-04-01-撤销提交","date":"2022-03-31T16:00:00.000Z","updated":"2023-05-22T08:19:09.480Z","comments":true,"path":"2022/04/01/2022-04-01-撤销提交/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/04/01/2022-04-01-%E6%92%A4%E9%94%80%E6%8F%90%E4%BA%A4/","excerpt":"","text":"因为提交了错误的分支,记录一下后面使用 git 撤销提交1、git loggit log 查看 commit 记录，记下自己要撤回的 commitId 很重要因为 reset 后会删除提交记录，所以要把 commitId 记下来 2、git reset commitId撤销本地的提交 3、 git push origin “分支名称” –force本地覆盖仓库的代码","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://gitee.com/shimmer612/myBlog/tags/git/"}]},{"title":"自己实现一个简单的redux","slug":"2022-03-30-自己实现redux","date":"2022-03-29T16:00:00.000Z","updated":"2022-04-02T11:21:42.196Z","comments":true,"path":"2022/03/30/2022-03-30-自己实现redux/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/03/30/2022-03-30-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0redux/","excerpt":"","text":"自己实现一个 redux今天面试被问到 redux 的实现过程，晚上回来想一想发现自己也可以简单的实现一下 就是观察者订阅者模式 1、createStore12345678910111213141516171819202122232425262728293031const reducer = require(&quot;./reducer&quot;);const createStore = (reducer, state) =&gt; &#123; const fnArr = []; //订阅 const subscribe = (fn) =&gt; &#123; fnArr.push(fn); &#125;; //发布 const dispatch = (action) =&gt; &#123; reducer(state, &#123; ...action &#125;); if (fnArr.length !== 0) &#123; fnArr.map((fn) =&gt; fn()); &#125; &#125;; const getState = () =&gt; &#123; return &#123; ...state &#125;; &#125;; // 初始化state dispatch(&#123; type: null &#125;); return &#123; getState, dispatch, subscribe, &#125;;&#125;;const store = createStore(reducer.reducer, &#123; num: 1 &#125;);exports.store = store; 2、reducer.js 这个没什么区别12345678const reducer = (state, action) =&gt; &#123; if (action.type === &quot;add&quot;) &#123; state.num = state.num + action.value; &#125; return &#123; ...state &#125;;&#125;;exports.reducer = reducer; 3、使用12345678const store = require(&quot;./store&quot;);store.store.subscribe(() =&gt; &#123; console.log(&quot;值改变了&quot;);&#125;);store.store.dispatch(&#123; type: &quot;add&quot;, value: 10 &#125;);console.log(store.store.getState()); //11 没想到本以为很复杂的东西，原理其实很简单。主要的还是编程的思想","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"pinia新的状态管理工具","slug":"2022-03-25-pinia的使用","date":"2022-03-24T16:00:00.000Z","updated":"2022-03-25T10:48:57.114Z","comments":true,"path":"2022/03/25/2022-03-25-pinia的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/03/25/2022-03-25-pinia%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"pinia新的状态管理工具1、安装npm install pinia --save 2、新建store,在main.js中引入在根目录下新建store文件夹，新建index.js 1234import &#123; createPinia &#125; from &quot;pinia&quot;;// 创建storeconst store = createPinia();export default store; main.js 12345678910import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store&quot;;const app = createApp(App);app.use(store);app.mount(&quot;#app&quot;); 3、在store文件夹下新建stateStore.js123456789101112131415161718192021222324252627282930313233343536import &#123; defineStore &#125; from &quot;pinia&quot;;export const stateStore = defineStore(&#123; id: &quot;state&quot;, //命名 state: () =&gt; &#123; return &#123; name: &quot;菠萝&quot;, age: 99, &#125;; &#125;, //类似于计算属性 getters: &#123; getterName(state) &#123; console.log(&quot;使用了getter&quot;); return &quot;我是什么水果？我是&quot; + state.name; &#125;, &#125;, actions: &#123; //还支持调用别的actions updateName(name, age) &#123; this.name = name; this.updateAge(age); &#125;, updateAge(age) &#123; this.age = age; &#125;, //action 可以像写一个简单的函数一样支持 async/await的语法 async asyncfun() &#123; const timer = setTimeout(() =&gt; &#123; this.name = &quot;桃子&quot;; &#125;, 1000); await timer; &#125;, &#125;,&#125;); 4、使用先引入创建的store 解构需要引入storeToRefs 修改state数据可以直接修改，也可以使用$patch,也可以使用actions修改 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;h1&gt;pinia:&#123;&#123; name &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;pinia:&#123;&#123; age &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;pinia.getter:&#123;&#123; state.getterName &#125;&#125;&lt;&#x2F;h1&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;changeName&quot;&gt;修改pinia&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script setup&gt;import &#123; reactive, inject &#125; from &quot;vue&quot;;import &#123; stateStore &#125; from &quot;..&#x2F;store&#x2F;state&quot;;&#x2F;&#x2F;解构storeimport &#123; storeToRefs &#125; from &quot;pinia&quot;;const state &#x3D; stateStore();const &#123; age, name &#125; &#x3D; storeToRefs(state);const changeName &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 通过patch修改数据两种方式对象和函数 &#x2F;&#x2F; 1、对象 &#x2F;&#x2F; state.$patch(&#123; &#x2F;&#x2F; name: &quot;西瓜&quot;, &#x2F;&#x2F; age: 100, &#x2F;&#x2F; &#125;); &#x2F;&#x2F; 2、函数 &#x2F;&#x2F; state.$patch((state) &#x3D;&gt; &#123; &#x2F;&#x2F; state.name &#x3D; &quot;哈密瓜&quot;; &#x2F;&#x2F; state.age &#x3D; 999; &#x2F;&#x2F; &#125;); &#x2F;&#x2F; 通过action修改数据 state.updateName(&quot;香蕉&quot;, 88); state.asyncfun();&#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;&lt;&#x2F;style&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"},{"name":"pinia","slug":"pinia","permalink":"https://gitee.com/shimmer612/myBlog/tags/pinia/"}]},{"title":"react-hooks中useContext的使用","slug":"2022-02-22-useContext","date":"2022-02-21T16:00:00.000Z","updated":"2022-03-24T08:54:37.871Z","comments":true,"path":"2022/02/22/2022-02-22-useContext/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/02/22/2022-02-22-useContext/","excerpt":"","text":"react-hooks中useContext的使用1、作用useContext可以多层嵌套传输数据和方法 2、使用1、新建一个store.js文件，使用React.createContext()创建一个自己的Context 12345import React from &quot;react&quot;;const myContext &#x3D; React.createContext(null);export &#123; myContext &#125;; 2、最外层组件 使用myContext.Provider包裹然后value传入自己需要的值 1234567891011121314import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useState &#125; from &quot;react&quot;;import Child from &quot;.&#x2F;child&quot;;const App &#x3D; () &#x3D;&gt; &#123; const [num, setNum] &#x3D; useState(0); return ( &lt;myContext.Provider value&#x3D;&#123;&#123; setNum, num &#125;&#125;&gt; &lt;Child&gt;&lt;&#x2F;Child&gt; &lt;&#x2F;myContext.Provider&gt; );&#125;;export default App; 3、子组件 引入myContext并通过useContext获取到传入的值 1234567891011121314151617181920212223import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useContext&#125; from &quot;react&quot;;import GrandSon from &quot;.&#x2F;grandSon&quot;;const Child &#x3D; (props) &#x3D;&gt; &#123; const &#123; setNum, num &#125; &#x3D; useContext(myContext); return ( &lt;&gt; &lt;h1&gt;&#123;num&#125;&lt;&#x2F;h1&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setNum((prev) &#x3D;&gt; prev + 1); &#125;&#125; &gt; 添加 &lt;&#x2F;button&gt; &lt;GrandSon num&#x3D;&#123;num&#125; &#x2F;&gt; &lt;&#x2F;&gt; );&#125;;export default Child; 3、孙组件 和子组件中一样 12345678910111213141516171819202122import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useContext &#125; from &quot;react&quot;;const GrandSon &#x3D; (props) &#x3D;&gt; &#123; const &#123; setNum, num &#125; &#x3D; useContext(myContext); return ( &lt;&gt; &lt;h1&gt;我是孙子&lt;&#x2F;h1&gt; &lt;h1&gt;&#123;num&#125;&lt;&#x2F;h1&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setNum((prev) &#x3D;&gt; prev + 1); &#125;&#125; &gt; 添加 &lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125;;export default GrandSon; 多层传值的话结构比较清晰，不需要层层用props传值，在一个单独的组件中传值中比较方便","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"useRef的使用","slug":"2022-02-21-useRef","date":"2022-02-20T16:00:00.000Z","updated":"2022-04-01T10:57:51.490Z","comments":true,"path":"2022/02/21/2022-02-21-useRef/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/02/21/2022-02-21-useRef/","excerpt":"","text":"react-hooks之useRef，useImperativeHandle的使用1、函数内部使用useRef可以用来做数据持久化，也可以用来获取到元素实例 ref.current的变化并不会导致函数组件的重新加载不像useState 可以用一个假的useState，结合useEffect的依赖让useRef的值改变后重新加载函数 12345678910111213141516171819202122232425262728import React, &#123; useState, useContext, useRef, useEffect &#125; from &quot;react&quot;;const App = () =&gt; &#123; const [num, setNum] = useState(0); const myRef = useRef(0); const btnRef = useRef(); useEffect(() =&gt; &#123; myRef.current += 1; &#125;, [num]); return ( &lt;div&gt; &lt;h1&gt;我是Ref:&#123;myRef.current&#125;&lt;/h1&gt; &lt;button ref=&#123;btnRef&#125; onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); console.log(&quot;button的文字: &quot;, btnRef.current.innerText);//改变ref &#125;&#125; &gt; 改变ref &lt;/button&gt; &lt;/div&gt; );&#125;;export default App; 2、子组件使用子组件使用不能直接&lt;Child ref=&#123;childRef&#125;&gt;&lt;Child/&gt; 这样子组件获取不到ref，要用forwordRef把子组件包裹起来传入两个参数（props,ref） 12345678910111213141516171819202122232425262728293031//父组件import React, &#123; useState, useContext, useRef, useEffect &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;const App = () =&gt; &#123; const [num, setNum] = useState(0); const myRef = useRef(0); const btnRef = useRef(); useEffect(() =&gt; &#123; myRef.current += 1; &#125;, [num]); return ( &lt;div&gt; &lt;h1&gt;我是Ref:&#123;myRef.current&#125;&lt;/h1&gt; &lt;button ref=&#123;btnRef&#125; onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); console.log(&quot;button的文字: &quot;, btnRef.current.innerText);//改变ref &#125;&#125; &gt; 改变ref &lt;/button&gt; &lt;Child ref=&#123;childRef&#125;&gt;&lt;/Child&gt; &lt;/div&gt; );&#125;;export default App; 1234567891011121314//子组件import React, &#123;useEffect, forwardRef &#125; from &quot;react&quot;;const Child = forwardRef((props, ref) =&gt; &#123; console.log(&quot;props: &quot;, props); return ( &lt;div ref=&#123;ref&#125;&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;h1&gt;&#123;num&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;);export default Child; 3、useImperativeHandle像父组件暴露子组件的实例（类似于子传父） 12345678910111213141516171819202122232425262728293031323334import &#123; myContext &#125; from &quot;./store&quot;;import React, &#123; useState, useContext, useEffect, forwardRef, useImperativeHandle &#125; from &quot;react&quot;;import GrandSon from &quot;./grandSon&quot;;const Child = forwardRef((props, ref) =&gt; &#123; const &#123; setNum, num &#125; = useContext(myContext); const [name, setName] = useState(&quot;zs&quot;); useImperativeHandle(ref, () =&gt; &#123; return &#123; fn &#125;; &#125;); const fn = () =&gt; &#123; console.log(&quot;hahahha&quot;); &#125;; return ( &lt;div ref=&#123;ref&#125;&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;h1&gt;&#123;num&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); setName(&quot;ls&quot;); &#125;&#125; &gt; 子组件添加 &lt;/button&gt; &lt;GrandSon num=&#123;num&#125; name=&#123;name&#125; /&gt; &lt;/div&gt; );&#125;);export default Child; 子组件就能获取到暴露的值 1234567891011121314151617181920212223242526272829303132//父组件import React, &#123; useState, useContext, useRef, useEffect &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;const App = () =&gt; &#123; const [num, setNum] = useState(0); const myRef = useRef(0); const btnRef = useRef(); useEffect(() =&gt; &#123; myRef.current += 1; childRef.current?.fn?.(); &#125;, [num]); return ( &lt;div&gt; &lt;h1&gt;我是Ref:&#123;myRef.current&#125;&lt;/h1&gt; &lt;button ref=&#123;btnRef&#125; onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); console.log(&quot;button的文字: &quot;, btnRef.current.innerText);//改变ref &#125;&#125; &gt; 改变ref &lt;/button&gt; &lt;Child ref=&#123;childRef&#125;&gt;&lt;/Child&gt; &lt;/div&gt; );&#125;;export default App;","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"react hooks介绍","slug":"2022-01-15-react-hook","date":"2022-01-14T16:00:00.000Z","updated":"2022-03-24T08:54:52.864Z","comments":true,"path":"2022/01/15/2022-01-15-react-hook/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/01/15/2022-01-15-react-hook/","excerpt":"","text":"Hook 是什么？“Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。” 从使用感官上来说，主要是对class组件中 setState和生命周期的“替换”。 Hook的优势 脱离了class和this。（前端更偏爱组装而不是继承。this因为方法嵌套，箭头函数，call，apply，bind等，逐渐复杂化）。 拆分生命周期。（ 对于复杂组件， componentDidUpdate 中可能包含很多逻辑，用useeffect拆分后，条理更清晰 ）。 复用状态逻辑。 在react开发中经常关注的问题 什么行为会触发组件更新？ setState props useReducer 如何让数据在更新过程中不被重置？ useMemo useState const a = useRef(); a.current = 1; 把变量定义在组件的外层 useState和useEffect useState兼具触发更新和保存数据的功能。 useEffect用于弥补函数式组件生命周期的缺失 依赖缺失会导致哪些问题？ useEffect(fun, []); 读取到旧数据`` 依赖的数据类型？ useEffect(fun, [[123] === [123], props, fn]); function 用useCallback进行包裹，useCallback(fn ,[]) 哪些东西不需要写在依赖列表 import，service，moment useRef() useImperativeHandle和useRef useRef可以方便的实现数据持久化，对于不需要进行展示，或者可以依赖其它useState来借东风。 ref转发？ 12345678910function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;), []); return &lt;input ref=&#123;inputRef&#125; /&gt;;&#125;FancyInput = forwardRef(FancyInput); useCallback和useMemo1useCallback(fn, deps)` 相当于 `useMemo(() =&gt; fn, deps) 其它一些Hook useContext useReducer 自定义Hook复用状态逻辑","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"2022年来啦","slug":"2022","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-01T14:38:19.748Z","comments":true,"path":"2022/01/01/2022/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/01/01/2022/","excerpt":"","text":"2022年元旦新的一年又到来了 工作的时间过的飞快，转眼间已经当了一年的打工人了。 这一年经历了很多，实习、毕业、工作、旅游、隔离、加班。 毕业后一个人留在了常州，开始没什么朋友，过的很烦闷和痛苦。 虽然工作中遇到了几个同事与好友，但是人的喜好并不相同。 但也是很开心的。至少工作中又很多欢乐。 经历了很多也收获了很多，从一开始的写一些小需求，到现在开发整个版本，调研新的技术。 现在应该算一个真正的前端程序员了吧。 就是自己技术的广度没多大提升。 每天从早写到晚，下班或者放假的时候学习新技术是可以屈指可数的。 今年慢慢加油吧。 今天元旦，华姐邀请我去她家吃饭，但是还要我自己烧饭，还是很快乐的，只是没有发挥好，最后出锅忘记了放盐，没有华姐做的好吃。饭后打打牌，做做小游戏，美中不足是没有打到羽毛球。 周末能和好朋友们一起玩一玩真的挺棒的，不会那么烦闷。 新的一年继续加油。 希望今年父母健康，一切都好。 自己一切都好，我爱的人和爱我的人一切都好。 新年快乐！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"react项目国际化","slug":"2021-12-04-react项目国际化","date":"2021-12-03T16:00:00.000Z","updated":"2022-03-24T08:40:05.438Z","comments":true,"path":"2021/12/04/2021-12-04-react项目国际化/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/12/04/2021-12-04-react%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"react项目国际化这里使用的react-intl1、安装react-intlnpm install react-intl --save 或者 cnpm install react-intl --save 2、引入在需要国际化的文件引入react-intl 需要全局国际化就在app.js文件中引入 1234567891011121314import React, &#123; Component &#125; from &quot;react&quot;;import &#123; IntlProvider &#125; from &quot;react-intl&quot;;class Page extends Component &#123; render() &#123; return ( &lt;IntlProvider&gt; &lt;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;IntlProvider&gt; ) &#125;&#125; 3、创建翻译数据文件在src目录下新建一个文件夹i18n包含两个js文件一个locales.js 需要的语言一个messages.js需要翻译的数据 我这里是中文英语和尼泊尔语 1234567&#x2F;&#x2F;locales.jsexport const LOCALES &#x3D; &#123; NEPAIL: &quot;ne-Ne&quot;, CHINESE: &quot;zh-CN&quot;, ENGLISH: &quot;en&quot;,&#125;; 12345678910111213141516171819202122232425&#x2F;&#x2F;messages.jsimport &#123; LOCALES &#125; from &quot;.&#x2F;locales&quot;;export const messages &#x3D; &#123; [LOCALES.NEPAIL]: &#123; chinese: &quot;चिनियाँ&quot;, nepail: &quot;नेपाली&quot;, change_lan: &quot;एउटा भाषा छान्नुहोस्&quot;, station_name: &quot;चार्जिङ स्टेशनको नाम&quot;, &#125;, [LOCALES.CHINESE]: &#123; change_lan: &quot;选择语言&quot;, chinese: &quot;中文&quot;, nepail: &quot;尼泊尔语&quot;, station_name: &quot;电站名称&quot;, &#125;, [LOCALES.ENGLISH]: &#123; change_lan: &quot;languages&quot;, chinese: &quot;chinese&quot;, nepail: &quot;Nepail&quot;, station_name: &quot;stationName&quot;, &#125;,&#125;; 4、使用 使用FormattedMessage 组件，允许用户对简单到复杂的字符串和消息进行翻译和格式化 这个locale ，它接受一个字符串，决定了我们的应用程序是以什么语言呈现的。这里我使用select动态地改变这个值。 messages 对象包含一组准备在前台显示的翻译字符串。这些也将根据当前的语言环境动态地添加。 defaultLocale 道具是默认的locale，应该与应用程序的默认语言相匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from &quot;react&quot;;import &#123; IntlProvider,FormattedMessage &#125; from &quot;react-intl&quot;;import &#123; LOCALES &#125; from &quot;..&#x2F;..&#x2F;i18n&#x2F;locales&quot;;import &#123; messages &#125; from &quot;..&#x2F;..&#x2F;i18n&#x2F;messages&quot;;class Page extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; &#x2F;&#x2F;默认语言 locale: LOCALES.CHINESE, &#125;; render() &#123; const &#123; locale &#125; &#x3D; this.state; return ( &lt;IntlProvider messages&#x3D;&#123;messages[locale]&#125; locale&#x3D;&#123;locale&#125; &#x2F;&#x2F;默认语言 defaultLocale&#x3D;&#123;locale.CHINESE&#125;&gt; &lt;div&gt; &lt;span&gt; &lt;span style&#x3D;&#123;&#123; marginRight: &quot;5px&quot; &#125;&#125;&gt; &lt;FormattedMessage id&#x3D;&quot;change_lan&quot; &#x2F;&gt;: &lt;&#x2F;span&gt; &lt;Select defaultValue&#x3D;&#123;1&#125; placeholder&#x3D;&#123;&lt;FormattedMessage id&#x3D;&quot;change_lan&quot; &#x2F;&gt;&#125; onChange&#x3D;&#123;(val) &#x3D;&gt; &#123; if (val &#x3D;&#x3D;&#x3D; 1) &#123; this.setState(&#123; locale: LOCALES.CHINESE, &#125;); &#125; else if (val &#x3D;&#x3D;&#x3D; 2) &#123; this.setState(&#123; locale: LOCALES.NEPAIL, &#125;); &#125; else if (val &#x3D;&#x3D;&#x3D; 3) &#123; this.setState(&#123; locale: LOCALES.ENGLISH, &#125;); &#125; &#125;&#125; style&#x3D;&#123;&#123; width: &quot;150px&quot; &#125;&#125; &gt; &lt;Option value&#x3D;&#123;1&#125;&gt;中文&lt;&#x2F;Option&gt; &lt;Option value&#x3D;&#123;2&#125;&gt;Nepail&lt;&#x2F;Option&gt; &lt;Option value&#x3D;&#123;3&#125;&gt;Engilish&lt;&#x2F;Option&gt; &lt;&#x2F;Select&gt; &lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;IntlProvider&gt; ) &#125;&#125; 5、占位符placeholder使用、message提示的使用不能使用FormattedMessage因为返回的是一个html 首先使用injectIntl包装React组件， 注入intl上下文 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Form, Input, message &#125; from &quot;antd&quot;;import &#123; FormattedMessage, injectIntl &#125; from &quot;react-intl&quot;;class Add extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; &#125;; &#125; onFinish &#x3D; () &#x3D;&gt; &#123; this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; const msg2 &#x3D; this.props.intl.formatMessage(&#123; id: &quot;save_success&quot; &#125;); message.success(msg2, 5); this.props.form.resetFields(); &#125; &#125;); &#125; &#125;); &#125;; render() &#123; const &#123; getFieldDecorator, setFieldsValue &#125; &#x3D; this.props.form; const placeholder &#x3D; this.props.intl.formatMessage(&#123; id: &quot;input&quot; &#125;); return ( &lt;div&gt; &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125;&gt; &lt;Form.Item label&#x3D;&#123;&lt;FormattedMessage id&#x3D;&quot;station_name&quot; &#x2F;&gt;&#125;&gt; &#123;getFieldDecorator(&quot;name&quot;, &#123; rules: [&#123; required: true, whitespace: true, message: &lt;FormattedMessage id&#x3D;&quot;required&quot; &#x2F;&gt; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&#123;placeholder&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;div&gt; ); &#125;&#125;Add &#x3D; Form.create(&#123;&#125;)(Add);export default injectIntl(Add);","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"react中使用谷歌地图","slug":"2021-12-02-react中使用谷歌地图","date":"2021-12-01T16:00:00.000Z","updated":"2022-03-24T08:40:00.030Z","comments":true,"path":"2021/12/02/2021-12-02-react中使用谷歌地图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/12/02/2021-12-02-react%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"react中使用谷歌地图1、引入index.html文件中引入谷歌地图 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt; &lt;title&gt;OMS&lt;/title&gt; &lt;script src=&quot;https://maps.googleapis.com/maps/api/js?key=AIzaSyDVTk78W-PvhqUC08l6MBqUHTjJXSGcP4g&amp;libraries=places&amp;language=&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2、使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Button, Input &#125; from &quot;antd&quot;;import &#123; FormattedMessage &#125; from &quot;react-intl&quot;;const googleMap &#x3D; window.google &amp;&amp; window.google.maps;class Map extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; map: null, lat: null, lng: null, marker: [], &#125;; &#125; &#x2F;&#x2F; 初始化谷歌地图 componentDidMount() &#123; if (&quot;geolocation&quot; in navigator) &#123; &#x2F;&#x2F;检测当前设备是否支持H5Geolocation API navigator.geolocation.getCurrentPosition((position) &#x3D;&gt; &#123; let mapProp &#x3D; &#123; center: new googleMap.LatLng(position.coords.latitude, position.coords.longitude), zoom: 17, mapTypeId: googleMap.MapTypeId.ROADMAP, &#125;; let map &#x3D; new googleMap.Map(document.getElementById(&quot;googleMap&quot;), mapProp); if (this.state.marker[0] &amp;&amp; this.state.marker[0].setMap) &#123; this.state.marker[0].setMap(null); &#125; const arr &#x3D; []; arr[0] &#x3D; new googleMap.Marker(&#123; position: new googleMap.LatLng(position.coords.latitude, position.coords.longitude), &#125;); this.setState( &#123; marker: arr, lat: position.coords.latitude, lng: position.coords.longitude, map, &#125;, () &#x3D;&gt; &#123; this.state.marker[0].setMap(map); &#125; ); &#125;); &#125; else &#123; alert(&quot;该浏览器不支持获取地理位置&quot;); &#125; &#125; addMap &#x3D; () &#x3D;&gt; &#123; googleMap.event.addListener(this.state.map, &quot;click&quot;, (e) &#x3D;&gt; &#123; if (this.state.marker[0] &amp;&amp; this.state.marker[0].setMap) &#123; this.state.marker[0].setMap(null); &#125; const arr &#x3D; []; arr[0] &#x3D; new googleMap.Marker(&#123; position: new googleMap.LatLng(e.latLng.lat(), e.latLng.lng()), &#125;); this.setState( &#123; marker: arr, lat: e.latLng.lat(), lng: e.latLng.lng(), &#125;, () &#x3D;&gt; &#123; this.state.marker[0].setMap(this.state.map); &#125; ); &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;div style&#x3D;&#123;&#123; display: &quot;flex&quot;, alignItems: &quot;center&quot;, marginBottom: 10 &#125;&#125;&gt; &lt;span&gt; &lt;FormattedMessage id&#x3D;&quot;lng&quot; &#x2F;&gt;： &lt;&#x2F;span&gt; &lt;Input style&#x3D;&#123;&#123; width: &quot;200px&quot; &#125;&#125; value&#x3D;&#123;this.state.lng&#125; disabled &#x2F;&gt; &lt;span style&#x3D;&#123;&#123; marginLeft: 20 &#125;&#125;&gt; &lt;FormattedMessage id&#x3D;&quot;lat&quot; &#x2F;&gt;： &lt;&#x2F;span&gt; &lt;Input style&#x3D;&#123;&#123; width: &quot;200px&quot; &#125;&#125; value&#x3D;&#123;this.state.lat&#125; disabled &#x2F;&gt; &lt;Button style&#x3D;&#123;&#123; marginLeft: 20 &#125;&#125; type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;() &#x3D;&gt; &#123; this.props.addLatLng(this.state.lat, this.state.lng); this.props.onCancel(); &#125;&#125; &gt; &lt;FormattedMessage id&#x3D;&quot;ok&quot; &#x2F;&gt; &lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;googleMap&quot; style&#x3D;&#123;&#123; width: &quot;900px&quot;, height: &quot;500px&quot; &#125;&#125; onClick&#x3D;&#123;this.addMap&#125;&gt;&lt;&#x2F;div&gt;; &lt;&#x2F;div&gt; ); &#125;&#125;export default Map;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Redux的使用方法（复习）","slug":"2021-11-03-redux&&reacy-redux的使用","date":"2021-11-02T16:00:00.000Z","updated":"2022-03-29T12:25:35.770Z","comments":true,"path":"2021/11/03/2021-11-03-redux&&reacy-redux的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/11/03/2021-11-03-redux&&reacy-redux%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Redux 的使用方法1、安装 reduxnpm i redux --save 2、新建文件新建文件夹 store 包含 store.js/reducer.js/action.js 3、新建 reducer/action/引入 storereducer.js 123456789101112131415161718192021222324const defaultData = &#123; num: 0 &#125;;const reducer = (state = defaultData, action) =&gt; &#123; console.log(&quot;action: &quot;, action); console.log(&quot;state: &quot;, state); const newData = JSON.parse(JSON.stringify(state)); console.log(&quot;newData: &quot;, newData); switch (action.type) &#123; case &quot;add&quot;: newData.num++; return newData; case &quot;minus&quot;: newData.num--; return newData; case &quot;getVal&quot;: newData.num = action.value; return newData; default: return newData; &#125;&#125;;export default reducer; action.js 12345678910111213const add = (value) =&gt; &#123; return &#123; type: &quot;add&quot;, value &#125;;&#125;;const minus = (value) =&gt; &#123; return &#123; type: &quot;minus&quot;, value &#125;;&#125;;const changeVal = (value) =&gt; &#123; return &#123; type: &quot;getVal&quot;, value &#125;;&#125;;export &#123; add, minus, changeVal &#125;; store.js 123456import &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;const store = createStore(reducer);export default store;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"除法数值转换精度","slug":"2021-10-08-除法的百分比精度","date":"2021-10-07T16:00:00.000Z","updated":"2022-03-24T08:40:53.916Z","comments":true,"path":"2021/10/08/2021-10-08-除法的百分比精度/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/10/08/2021-10-08-%E9%99%A4%E6%B3%95%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E7%B2%BE%E5%BA%A6/","excerpt":"","text":"除法数值转换精度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//arg1:除数//arg2:被除数// 除法转换数值精度export const editDiscountNum = (arg1, arg2) =&gt; &#123; arg1 = Number(arg1); arg2 = Number(arg2); if (!arg2) &#123; return null; &#125; if (!arg1 &amp;&amp; arg1 !== 0) &#123; return null; &#125; else if (arg1 === 0) &#123; return 0; &#125; arg1 = toNonExponential(arg1); arg2 = toNonExponential(arg2); let n1, n2; let r1, r2; // 小数位数 try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; n1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)); n2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)); return floatMultiply(n1 / n2, Math.pow(10, r2 - r1));&#125;;// 乘法数值精度const floatMultiply = (arg1, arg2) =&gt; &#123; arg1 = Number(arg1); arg2 = Number(arg2); if ((!arg1 &amp;&amp; arg1 !== 0) || (!arg2 &amp;&amp; arg2 !== 0)) &#123; return null; &#125; arg1 = toNonExponential(arg1); arg2 = toNonExponential(arg2); let n1, n2; let r1, r2; // 小数位数 try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; n1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)); n2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)); return (n1 * n2) / Math.pow(10, r1 + r2);&#125;;const toNonExponential = (num) =&gt; &#123; if (num == null) &#123; return num; &#125; if (typeof num == &quot;number&quot;) &#123; var m = num.toExponential().match(/\\d(?:\\.(\\d*))?e([+-]\\d+)/); return num.toFixed(Math.max(0, (m[1] || &quot;&quot;).length - m[2])); &#125; else &#123; return num; &#125;&#125;;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"常用正则表达式","slug":"2021-09-27-常用正则表达式","date":"2021-09-26T16:00:00.000Z","updated":"2022-03-24T08:40:42.734Z","comments":true,"path":"2021/09/27/2021-09-27-常用正则表达式/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/09/27/2021-09-27-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"常用正则表达式1234567891011121314151617181920212223242526//手机号var phoneReg = /^1[3456789]\\d&#123;9&#125;$/; // 详细手机号校验规则var phoneReg1 = /^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$/; //验证手机号和固定电话var reg = /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1[34578]\\d&#123;9&#125;))$/;; //邮箱var emailReg = /[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?/;//用户名校验var userNameReg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; //6-16位的包含大小写字母、数字、特殊符号- _ 的用户名var userNameReg1 = /^(?![0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]&#123;6,20&#125;$/; //6-20位字母和数字组合//身份证验证 var idcardReg = /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/;//验证是否两位小数var twoDigReg = /(^[1-9]([0-9]+)?(\\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\\.[0-9]([0-9])?$)/;//内容只能由英文、数字、下划线组成var reg = /^\\w+$/;//内容只能包含英文字母和数字var reg = /^[a-z0-9]+$/i；","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"数组的map方法会不会改变原数组","slug":"2021-09-21-数组的map方法","date":"2021-09-20T16:00:00.000Z","updated":"2022-03-24T08:40:24.612Z","comments":true,"path":"2021/09/21/2021-09-21-数组的map方法/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/09/21/2021-09-21-%E6%95%B0%E7%BB%84%E7%9A%84map%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组的map方法会不会改变原数组****父组件朝子组件传值，二次渲染以后有一个数组的值改变了，发现该数组使用了map，map不是不会改变原数组吗。 会改变原数组于是就自己试了一下 1234567891011121314const arr = [&#123; name: &quot;aa&quot;, num: 1 &#125;];const newArr = arr.map((item) =&gt; &#123; item.num *= 10; return item;&#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/*********************arr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]newArr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]*******************/ 上面代码我们看出原数组arr的值改变了，数组内是引用类型 不会改变原数组123456789101112 const arr = [1, 2, 3, 4, 5]; const newArr = arr.map((item) =&gt; &#123; return item * 10; &#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/**arr: [ 1, 2, 3, 4, 5 ]newArr: [ 10, 20, 30, 40, 50 ]**/ 我又试了一下值类型，发现值类型不会被改变 看来数组的map方法会改变原数组 不改变的写法怎么样能让map方法不改变原数组呢？ 改变原数组的原因是直接对item进行操作。 可以返回一个新的，如下 12345678910111213141516const arr = [&#123; name: &quot;aa&quot;, num: 1 &#125;];const newArr = arr.map((item) =&gt; &#123; return &#123; name:item.name, num:item.num*10 &#125;&#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/***arr: [ &#123; name: &#x27;aa&#x27;, num: 1 &#125; ]newArr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]***/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"文件作为参数上传","slug":"2021-08-12-文件作为参数上传","date":"2021-08-11T16:00:00.000Z","updated":"2022-03-24T08:40:57.755Z","comments":true,"path":"2021/08/12/2021-08-12-文件作为参数上传/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/08/12/2021-08-12-%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"文件作为参数上传文件作为参数上传，需要使用formData格式。 本次是使用Ant Design的form组件和Upload组件实现 若需要别的参数，也要通过formData的append的方法把参数添加到formData中 12//formData中添加参数formData.append(&quot;参数名&quot;，&quot;参数值&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Form, Button, Input, message, Upload &#125; from &quot;antd&quot;;import fetchHandler from &quot;@&#x2F;fetch&#x2F;fetchHandler&quot;;import &#123; prefixFile, rebateUpload &#125; from &quot;@&#x2F;fetch&#x2F;fetchApi&quot;;import axios from &quot;axios&quot;;const &#123; TextArea &#125; &#x3D; Input;class UploadForm extends Component &#123; constructor(props) &#123; super(props); this.props &#x3D; props; this.state &#x3D; &#123; fileList: [], &#125;; &#125; normFile &#x3D; (e) &#x3D;&gt; &#123; console.log(&quot;Upload event:&quot;, e); if (Array.isArray(e)) &#123; return e; &#125; return e &amp;&amp; e.fileList; &#125;; &#x2F;&#x2F; 表单提交 onFinish &#x3D; (e) &#x3D;&gt; &#123; e.preventDefault(); this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; const &#123; fileList &#125; &#x3D; this.state; const formData &#x3D; new FormData(); fileList.forEach((file) &#x3D;&gt; &#123; formData.append(&quot;file&quot;, file); formData.append(&quot;rebateName&quot;, values.rebateName); formData.append(&quot;remark&quot;, values.remark); formData.append(&quot;activityName&quot;, values.activityName); &#125;); axios(&#123; method: &quot;post&quot;, url: &#96;$&#123;prefixFile&#125;&#x2F;webApi&#x2F;rebate&#x2F;upload&#96;, data: formData, header: &#123; Authorization: window.sessionStorage.getItem(&quot;token&quot;), &#125;, &#125;).then((res) &#x3D;&gt; &#123; console.log(res); &#125;); &#125; &#125;); &#125;; &#x2F;&#x2F; 模板下载 downloadTemplate &#x3D; () &#x3D;&gt; &#123; if (this.fileUrl) &#123; window.location.href &#x3D; this.fileUrl; &#125; else &#123; window.location.href &#x3D; &#96;$&#123;prefixFile&#125;&#x2F;templates&#x2F;批量返利模板.xls&#96;; &#125; &#125;; render() &#123; const &#123; getFieldDecorator &#125; &#x3D; this.props.form; const &#123; fileList &#125; &#x3D; this.state; const tailFormItemLayout &#x3D; &#123; wrapperCol: &#123; xs: &#123; span: 24, offset: 0 &#125;, sm: &#123; span: 16, offset: 5 &#125;, &#125;, &#125;; const formItemLayout &#x3D; &#123; labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 4 &#125;, &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 12, offset: 1 &#125;, &#125;, &#125;; const uploadProps &#x3D; &#123; name: &quot;file&quot;, accept: &quot;.xls&quot;, &#x2F;&#x2F; onChange: this.handleChange, onRemove: (file) &#x3D;&gt; &#123; this.setState((state) &#x3D;&gt; &#123; const index &#x3D; state.fileList.indexOf(file); const newFileList &#x3D; state.fileList.slice(); newFileList.splice(index, 1); this.props.form.setFieldsValue(&#123; file: &quot;&quot;, &#125;); return &#123; fileList: newFileList, &#125;; &#125;); &#125;, beforeUpload: (file) &#x3D;&gt; &#123; this.setState( &#123; fileList: [file], &#125;, () &#x3D;&gt; &#123; const &#123; fileList &#125; &#x3D; this.state; const formData &#x3D; new FormData(); fileList.forEach((file) &#x3D;&gt; &#123; formData.append(&quot;file&quot;, file); &#125;); this.props.form.setFieldsValue(&#123; file: formData, &#125;); &#125; ); return false; &#125;, fileList, &#125;; return ( &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125;&gt; &lt;Form.Item label&#x3D;&quot;返利批次名称&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;rebateName&quot;, &#123; rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&quot;请输入返利批次名称&quot; maxLength&#x3D;&#123;100&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;活动名称&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;activityName&quot;, &#123; rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&quot;请输入活动名称&quot; maxLength&#x3D;&#123;100&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;备注&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;remark&quot;, &#123; rules: [&#123; required: false &#125;], initialValue: &quot;&quot;, &#125;)(&lt;TextArea rows&#x3D;&#123;5&#125; maxLength&#x3D;&#123;50&#125; placeholder&#x3D;&quot;请输入备注&quot; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;批量上传&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;file&quot;, &#123; valuePropName: &quot;fileList&quot;, getValueFromEvent: this.normFile, rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], &#125;)( &lt;div&gt; &lt;Upload &#123;...uploadProps&#125;&gt; &lt;Button type&#x3D;&quot;dashed&quot;&gt;上传文件&lt;&#x2F;Button&gt; &lt;&#x2F;Upload&gt; &lt;a style&#x3D;&#123;&#123; marginRight: &quot;10px&quot; &#125;&#125;&gt;模板&lt;&#x2F;a&gt; &lt;a onClick&#x3D;&#123;this.downloadTemplate&#125;&gt;点击下载&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; )&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item &#123;...tailFormItemLayout&#125;&gt; &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; &#123; this.props.onCancel(); &#125;&#125; style&#x3D;&#123;&#123; marginRight: &quot;20px&quot; &#125;&#125; &gt; 退出 &lt;&#x2F;Button&gt; &lt;Button type&#x3D;&quot;primary&quot; htmlType&#x3D;&quot;submit&quot;&gt; 提交 &lt;&#x2F;Button&gt; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;Form&gt; ); &#125;&#125;UploadForm &#x3D; Form.create(&#123;&#125;)(UploadForm);export default UploadForm;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"表单添加多组规则","slug":"2021-07-30-表单添加多组规则","date":"2021-07-29T16:00:00.000Z","updated":"2022-03-24T08:25:35.162Z","comments":true,"path":"2021/07/30/2021-07-30-表单添加多组规则/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/07/30/2021-07-30-%E8%A1%A8%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BB%84%E8%A7%84%E5%88%99/","excerpt":"","text":"起因 框架 react+ant3（老项目重构很难） 新版本一个需求原型如下：[ 可以有多个规则，且规则之间时间需要连续。上一个结束时间的第二天要是下一个规则的开始时间。 如果第一个结束时间是 7 月 30 号,下个月的开始时间要是 7.31 号。依次类推。 还要可以批量设置。就是一次性设置多个。 首先肯定想到的是用数组 map,用的 form 表单。就新建一个数组arr=[0],点击添加按钮的时候就再push一个 0，删除按钮就arr.splice(index,1),index 是当前元素下标。但是form.item的依赖字段会重复。 然后只能自己用datePicker、Input还有框架封装好的获取企业 Id 的模糊查询的组件。 且有规则后再修改可以回显数据。 如下： 这是外层的 Modal: 因为批量多个参数逗号分隔。 初始化indexOf判断有没有逗号，是单个还是批量，单个的话就获取数据，且把获取到的数据通过 props 传到子组件当中。因为 render 是先 render。所以这里用个 flag。保证获取到的数据可以传到子组件。 再把需要的一些方法传到子组件当中。 子组件中，通过onChange获取到值放到一个对象中添加到数组里。 添加的时候获取到当前的结束时间。通过moment().add(1,&#39;day&#39;)当然这里要判断是不是数组中的第一个 还有就是对时间的判断。 因为时间的连续的删除只能删除最后一个。 基本完成了功能，但是感觉很冗余，还要修改，一些细节还要完善。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import React,&#123;Component&#125; from &#39;react&#39;import &#123; Form, Button, Input, message &#125; from &quot;antd&quot;import fetchHandler from &#39;@&#x2F;fetch&#x2F;fetchHandler&#39;import TrusteeshipForm from &#39;.&#x2F;TrusteeshipForm&#39;;import moment from &#39;moment&#39;;import &#123;settlementSetting,getSettlementSetting&#125; from &#39;@&#x2F;fetch&#x2F;fetchApi&#39;class Trusteeship extends Component &#123; constructor(props) &#123; super(props) this.props &#x3D; props this.state &#x3D; &#123; domArr : [], stubId:this.props.stubId, info:[], flag:true &#125; &#125; componentWillMount() &#123; this.getInfo() &#125; async getInfo () &#123; if(this.props.stubId.indexOf(&#39;,&#39;)&gt;0) &#123; return &#125; this.setState(&#123; flag:false &#125;) await fetchHandler(getSettlementSetting,&#123; stubId:this.props.stubId &#125;).then( (res)&#x3D;&gt;&#123; if(res&amp;&amp;res.code&#x3D;&#x3D;&#x3D;&#39;success&#39;) &#123; const domArr &#x3D; [] res.data.map((item,index)&#x3D;&gt;&#123; let obj &#x3D; &#123;&#125; obj.unitPrice &#x3D; item.unitPrice obj.paymentCompanyId&#x3D;item.paymentCompanyId obj.startDate &#x3D; moment(item.startDate).format(&quot;YYYY-MM-DD&quot;) obj.endDate &#x3D; moment(item.endDate).format(&quot;YYYY-MM-DD&quot;) obj.companyName &#x3D; item.companyName domArr.push(obj) &#125;) this.setState(&#123; domArr, info:res.data, flag:true &#125;) &#125; &#125;) &#125; onAdd &#x3D; (newArr)&#x3D;&gt;&#123; this.setState(&#123; domArr:newArr &#125;)&#125; onDel &#x3D; ()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr domArr.splice(domArr.length-1,1) this.setState(&#123; domArr &#125;) &#125;&#x2F;&#x2F; 判断对象是否存在空值 getDetaios(arr) &#123; for (var i in arr) &#123; if (arr[i] &#x3D;&#x3D; null) &#123; return true &#125; &#125; return false &#125; onChange &#x3D; (obj)&#x3D;&gt;&#123; this.props.form.setFieldsValue(&#123; stubPeriodSetting: obj &#125;) &#125;onFinish &#x3D; (e) &#x3D;&gt; &#123; const domArr &#x3D; this.state.domArr const isNull &#x3D; this.getDetaios(domArr[domArr.length-1]) console.log(domArr); if(isNull) &#123; message.warning(&quot;存在未填项或开始时间在结束时间之前，请检查&quot;) return &#125; e.preventDefault(); this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; values.stubIds &#x3D; this.state.stubId fetchHandler(settlementSetting,values ).then((res) &#x3D;&gt; &#123; console.log(res); if (res.code &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123; message.success(&quot;保存成功！&quot;) this.props.fresh() this.props.onCancel() &#125; &#125;) &#125; &#125;);&#125;;setFlag () &#123; this.setState(&#123; flag:true &#125;)&#125;render () &#123; const &#123;getFieldDecorator&#125; &#x3D; this.props.form const &#123;domArr,flag,info&#125; &#x3D; this.state console.log(domArr); console.log(info); return ( &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125; &gt; &lt;h5&gt;收费规则&lt;&#x2F;h5&gt; &#123;flag? &lt;div&gt;&lt;Form.Item label&#x3D;&quot;合同编号&quot; style&#x3D;&#123;&#123; display:&quot;flex&quot; &#125;&#125; &gt; &#123;getFieldDecorator(&#39;concatNo&#39;, &#123; rules: [&#123; required: true, message: &#39;该项是必填项&#39; &#125;], initialValue: (info.length!&#x3D;&#x3D;0)?info[0].concatNo:&quot;&quot; &#125;)( &lt;Input style&#x3D;&#123;&#123; &#39;width&#39;: &#39;300px&#39; &#125;&#125; placeholder&#x3D;&quot;请输入合同编号&quot; &#x2F;&gt;, )&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&#39;stubPeriodSetting&#39;, &#123; rules: [&#123; required: true, message: &#39;该项是必填项&#39;,type: &#39;array&#39; &#125;], initialValue: &quot;&quot; &#125;)( &lt;TrusteeshipForm setFlag&#x3D;&#123;()&#x3D;&gt;&#123;this.setFlag&#125;&#125; domArr&#x3D;&#123;domArr&#125; onAdd &#x3D; &#123;this.onAdd&#125; onDel&#x3D;&#123;this.onDel&#125; onChange&#x3D;&#123;this.onChange&#125; &#x2F;&gt;, )&#125; &lt;&#x2F;Form.Item&gt;&lt;&#x2F;div&gt;:&quot;&quot;&#125; &lt;Form.Item style&#x3D;&#123;&#123;display: &quot;flex&quot;,justifyContent:&quot;center&quot;&#125;&#125;&gt; &lt;Button type&#x3D;&quot;dashed&quot; htmlType&#x3D;&quot;submit&quot;&gt; 保存 &lt;&#x2F;Button&gt; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;Form&gt; )&#125;&#125;Trusteeship &#x3D; Form.create(&#123;&#125;)(Trusteeship)export default Trusteeship 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&#x2F;&#x2F; 引入reactimport React, &#123; PureComponent&#125; from &#39;react&#39;;import &#123; Form, Button, Input, message,DatePicker &#125; from &quot;antd&quot;import fetchHandler from &#39;@&#x2F;fetch&#x2F;fetchHandler&#39;import &#123;companyList &#125; from &#39;@&#x2F;fetch&#x2F;fetchApi&#39;import AutoSearch from &#39;@&#x2F;components&#x2F;display&#x2F;input&#x2F;AutoSearch&#39;;import moment from &#39;moment&#39;;class TrusteeshipForm extends PureComponent &#123; constructor(props) &#123; super(props); this.props &#x3D; props this.state &#x3D; &#123; domArr :this.props.domArr &#125; &#125; style &#x3D; &#123; display: &#39;flex&#39;, alignItems:&quot;center&quot;, marginBottom:&quot;20px&quot; &#125;&#x2F;&#x2F; 判断对象是否存在空值 getDetaios(arr) &#123; for (var i in arr) &#123; if (arr[i] &#x3D;&#x3D; null) &#123; return true &#125; &#125; return false &#125;componentDidMount () &#123; this.props.onChange(this.state.domArr)&#125; onAdd &#x3D; ()&#x3D;&gt;&#123; const &#123;domArr&#125; &#x3D; this.state this.props.setFlag() if(domArr.length&gt;&#x3D;10) &#123; message.warning(&quot;最多添加10条！&quot;) return &#125; if(this.getDetaios(domArr[domArr.length-1])) &#123; message.warning(&quot;存在未填项或数据不正确，请检查！&quot;) return &#125; let nextStartDate &#x3D; moment(new Date()).format(&quot;YYYY-MM-DD&quot;) let nextEndDate &#x3D; moment(new Date()).add(7,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) if(domArr.length&gt;0) &#123; nextStartDate &#x3D; moment(domArr[domArr.length-1].endDate).add(1,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) nextEndDate &#x3D; moment(nextStartDate).add(7,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) &#125; const obj &#x3D;&#123; unitPrice:null, paymentCompanyId:null, startDate:nextStartDate, endDate: nextEndDate, &#125; domArr.push(obj) this.setState(&#123; domArr, &#125;,()&#x3D;&gt;&#123; this.props.onAdd(domArr) &#125; ) &#125; startChange (startDate,index) &#123; const domArr &#x3D; this.state.domArr const time &#x3D; moment(startDate).diff(moment(domArr[index].endDate)) if(time&gt;0) &#123; message.warning(&quot;开始时间必须在结束时间之前！&quot;) return &#125; domArr[index].startDate &#x3D; startDate this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; endChange (endDate,index) &#123; const domArr &#x3D; this.state.domArr let time if( domArr[index+1]) &#123; time &#x3D; moment(endDate).diff(moment(domArr[index+1].endDate)) &#125; if(time&gt;0||time&#x3D;&#x3D;&#x3D;0) &#123; domArr.forEach((item,i)&#x3D;&gt;&#123; if(i&gt;index) &#123; item.endDate &#x3D; null item.startDate &#x3D; null &#125; &#125;) &#125; if(domArr[index+1]) &#123; domArr[index+1].startDate &#x3D; moment(endDate).add(1,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) &#125; domArr[index].endDate &#x3D; endDate this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; feeChange (fee,index) &#123; const domArr &#x3D; this.state.domArr domArr[index].unitPrice &#x3D; fee this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; companyChange (e,index) &#123; const domArr &#x3D; this.state.domArr domArr[index].paymentCompanyId &#x3D; e this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; render() &#123; const &#123;domArr&#125; &#x3D; this.state return &lt;div style&#x3D;&#123;&#123;width:&quot;552px&quot;&#125;&#125;&gt; &#123;domArr&amp;&amp;domArr.map((item,index)&#x3D;&gt;&#123; return &lt;div key&#x3D;&#123;index&#125;&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 时间周期：&lt;&#x2F;label&gt; &lt;DatePicker placeholder&#x3D;&quot;开始时间&quot; disabled&#x3D;&#123;index!&#x3D;&#x3D;0&#125; value &#x3D; &#123;moment(item.startDate,&quot;YYYY-MM-DD&quot;)&#125; onChange&#x3D;&#123;(e,date)&#x3D;&gt;&#123; this.startChange(date,index) &#125;&#125;&#x2F;&gt; &lt;span&gt;—&lt;&#x2F;span&gt; &lt;DatePicker placeholder&#x3D;&quot;结束时间&quot; defaultValue&#x3D;&#123;moment(item.endDate,&quot;YYYY-MM-DD&quot;)&#125; disabledDate&#x3D;&#123;(current)&#x3D;&gt; &#123; return current &amp;&amp; current &lt;moment(item.startDate) &#125;&#125; onChange&#x3D;&#123;(e,date)&#x3D;&gt;&#123; this.endChange(date,index) &#125;&#125; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 托管费用：&lt;&#x2F;label&gt; &lt;Input defaultValue&#x3D;&#123;item.unitPrice&#125; type&#x3D;&quot;number&quot; style&#x3D;&#123;&#123; &#39;width&#39;: &#39;300px&#39; &#125;&#125; onChange&#x3D;&#123;(e)&#x3D;&gt;&#123; this.feeChange(e.target.value,index) &#125;&#125; placeholder&#x3D;&quot;请输入托管费用&quot; addonAfter&#x3D;&quot;元&#x2F;年&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 承担企业：&lt;&#x2F;label&gt; &lt;AutoSearch key&#x3D;&#123;item.companyName||&#39;add&#39;&#125; placeholder&#x3D;&#39;请输入商户名称模糊搜索&#39; config&#x3D;&#123;&#123; allowClear: true,&#x2F;&#x2F;是否允许清除, showParam: &#39;companyName&#39;, &#x2F;&#x2F; 展示的条目参数 choseParam: &#39;companyId&#39;, &#x2F;&#x2F; 选中的参数 sourceApi: companyList, &#x2F;&#x2F; 选项接口 initialValue: item.companyName, fetchParams:&#123; status:1 &#125; &#125;&#125; module&#x3D;&#39;company&#39; setValue&#x3D;&#123;(e) &#x3D;&gt; &#123; this.companyChange(e,index) &#125;&#125; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;hr&#x2F;&gt; &lt;&#x2F;div&gt; &#125;) &#125; &lt;div style&#x3D;&#123;&#123;display: &quot;flex&quot;,justifyContent:&quot;center&quot;&#125;&#125;&gt; &lt;Button type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123; this.onAdd() &#125;&#125;&gt; 添加规则&lt;&#x2F;Button&gt; &#123;domArr&amp;&amp;domArr.length!&#x3D;&#x3D;0? &lt;Button style&#x3D;&#123;&#123;marginLeft:&quot;20px&quot;&#125;&#125; type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123; this.props.onDel() &#125;&#125;&gt;删除&lt;&#x2F;Button&gt;:&quot;&quot;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#125;&#125;TrusteeshipForm &#x3D; Form.create(&#123;&#125;)(TrusteeshipForm)export default TrusteeshipForm;","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"https://gitee.com/shimmer612/myBlog/tags/antd/"}]},{"title":"星球空间站项目总结","slug":"2021-06-30-星球空间站项目总结","date":"2021-06-29T16:00:00.000Z","updated":"2021-06-30T14:10:40.226Z","comments":true,"path":"2021/06/30/2021-06-30-星球空间站项目总结/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/30/2021-06-30-%E6%98%9F%E7%90%83%E7%A9%BA%E9%97%B4%E7%AB%99%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"“星球空间站”项目总结星球空间站是OMS项目的3.0版本，入职以来，都是在老项目中写页面，上一个项目组中的新项目《重卡换电》场站管理系统，做到80%,就被调走了，不过也只是写写页面，项目都是健哥搭的umijs 星球空间站算是第一个全部由我开发的项目。虽然只算是OMS的一个导航页面。不过对于我来说，也是很好的锻炼了。 今天把遇到的一些知识点记录一下。 最终图差不多如下。 如下 1、首页有三个echarts图表，一个曲线折线图。两个环形图。 ​ 这个比较简单一些，因为之前有recat引用echarts的经验，所以官网找到相关的示例。 只是改样式比较麻烦。只能慢慢找配置项。 这里记录一下用到的配置项，里面详细的配置就不记录了。 配置项的地址如下 https://echarts.apache.org/zh/option.html 1234567legend 图例。dataZoom 用于区域缩放，就是图表可以放大缩小，左右滑动tooltip提示框。 鼠标移到表格上可以提示数据series系列列表。每个系列通过 type 决定自己的图表类型，放数据以及数据怎么展示的地方xAxis 直角坐标轴 x轴yAxis 直角坐标轴 y轴 等等 然后还有的就是。echarts的加载、数据动态绑定等，大小随窗口变化等要注意的地方 2、下面导航按钮图标使用iconfont 之前使用iconfont都是下载的png图片，这里要用代码引入 一开始使用的css引入发现图标没有颜色都是黑的，问了一下，要用symbol 方式引入，就是js方式： 1：我是先新建了一个iconfont的js文件 12345678910 import &#123; Icon &#125; from &#x27;antd&#x27;; const IconFont = Icon.createFromIconfontCN(&#123; scriptUrl: &#x27;symbol方式在线地址&#x27; &#125;); export default IconFont; 2：使用，type就是图标的名 1&lt;IconFont type=&quot;icon-ali-pay&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;lightblue&#x27; &#125;&#125; /&gt; 3、日历组件 最烦的就是这个花了我大量的时间，本来想使用ant的现成组件，可是不会复写样式，而且也麻烦，心一横手写吧。 因为之前在小程序中写过，获取到当月的天数，然后通过第一天是星期几，来判断上月显示几天，下月显示几天。我这里第一天是兴趣一，要是上个月最后一天是星期天就不用显示了。是星期一的话就显示最后一天，星期二最后2天以此类推。下个月就是下个月第一天是星期一就不用显示。星期天就显示下个月第一天。星期二就显示下个月一二两天，依次类推。 然后三个数组拼成一个数组用arr.concat()连接数组。 又因为日期要可以点击，样式产生变化，而且可以获取到当前日期， 日期数组中，每一项的结构如下, flag是判断当前哪个日期被选中了，初始化当天的flag为true isActivity是判断当前日前有没有活动 1234567[&#123;year:2021,month：6,day:30,flag:true,isActivity:true&#125;] 然后就是点击上月日期和下月日期切换月份。 判断当前点击的日期月份。 select框也是和数据绑定， 需要考虑的就是setState()是异步的，需要在setState()的回调中，或者setTimeout()调用相关的方法,以及方法的传参等等。 4、主要的就是这些，还有的就是路由传值、跳转，因为oms没有路由通过tabs页签切换页面的，吧tab的 key传过去等 父组件中跳转传参 12345this.props.history.push(&#123; pathname:&quot;/index&quot;, name:&quot;xxx&quot;,//参数 age:&quot;18&quot;&#125;) 子组件中： 12345678//父组件通过props传给子组件&lt;Child history=&#123;this.props.history&#125;/&gt; this.props.history.push(&#123; pathname:&quot;/index&quot;, name:&quot;xxx&quot;,//参数 age:&quot;18&quot;&#125;) 接收在location： 12this.props.history.location.namethis.props.history.location.age 还有就是moment.js计算两天某天相差多少天,倒计时 moment(endTime).diff(moment(startTime),&#39;day&#39;) 天 moment(endTime).diff(moment(startTime),&#39;month&#39;)月 moment(endTime).diff(moment(startTime),&#39;year&#39;) 年 还有就是一些布局方面注意的东西。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"}]},{"title":"菊次郎的夏天观后感","slug":"2021-06-12-菊次郎的夏天观后感","date":"2021-06-11T16:00:00.000Z","updated":"2021-06-12T09:56:33.113Z","comments":true,"path":"2021/06/12/2021-06-12-菊次郎的夏天观后感/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/12/2021-06-12-%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/","excerpt":"","text":"《菊次郎的夏天》观后感1、《菊次郎的夏天》这部电影评分很高 久石让给电影配乐 就算你不知道这部电影 也应该听过 让人很舒服的曲子 剧中大叔菊次郎帮正太找妈妈 结果正太的妈妈有了新的家庭 ”地方对了，人不对“ 欢笑中见温情 剧中他们遇到的人都很温柔 小情侣、摩托二人组、吟游诗人 其实这个电影就是说大叔菊次郎小时候的故事 熟悉的音乐开始 熟悉的音乐结束 只是片尾的音乐多了一丝轻快与愉悦 温馨的音乐， 像夏天傍晚微凉的风迎面吹来，看着大海 这样的音乐 却不经意就让人湿了眼眶 2、其实很怀念剧中的夏天 谁的童年不曾有过那样的一个类似的暑假呢 只是现在就算回到了童年的场景 也不有当时的人了 那时的景那时的人 停留在那时空了 3、最近很闲 有个十天左右的时间 不用上班 很闲 九十点就睡觉，五六点就起床 睡得早、起的早 像个老年人 想想人生的前几个阶段 我好像不是一个善于维护关系的人 每一个阶段看起来都和身边的人玩的很好 当那个阶段结束 就从来不联系了 仿佛这个人没有在我的生命中出现过一样 我总以为 该在的人，总会一直在那的 无需联系 需要联系我也不知道联系什么 我本是一个无趣的人 生活中见不起什么波澜 也没有什么分享欲 按理说我应该很合适一个人的 但是我有希望时不时能有个人陪我一起去干点什么 其实每个人身边都应该有一两个好朋友的 可我没有 按理说我其实也不差 做事情从来不会想太多 直言直语 可为什么有人背后说我有心机太重 很莫名其妙","categories":[],"tags":[{"name":"观后感","slug":"观后感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"杂记07(再见我的学生时代)","slug":"2021-06-10-杂记07(再见我的学生时代)","date":"2021-06-09T16:00:00.000Z","updated":"2021-06-10T04:13:52.028Z","comments":true,"path":"2021/06/10/2021-06-10-杂记07(再见我的学生时代)/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/10/2021-06-10-%E6%9D%82%E8%AE%B007(%E5%86%8D%E8%A7%81%E6%88%91%E7%9A%84%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3)/","excerpt":"","text":"和学生的身份说再见时间真的过的很快 曾经遥遥无期的毕业 也来到了眼前 这次的毕业也真正的要与学生的身份说再见了 以前总是想尽快的告别学生的身份 走进社会干一番大事业 当这个时间点真实的到达眼前 却想着时间你能不能再慢一点 小学、初中、高中以往的毕业总是离别中带着一丝轻松愉快的 考完试，就是漫长的假期，不紧不慢 有大把的时间能让我们去迎接下一阶段的生活 大学毕业却是紧迫的 实习的我，半只脚已经踏入社会 请假答辩交材料 聚会、离别 租房、搬家 在一天天的忙碌中 我离开了校园 自由却又束缚 不像我想的那样美好 租房确实给了自己一方天地 我养了猫 名字叫 拾月 是个橘猫妹妹 这个小家伙 给我的生活带来了很多的惊喜 同时也很闹心 就和养一个孩子一样 我不是一个很乐观的人 但总是会在悲观的情绪中给自己一点暗示 会好起来的 最后 再见我的学生时代 （睡觉的拾月）","categories":[],"tags":[{"name":"随感","slug":"随感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E6%84%9F/"}]},{"title":"把多层嵌套的一层数据结构转换成原本的多层","slug":"2021-04-20-把多层嵌套的一层数据结构转换成原本的多层","date":"2021-04-19T16:00:00.000Z","updated":"2021-04-21T00:44:36.572Z","comments":true,"path":"2021/04/20/2021-04-20-把多层嵌套的一层数据结构转换成原本的多层/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/20/2021-04-20-%E6%8A%8A%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E4%B8%80%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8E%9F%E6%9C%AC%E7%9A%84%E5%A4%9A%E5%B1%82/","excerpt":"","text":"背景一个多层嵌套评论回复的场景，但是孤儿后端，把所有的回复数据，放到一个数组里返回给我，只有一层，我要给数据转换成原先的多层嵌套的模式。 数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//commitId是最外层的评论ID//id是每条回复自己的ID//replyId是回复父级的Id//现在要把每个子级回复放到父级回复的child里面let data = [ &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;da642ba6-52b2-4965-bf39-c21f8f2ceaf0&quot;, replyId: &quot;fb0a7604-68cb-45c7-b149-99dceb5a6004&quot;, replyMsg: &quot;1-1-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;e5def846-c747-496b-9ab8-270655bc269b&quot;, replyId: &quot;a583dd34-ff71-44dd-9eaa-5b753501b9a6&quot;, replyMsg: &quot;2-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;a583dd34-ff71-44dd-9eaa-5b753501b9a6&quot;, replyId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, replyMsg: &quot;2&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;9de4bb96-16e5-4570-b03f-60ac2beb8965&quot;, replyId: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyMsg: &quot;1-2&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;fb0a7604-68cb-45c7-b149-99dceb5a6004&quot;, replyId: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyMsg: &quot;1-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, replyMsg: &quot;1&quot;, child: [] &#125;] 看到这个场景，第一时间想到的就是递归。 但是逻辑想了很久才想出来。 其实很简单，想不通，想死了都想不出来。 想通了就很简单。 12345678910111213function dg(id) &#123; let arr = [] for(let i = 0;i&lt;data.length;i++) &#123; if(data[i].replyId === id)&#123; arr.push(data[i]) data[i].child = dg(data[i].id) &#125; &#125; return arr&#125; 如下 tips:今天是她的生日，我什么都没干，太棒了！","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"递归实现多层评论","slug":"2021-04-19-递归实现多层评论","date":"2021-04-18T16:00:00.000Z","updated":"2021-04-19T09:12:22.880Z","comments":true,"path":"2021/04/19/2021-04-19-递归实现多层评论/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/19/2021-04-19-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E8%AF%84%E8%AE%BA/","excerpt":"","text":"多层评论递归嵌套递归函数两部曲 1：找规律 2：找出口 数据格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const obj = [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [] &#125;, &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [] &#125;, ] &#125; ] &#125; ] &#125;] 1234567891011121314151617181920212223242526272829303132333435363738394041// 评论递归 repleyRecursion = (k) =&gt; &#123; const &#123; replyArr &#125; = this.state if (k.length !== 0) &#123; k.map((item, index) =&gt; &#123; replyArr.push(&lt;div style=&#123;&#123; width: &quot;700px&quot;, display: &quot;flex&quot;, justifyContent: &quot;space-between&quot;, alignItems: &quot;center&quot;, marginBottom: &quot;10px&quot; &#125;&#125;&gt; &lt;span&gt;用户账号：&#123;item.replyUserName&#125;&lt;/span&gt; &lt;span&gt;回复时间: &#123;item.replyTime&#125;&lt;/span&gt; &lt;span&gt;回复内容：&#123;item.replyMsg&#125;&lt;/span&gt; &lt;div&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; &#123; this.setState(&#123; replyVisible: true, commentId: item.commentReplyId, userId: item.replyUserId &#125;) &#125;&#125;&gt;回复&lt;/Button&gt; &lt;Popconfirm title=&quot;确认删除评论吗？&quot; onConfirm=&#123;() =&gt; &#123; this.deleteReply(item.commentId) &#125;&#125; onCancel=&#123;&quot;&quot;&#125; okText=&quot;确定&quot; cancelText=&quot;取消&quot; &gt; &lt;Button type=&quot;primary&quot;&gt;删除&lt;/Button&gt; &lt;/Popconfirm&gt; &lt;/div&gt; &lt;/div&gt;) this.repleyRecursion(item.childCommentReplyBo) &#125;) &#125; else &#123; return replyArr.map((item, i) =&gt; &#123; return item &#125;) &#125; &#125;","categories":[],"tags":[{"name":"-javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"javascript排序算法01","slug":"2021-04-15-javascript排序算法01","date":"2021-04-14T16:00:00.000Z","updated":"2021-04-15T09:42:04.768Z","comments":true,"path":"2021/04/15/2021-04-15-javascript排序算法01/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/15/2021-04-15-javascript%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/","excerpt":"","text":"冒泡排序两两对比，如果n项大于n+1项，就交换位置。 基本的 forEach执行就是所有循环结束，不能break。map同理 12345678910111213141516171819const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]// const arr = [1, 2, 3, 4, 5, 6, 7]let a = 0//基本 arr.forEach(() =&gt; &#123; arr.forEach((k, i) =&gt; &#123; const count = arr[i + 1] if (arr[i] &gt; arr[i + 1]) &#123; arr[i + 1] = arr[i] arr[i] = count &#125; &#125;) &#125;)console.log(a);console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 优化版 123456789101112131415161718192021// 优化const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]for (var i = 0; i &lt; arr.length - 1; i++) &#123; var flag = false; for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; a++ if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if (flag == false) &#123; break; &#125;&#125;console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 选择排序每次排序把最大的或者最小的放到开头或者末尾 1234567891011121314151617181920212223const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]function selectSort(arr) &#123; let minIndex, temp for (let i = 0; i &lt; arr.length - 1; i++) &#123; // 保存当前下标 minIndex = i // 找到最小的数的下标 for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; // 每次找出的最小数和当前的数交换位置 temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr&#125;selectSort(arr)console.log(arr);//[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 插入排序从第二个数开始，如果当前数大于或者小于前一个数，就交换位置 123456789101112131415161718192021222324252627282930313233343536const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]function insertSort(arr) &#123; var len = arr.length; for (var i = 1; i &lt; len; i++) &#123; //key为当前数 var key = arr[i]; // j为前一个数的下标 var j = i - 1; //如果前一个数大于当前数 while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; //当前数等于前一个数 arr[j + 1] = arr[j]; //j减一 j--; &#125; //满足条件的最前面的数等于当前数 arr[j + 1] = key; &#125; return arr;&#125;insertSort(arr)console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ]","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"聊天框自动定位到最底部","slug":"2021-04-12-聊天框自动定位到最底部","date":"2021-04-11T16:00:00.000Z","updated":"2021-04-12T08:52:27.818Z","comments":true,"path":"2021/04/12/2021-04-12-聊天框自动定位到最底部/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/12/2021-04-12-%E8%81%8A%E5%A4%A9%E6%A1%86%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%9C%80%E5%BA%95%E9%83%A8/","excerpt":"","text":"介绍最近通过webSocket实现了客服聊天的功能，但是当消息超出聊天框的时候，消息框并不会自动滚到到最新消息的地方。要手动滚动，很蠢。 而且一开始的滚动条很丑，顺便美化了一下滚动条。 vue中写在updated的生命周期里/react写在componentDidUpdate生命周期里 1234567updated () &#123; // 聊天定位到底部 this.$nextTick(() =&gt; &#123; const msg = document.getElementsByClassName(&#x27;chat-info&#x27;) // 获取对象 msg[0].scrollTop = msg[0].scrollHeight // 滚动高度 &#125;) &#125;, css 1234567891011::-webkit-scrollbar &#123; // display: none; width: 5px; height: 100%; background: rgb(239, 239, 239); border-radius: 2px;&#125;::-webkit-scrollbar-thumb &#123; background: #bfbfbf; border-radius: 10px;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"express-ws实现webSocket通信","slug":"2021-04-10-express-ws实现webSocket通信","date":"2021-04-09T16:00:00.000Z","updated":"2021-04-12T00:42:03.873Z","comments":true,"path":"2021/04/10/2021-04-10-express-ws实现webSocket通信/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/10/2021-04-10-express-ws%E5%AE%9E%E7%8E%B0webSocket%E9%80%9A%E4%BF%A1/","excerpt":"","text":"前言最近要给自己写的项目中加一个客服聊天的功能。就是前端商城和后台管理系统通信。但是是两个不同的端口。 百度了一下就找到了webSocket。 什么是webSocket？WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。(来自菜鸟教程：https://www.runoob.com/html/html5-websocket.html) express-ws实现1、首先在express项目中安装express-ws npm i express-ws --save 2、然后引入 123456const express = require(&#x27;express&#x27;)const app = express()// 引入WebSocketconst ws = require(&quot;express-ws&quot;)// 将webSocket服务混入app，相当于为app添加.ws方法ws(app) 3、启动服务 12345678910111213141516171819202122232425//为了获取到所以的客户端const wss = ws(app).getWss(&#x27;/&#x27;)// 建立webSocket服务app.ws(&#x27;/&#x27;, (ws, req) =&gt; &#123; console.log(&quot;连接成功！&quot;); // send给客户端发消息 // on是监听事件 // message表示服务端传来的数据 ws.on(&quot;message&quot;, (msg) =&gt; &#123; // 给所有的客户端广播消息 wss.clients.forEach((e) =&gt; &#123; e.send(msg) &#125;) &#125;) // close 事件表示客户端断开连接时执行的回调函数 ws.on(&#x27;close&#x27;, function (e) &#123; console.log(&#x27;close connection&#x27;) &#125;) &#125;)app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 此时服务已经在3002端口跑起来了 前端接收消息1、vue中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;script&gt; //连接webSocketconst ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)export default &#123; data () &#123; return &#123; msg: &#x27;&#x27;, msgList: [] &#125; &#125;, mounted () &#123; // 绑定webSocket事件 //连接成功的回调 ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) //关闭的回调 ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) //连接错误的回调 ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) //接收发送消息的回调 ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125;, methods: &#123; sendMessage () &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = window.sessionStorage.getItem(&#x27;nickname&#x27;) const msg = JSON.stringify(&#123; msg: this.msg, name: name, date: date, left: true &#125;) ws.send(msg) // 发送完清空聊天框 this.msg = &#x27;&#x27; &#125;, handleWsOpen () &#123; console.log(&#x27;聊天已经启动！&#x27;) &#125;, handleWsClose () &#123; console.log(&#x27;聊天已经关闭！&#x27;) &#125;, handleWsError () &#123; console.log(&#x27;聊天出错！&#x27;) &#125;, // 收发消息 handleWsMessage (e) &#123; console.log(e) const msg = JSON.parse(e.data) this.msgList.push(msg) &#125; &#125;&#125;&lt;/script&gt; 2、react中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)class Chat extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &quot;&quot;, msgList:[] &#125; &#125; componentDidMount () &#123; ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125; sendMessage = ()=&gt; &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = &quot;客服&quot; const msg = JSON.stringify(&#123; msg: this.state.msg, name: name, date: date, left: false &#125;) ws.send(msg) // 发送完清空聊天框 this.setState(&#123; msg:&quot;&quot; &#125;) &#125; handleWsOpen () &#123; message.success(&quot;连接成功&quot;) &#125; handleWsClose () &#123; message.info(&quot;聊天结束&quot;) &#125; handleWsError () &#123; message.error(&quot;连接失败&quot;) &#125; // 收发消息 handleWsMessage (e) &#123; const msg = JSON.parse(e.data) let arr = this.state.msgList arr.push(msg) this.setState(&#123; msgList:arr &#125;) &#125; render () &#123; const msgList = this.state.msgList return ( &lt;Content className=&quot;site-layout-background&quot; &gt; &lt;div className=&quot;chatBox&quot;&gt; &lt;div className=&quot;chat&quot;&gt; &#123;/* 展示消息 */&#125; &lt;div className=&quot;chat-info&quot;&gt; &#123;msgList.map((item, k) =&gt; &#123; return &lt;div className=&quot;info-detail&quot;&gt; &lt;div className=&#123;item.left?&#x27;head-a&#x27;:&#x27;head&#x27;&#125;&gt; &lt;span className=&#123;item.left?&#x27;name-a&#x27;:&#x27;name&#x27;&#125;&gt;&#123;item.name&#125;&lt;/span&gt; &lt;span&gt;&#123;item.date&#125;&lt;/span&gt; &lt;/div&gt; &lt;div className=&#123;item.left?&#x27;info-main-a&#x27;:&#x27;info-main&#x27;&#125;&gt; &lt;span&gt;&#123;item.msg&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#125;) &#125; &lt;/div&gt; &#123;/* 发送消息 */&#125; &lt;div className=&quot;send-msg&quot;&gt; &lt;Input value=&#123;this.state.msg&#125; onChange=&#123;(e) =&gt; &#123; this.setState(&#123; msg:e.target.value &#125;) &#125;&#125; placeholder=&quot;请输入...&quot; style=&#123;&#123; width: &quot;350px&quot;, marginRight: &quot;10px&quot; &#125;&#125; onPressEnter=&#123;() =&gt; &#123; this.sendMessage() &#125;&#125; &gt; &lt;/Input&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; &#123; this.sendMessage() &#125;&#125;&gt; 发送 &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Content &gt; ) &#125;&#125; 效果如下： vue全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;template&gt; &lt;div class=&quot;chat&quot;&gt; &lt;div class=&quot;chat-box&quot;&gt; &lt;div class=&quot;chat-info&quot;&gt; &lt;div class=&quot;info-detail&quot; v-for=&quot;(item,k) in msgList&quot; :key=&quot;k&quot;&gt; &lt;div :class=&quot;item.left?&#x27;head&#x27;:&#x27;head-a&#x27;&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;item.date&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div :class=&quot;item.left?&#x27;info-main&#x27;:&#x27;info-main-a&#x27;&quot;&gt; &lt;span&gt;&#123;&#123;item.msg&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;chat-message&quot;&gt; &lt;el-input v-model=&quot;msg&quot; placeholder=&quot;请输入内容&quot; @keyup.enter.native=&quot;sendMessage&quot; &gt; &lt;el-button slot=&quot;append&quot; type=&quot;primary&quot; @click=&quot;sendMessage&quot; &gt;发送&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)export default &#123; data () &#123; return &#123; msg: &#x27;&#x27;, msgList: [] &#125; &#125;, mounted () &#123; // 绑定webSocket事件 ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125;, methods: &#123; sendMessage () &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = window.sessionStorage.getItem(&#x27;nickname&#x27;) const msg = JSON.stringify(&#123; msg: this.msg, name: name, date: date, left: true &#125;) ws.send(msg) // 发送完清空聊天框 this.msg = &#x27;&#x27; &#125;, handleWsOpen () &#123; console.log(&#x27;聊天已经启动！&#x27;) &#125;, handleWsClose () &#123; console.log(&#x27;聊天已经关闭！&#x27;) &#125;, handleWsError () &#123; console.log(&#x27;聊天出错！&#x27;) &#125;, // 收发消息 handleWsMessage (e) &#123; console.log(e) const msg = JSON.parse(e.data) this.msgList.push(msg) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chat &#123;padding: 100px 300px 0 300px;display: flex;justify-content: center;.chat-box&#123;margin-top: 20px;padding: 10px 10px 10px 10px;width: 400px;height: 600px;background-color: #fff;border-radius: 10px 10px 0 0 ;.chat-info&#123; height: 550px; overflow: auto; .info-detail&#123; margin-bottom: 5px; .head&#123; width: 100%; margin-bottom: 5px; display:flex; flex-direction: row-reverse; .name&#123; margin-left: 5px; color: rgb(240, 74, 74); &#125; &#125; .head-a&#123; width: 100%; margin-bottom: 5px; .name&#123; margin-right: 5px; color: rgb(22, 189, 240); &#125; &#125; .info-main-a&#123; font-size: 18px; font-family: 楷体; &#125; .info-main&#123; font-size: 18px; font-family: 楷体; display:flex; flex-direction: row-reverse; &#125; &#125;&#125;.chat-message&#123; height: 50px;&#125;&#125;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"webSocket","slug":"webSocket","permalink":"https://gitee.com/shimmer612/myBlog/tags/webSocket/"}]},{"title":"最近遇到的一些知识点","slug":"2021-04-07-最近遇到的一些知识点","date":"2021-04-06T16:00:00.000Z","updated":"2021-04-07T06:18:26.948Z","comments":true,"path":"2021/04/07/2021-04-07-最近遇到的一些知识点/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/07/2021-04-07-%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"判断一个数组是否为空12345const arr = []if(arr.length===0) &#123; console.log(&quot;改数组是空数组&quot;)&#125; 判断一个数组里是否有重复值1234567891011121314//循环添加到一个对象里，判断对象里是否有这个值var arr = [&quot;1111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;111&quot;, &quot;222&quot;]function isRepeat(arr) &#123; var hash = &#123;&#125;; for (var i in arr) &#123; if (hash[arr[i]]) &#123; console.log(arr[i] + &quot;重复了&quot;) &#125; hash[arr[i]] = &quot;have&quot;; &#125; console.log(hash); return false;&#125;isRepeat(arr) 两个对应的数组，删除对应值比如一个数组是[1,0,0,1,0,1,0,1,0,0]另外一个数组是[a,b,c,d,e,f,g,h,i,j],要删除后一个数组中对应前一个数组为1的元素。 我一开始想的是用找出第一个数组中元素1相对于的index然后用splice删除后一个数组中对应的项。 但是删除一次后，数组的长度就发生了改变，因为splice方法会改变原数组第二个splice删除的就不是正确的了。正确做法应该是删除的时候，往删除的地方添加一个空值，删除完后，删除这个空值。 1234567891011121314151617const a = [1,0,0,1,0,1,0,1,0,0]const b = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;]a.map((k,i)=&gt;&#123; if(k===1) &#123; b.splice(i,1,&quot; &quot;) &#125;&#125;)let c = []b.map((k,i)=&gt;&#123; if(k !== &quot; &quot;)&#123; c.push(k) &#125;&#125;)console.log(c) //[ &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;i&#x27;, &#x27;j&#x27; ]//c数组就是最后的数组","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"react类组件的数据顺序","slug":"2021-04-02-react类组件的数据顺序","date":"2021-04-01T16:00:00.000Z","updated":"2021-04-02T04:00:31.357Z","comments":true,"path":"2021/04/02/2021-04-02-react类组件的数据顺序/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/02/2021-04-02-react%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"昨日昨天写代码的时候，父组件通过props传值给子组件。我在子组件中在ComponentDidMount中用setState赋值render中拿不到。 代码如下 123456789101112131415161718192021class useDetail extends Component &#123; constructor(props) &#123; super(props) this.props = props this.state = &#123; useInfo: null &#125; &#125; componentDidMount () &#123; this.setState(&#123; useInfo:this.props.UseInfo &#125;) &#125; render() &#123; //拿不到值 const useInfo = this.state.useInfo const strategy = useInfo &amp;&amp; useInfo.strategy ? JSON.parse(useInfo.strategy.discountStrategy) : [] &#125; 这样就能获取到值，render在componentDidMount之前,所以值为undefined,传入的值可以直接放在state中赋值。 123456789101112class useDetail extends Component &#123; constructor(props) &#123; super(props) this.props = props this.state = &#123; useInfo: this.props.UseInfo &#125; &#125; render() &#123; const useInfo = this.state.useInfo const strategy = useInfo &amp;&amp; useInfo.strategy ? JSON.parse(useInfo.strategy.discountStrategy) : []&#125; over~","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"}]},{"title":"react hooks理解","slug":"2021-03-25-react-hooks理解","date":"2021-03-24T16:00:00.000Z","updated":"2021-03-25T05:50:55.167Z","comments":true,"path":"2021/03/25/2021-03-25-react-hooks理解/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/25/2021-03-25-react-hooks%E7%90%86%E8%A7%A3/","excerpt":"","text":"在函数式组件中发现了这样的一个问题，代码如下。按理说1处打印出来的isShow应该为true可是却是false 2处打印出来的是true 12345678910111213const demo = ()=&gt; &#123; const [isShow, setIsShow] = useState(false) //2console.log(isShow) return ( &lt;button onClick=&#123;()=&gt;&#123; setIsShow(true) //1 console.log(isShow) &#125;&#125;&gt;新增&lt;/button&gt; )&#125; 去百度了一些资料。 原来函数式组件每次更新的时候都会重新执行一次函数，此时 1处打印的isShow其实是初始的状态的旧值。形成了闭包。 2处外层能打印出来，是因为函数每次更新都要执行。 只有用useEffect才能获取到,绑定isShow为依赖。可以这样写: 123456789101112131415161718const demo = ()=&gt; &#123; const [isShow, setIsShow] = useState(false)useEffect(()=&gt;&#123; console.log(isShow)&#125;,[isShow]) //2console.log(isShow) return ( &lt;button onClick=&#123;()=&gt;&#123; setIsShow(true) //1 console.log(isShow) &#125;&#125;&gt;新增&lt;/button&gt; )&#125; hooks是有序的，会被react从上到下依次读取，所以不能在条件中使用，这样会导致解析的时候前后声明顺序不一致。hooks必须放在函数内部顶层。","categories":[],"tags":[{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"react hooks useEffect的使用","slug":"2021-03-24-react-hooks-useEffect的使用","date":"2021-03-23T16:00:00.000Z","updated":"2021-03-24T05:47:33.481Z","comments":true,"path":"2021/03/24/2021-03-24-react-hooks-useEffect的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/24/2021-03-24-react-hooks-useEffect%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"useEffect的tipsuseEffect的语法： 123useEffect(()=&gt;&#123;//逻辑&#125;,[]) 如果没有第二个空数组参数，useEffect就会在页面状态改变的时候执行，加了空数组参数，只会在页面mount的时候更新一次。 传第二个参数：可以用作页面数据初始化 不传第二个参数 按照useEffect的这个在页面状态变化的时候调用的特性，可以做很多东西。 可以每次数据变化的时候，把数据传给后台，相当于监听。 分数变化的时候打印当前得了多少分。 12345678910111213141516171819202122232425262728import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main = () =&gt; &#123; const [count, setCount] = useState(0); // 相当于componentDidMount和componentDidUpdate useEffect(() =&gt; &#123; // 打印点击的次数 console.log(`当前得分为$&#123;count&#125;`) &#125;) return ( &lt;div&gt; &lt;h1 onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;当前得分为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#x27;root&#x27;)); useEffect 不应该返回任何内容但是使用async await 会返回一个隐式的promise 1234//这样写是错误的useEffect(async()=&gt; &#123; await ...... &#125;) 应该把async await 写在useEffect里面，如： 12345678//应该这样写useEffect(()=&gt; &#123; async () =&gt; &#123; await..... &#125; &#125;,[]) 今天就记录到这，马上我把react-redux在复习一下。好久不用都忘的差不多了。","categories":[],"tags":[{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"杂记02","slug":"2021-03-22-杂记02","date":"2021-03-21T16:00:00.000Z","updated":"2021-03-22T09:28:12.629Z","comments":true,"path":"2021/03/22/2021-03-22-杂记02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/22/2021-03-22-%E6%9D%82%E8%AE%B002/","excerpt":"","text":"今天也没学什么新东西，但是博客总要点新的东西吧。就随便写一点吧。 今天想给自己的在线购物商城加一个客服聊天功能。百度了下用socket.io可以实现，但是自己折腾了半天也没有成功，就放弃了。 不过给订单页面加了一个快递查询的功能，用的假数据，点击直接返回一串快递信息，是我自己淘宝买东西的物流信息。用element-ui的TimeLine实现的。 其实想了很多功能，却不知道怎么实现，比如点击付款按钮，跳出来一个二维码，扫描二维码，跳转到订单页面，没有找到什么插件可以监听二维码的扫描事件。用的qrimage只能生成二维码，扫描跳转到设置特定的页面。 痛点很多，要学习的东西也很多。 总感觉自己不是一个合格的前端。 不务正业去学了后台。写了几个接口学了mongo,也满足自己平时写写小项目自己写后台了。也挺不错的。express真的挺香的。 昨天去滆湖公园放了风筝，很开心。和高中同学聊聊天散散步真的很愉快。 还是没事多出去走一走，呼吸呼吸新鲜的空气。 整个人的精神会好很多。 看着漫天的飞翔的风筝，抽芽的柳树，盛开的油菜花和家乡的Sakura。 那时候之前所有的烦闷与苦痛全部抛在脑后。 真好！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"创建一个vue3.0+element-plus项目","slug":"2021-03-20-创建一个vue3.0+element-plus项目","date":"2021-03-19T16:00:00.000Z","updated":"2021-03-20T06:15:27.903Z","comments":true,"path":"2021/03/20/2021-03-20-创建一个vue3.0+element-plus项目/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/20/2021-03-20-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAvue3.0+element-plus%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"创建一个vue3.0+element-plus项目首先要确认自己电脑中的@vue/cli&gt;4.5 可以用vue -V查看 没有的话可以用npm i -g @vue/cli升级 升级成功后 **vue create my-pro**这里选择Vue 3的项目。 创建成功后。 执行下面的命令。 12cd my-provue add element-plus 全局加载和按需加载自己选择。 安装成功后。 npm run serve 发现项目跑起来了。 按需加载的话，需要在src/plugins/element.js文件里，引入自己所需要的组件就可以了。 1234567import &#123; ElButton,ElTimeline &#125; from &#x27;element-plus&#x27;export default (app) =&gt; &#123; app.use(ElButton) app.use(ElTimeline)&#125;","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"}]},{"title":"Vue3中路由的相关配置","slug":"2021-03-16-Vue3中路由的相关配置","date":"2021-03-15T16:00:00.000Z","updated":"2021-03-17T01:25:00.647Z","comments":true,"path":"2021/03/16/2021-03-16-Vue3中路由的相关配置/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/16/2021-03-16-Vue3%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Vue3中路由的相关配置1、路由的配置在src路径下新建router文件夹，然后在该文件夹新建index.js文件 安装vue-router 1cnpm i vue-router@next --save index.js文件配置如下。 12345678910111213141516171819202122232425262728import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const addCount = () =&gt; import(&#x27;../components/addCount.vue&#x27;)const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/add&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, &#125;, &#123; path: &quot;/add&quot;, component: addCount &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router 然后配置main.js 引入router 1234567891011121314151617import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./index.css&#x27;//使用router//引入elementPlusimport ElementPlus from &#x27;element-plus&#x27;;import &#x27;element-plus/lib/theme-chalk/index.css&#x27;;//引入routerimport router from &#x27;./router/index&#x27;const app = createApp(App)//使用ElementPlusapp.use(ElementPlus)//使用routerapp.use(router)app.mount(&#x27;#app&#x27;) 2、路由的跳转方式一 引入useRouter 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter&#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const changeRouter = () =&gt; &#123; router.push(&#x27;/father&#x27;) &#125; return &#123; changeRouter &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 方式二router-link 1&lt;router-link to=&quot;/child&quot;&gt;子页面&lt;/router-link&gt; 方式三 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;toAdd&quot;&gt;下一页&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from &#x27;../router/index.js&#x27;export default &#123; methods: &#123; toAdd() &#123; router.push(&#x27;/add&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3、路由的传参引入useRoute 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const route = useRoute() const changeRouter = () =&gt; &#123; router.push(&#123; path: &#x27;/father&#x27;, query: &#123; name: &#x27;zz&#x27;, &#125;, &#125;) &#125; return &#123; changeRouter &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 如下图：在father页面就可以通过route.query.name获取到”zz” 4、路由的嵌套通过router-view和子路由的方式嵌套 router/index.js 123456789101112131415161718192021222324252627282930import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const children = () =&gt; import(&#x27;../components/child.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/father&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, children: [ &#123; path: &#x27;/child&#x27;, component: children &#125; ] &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router father.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h&quot;&gt;我是爷爷&lt;/h1&gt; &lt;br /&gt; &lt;router-link to=&quot;/child&quot;&gt;下一页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; child.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;hr&gt; &lt;h1&gt;我是儿子&lt;/h1&gt; &lt;/div&gt; &lt;Sunzi /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sunzi from &#x27;./sunzi.vue&#x27;export default &#123; components: &#123; Sunzi, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行如下图所示：","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"如何在vue的css中使用data中的变量","slug":"2021-03-15-如何在vue的css中使用data中的变量","date":"2021-03-14T16:00:00.000Z","updated":"2021-03-16T02:54:26.599Z","comments":true,"path":"2021/03/15/2021-03-15-如何在vue的css中使用data中的变量/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/15/2021-03-15-%E5%A6%82%E4%BD%95%E5%9C%A8vue%E7%9A%84css%E4%B8%AD%E4%BD%BF%E7%94%A8data%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/","excerpt":"","text":"如何在vue的css中使用data中的变量。 很简单用v-bind 一个简单的例子 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; &gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; color: &#x27;red&#x27;, &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行如下图所示：成功设置了文字的颜色。 这样就可以做一个文字颜色不断变化的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; @click=&quot;changeColor&quot;&gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeColor&quot;&gt;变色&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; Child, &#125;, data() &#123; return &#123; color: &#x27;red&#x27;, count: 1, &#125; &#125;, created () &#123; setInterval(()=&gt;&#123; this.changeColor() &#125;,500) &#125;, methods: &#123; changeColor() &#123; const arr = [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;black&#x27;, &#x27;hotpink&#x27;, &#x27;purple&#x27;, &#x27;lime&#x27;, &#x27;skyblue&#x27;, ] this.color = arr[this.count] this.count++ if (this.count === 8) &#123; this.count = 0 &#125; &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行结果如下图： 是不是感觉要方便许多。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"CSS的一些知识点","slug":"2021-03-12-CSS的一些知识点","date":"2021-03-11T16:00:00.000Z","updated":"2021-03-12T08:32:26.410Z","comments":true,"path":"2021/03/12/2021-03-12-CSS的一些知识点/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/12/2021-03-12-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"今天是三月十二日植树节，记录一些自己写样式的时候，以前不知道的东西。 1、设置padding的时候为了不改变盒子的大小要设置box-sizing:border-box 2、盒子内部阴影在末尾加一个inset比如box-shadow: 0 0 5px 0 red inset 3、设置透明度的时候opacity:0.8这样会让父元素子元素也改变透明度。可以改成rgba(255,255,255,0.8)的这种方式 4、网页字体最小就是12px 5、设置背景图时使用路径时 background-image: url(~@/assets/carMonitor/warn-info.png);写成这种样式。还有加上 background-size: cover; 不想写了，今天很难受，心情很不好。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"node.js+express+mongodb来开发后端","slug":"2021-03-10-node.js+express+mongodb来开发后端","date":"2021-03-10T16:00:00.000Z","updated":"2021-03-11T01:21:12.502Z","comments":true,"path":"2021/03/11/2021-03-10-node.js+express+mongodb来开发后端/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/11/2021-03-10-node.js+express+mongodb%E6%9D%A5%E5%BC%80%E5%8F%91%E5%90%8E%E7%AB%AF/","excerpt":"","text":"node.js+express+mongodb来开发后端大四临近毕业，要开始写毕业设计，但是作为前端的我，对后端一窍不通。然后想到nodejs也可以写后端。用的就是javascript。应该学习成本不是很高。 如今已经写好了毕设。但是对当时怎么用nodejs+express+mongodb写接口有点遗忘了。 今天来记录一下。以便后面来复习和查找。 1、安装expressnpm install express --save 2、新建一个js文件123456789101112131415161718192021222324252627282930313233343536373839//引入express并绑定到app上const express = require(&#x27;express&#x27;)const app = express()// 静态资源路径app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;))// 跨域app.use(require(&#x27;cors&#x27;)())// express 处理jsonapp.use(express.json())// 接口的开发app.use(&#x27;/&#x27;,require(&#x27;./router/user&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/address&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/admin&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/banner&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/cat&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goods&#x27;))// app.use(&#x27;/&#x27;,require(&#x27;./router/hotGoods&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/order&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/shopcart&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/star&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/upload&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goodsBuyCount&#x27;))// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 3、mongoose的使用安装mongoose npm i mongoose --save 新建一个js文件 123456789101112131415161718//引入mongooseconst mongoose = require(&#x27;mongoose&#x27;)// 连接数据库mongoose.connect(&#x27;mongodb://localhost:27017/storedb&#x27;, &#123; useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true&#125;)//创建数据模型，类似于表const CateSchema = new mongoose.Schema(&#123; //字段名称与字段类型 还可以加一些判断。required:true代表必传，unique 代表唯一的 cat_id: &#123; type:Number &#125;, cat_name: &#123; type: String, required: true &#125;&#125;)//绑定到模型const Category = mongoose.model(&#x27;category&#x27;, CateSchema, &#x27;category&#x27;) 4、接口的实现这里直接使用express router 不直接用app.get()或者app.post()这样去使用了。 新建一个js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344//引入expressconst express = require(&#x27;express&#x27;);//引入mongoose数据模型const &#123; Address &#125; = require(&#x27;../storedb&#x27;)//绑定routerlet router = express.Router();// 获取用户地址router.get(&#x27;/getAddress&#x27;, async (req, res) =&gt; &#123; const address = await Address.find(&#123; user_id: req.query.user_id &#125;) res.send(address)&#125;)// 删除地址router.delete(&#x27;/deleteAddress&#x27;, async (req, res) =&gt; &#123; const address = req.query const userId = req.query.user_id await Address.deleteOne(&#123; user_id: userId, add_id: address.add_id &#125;) res.send(&#123; message: &quot;删除地址成功！&quot; &#125;)&#125;)// 修改地址router.post(&#x27;/changeAddress&#x27;, async (req, res) =&gt; &#123; const address = req.body const addId = req.body.add_id await Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) res.send(&#123; message: &quot;修改地址成功！&quot; &#125;)&#125;)//导出module.exports = router 一般查询用get 增加修改用post 删除用delete 说一下mongoose的增删改查 增加 Address代表表名 里面是增加的一个地址， 123456Address.create(&#123; user_id: 1234, add_id: 123, user_name: &quot;zz&quot;, user_phone: 123456789, user_address: &quot;大道&quot; &#125;) 删除 删除user_id中add_id为123的那个地址 Address.deleteOne(&#123; user_id: 1234, add_id: 123 &#125;) 修改 修改第一个参数是修改哪一个，查找条件。add_id为多少的哪一个。 第二个参数为修改后的数据 12345Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) 查询 12345//查询所有的Address.find()//查询user_id为123的所有地址Address.find(&#123;user_id:123&#125;) mongoose的一些常用查询参数 1234567//skip查询的时候跳过多少个//limit限制一次查询几个//sort是排序 1是正序-1是倒序// skip(), limit(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 const goods = await Goods.find().limit(pageSize).skip((pageNum - 1) * pageSize).sort(&#123; goods_id: 1 &#125;) 12//$in 查询goods_id为$in后面的数组const aa = await Goods.find(&#123; goods_id: &#123; $in: [1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125;) 123456789//$or 满足其中一个条件就可以//$regex 匹配查询const data = await Goods.find(&#123; $or: [ &#123; goods_name: &#123; $regex: reg &#125; &#125;, &#123; goods_title: &#123; $regex: reg &#125; &#125;, &#123; goods_subtitle: &#123; $regex: reg &#125; &#125; ] &#125;) 123456789101112131415161718192021222324//aggregate聚合查询//$lookup 两个表关联查询//下面的意思是根据cat_id在goods表中查询，查询到的数据放到goods这个字段下。const index = req.params.categoryId - 1 await Category.aggregate([ &#123; $lookup: &#123; from: &quot;goods&quot;, localField: &quot;cat_id&quot;, foreignField: &quot;cat_id&quot;, as: &quot;goods&quot;, &#125; &#125;,&#123;$sort:&#123;&quot;cat_id&quot;:1&#125;&#125; ] , (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; res.send(data[index]) &#125; )&#125;) 5、上传文件12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require(&#x27;express&#x27;);var formidable = require(&#x27;formidable&#x27;);fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const &#123; Goods &#125; = require(&#x27;../storedb&#x27;)let router = express.Router();router.post(&#x27;/uploadImg&#x27;, (req, res, next) =&gt; &#123; const goods = req.query let form = new formidable.IncomingForm(); form.encoding = &#x27;utf-8&#x27;; // 编码 // 保留扩展名 form.keepExtensions = true; //文件存储路径 最后要注意加 &#x27;/&#x27; 否则会被存在public下 form.uploadDir = path.join(__dirname, &#x27;../public/imgs/accessory/&#x27;) form.parse(req, (err, fields, files) =&gt; &#123; if (err) throw err let oldFilename = files.file.name fs.rename(files.file.path, form.uploadDir + generateFilename(oldFilename), async err =&gt; &#123; if (err) &#123; console.log(&quot;重命名失败&quot;); &#125; else &#123; await Goods.updateOne(&#123; goods_id: goods.goods_id &#125;, &#123; goods_pic: `public/imgs/accessory/$&#123;generateFilename(oldFilename)&#125;`, &#125;) &#125; &#125;) res.send(&#123; message: &quot;保存成功！&quot; &#125;) &#125;) function generateFilename(oldFilename) &#123; //将老的文件名拼上时间戳，这样既不会命名冲突又可以看出文件的上传事件 let d = new Date(); let names = oldFilename.split(&quot;.&quot;); return `$&#123;names[0]&#125;_$&#123;&quot;&quot; + d.getFullYear() + (d.getMonth() + 1) + d.getDate() + &#x27;_&#x27; + d.getHours() + d.getMinutes() + d.getSeconds()&#125;.$&#123;names[1]&#125;`; &#125;&#125;); 6、启动在项目根目录打开终端运行node app.js 12345678//出现 success in port 3002，服务已经跑起来啦 //因为上面是这样写的// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 说明运行成功。 7、调用接口12345678910111213141516171819202122232425262728 // 获取用户地址 async getAddress () &#123; const userId = window.sessionStorage.getItem(&#x27;userId&#x27;) const res = await this.$http.get(&#x27;getAddress&#x27;, &#123; params: &#123; user_id: userId &#125; &#125;) this.address = res.data &#125;,//请求地址Request URL: http://localhost:3002/getAddress?user_id=1255Request Method: GETStatus Code: 200 OKRemote Address: [::1]:3002Referrer Policy: strict-origin-when-cross-origin//返回相应的数据[&#123; &quot;_id&quot;:&quot;602e26a4a8185949dc9ea23e&quot;, &quot;user_id&quot;:&quot;1255&quot;, &quot;add_id&quot;:&quot;157&quot;, &quot;user_name&quot;:&quot;wky&quot;, &quot;user_phone&quot;:&quot;18888888888&quot;, &quot;user_address&quot;:&quot;无锡市滨湖区太湖学院北区&quot;, &quot;__v&quot;:0&#125;] 到这里基本上就完成了大部分的功能。 当然还有登录注册。jwt签名生成token，密码的加密等等。 这个我也忘记的差不多了。 去整理一下，再记录下来。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"}]},{"title":"从数组中取出随机几个数组成新数组（不重复取）","slug":"2021-03-10-从数组中取出随机几个数组成新数组（不重复取）","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-10T09:14:23.203Z","comments":true,"path":"2021/03/10/2021-03-10-从数组中取出随机几个数组成新数组（不重复取）/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/10/2021-03-10-%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E5%87%BA%E9%9A%8F%E6%9C%BA%E5%87%A0%E4%B8%AA%E6%95%B0%E7%BB%84%E6%88%90%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%96%EF%BC%89/","excerpt":"","text":"​ 要给自己的商城，加一个推荐商品的功能。想让他随机从商品表中取出4个数据。 ​ 一开始我用Math.random()*arr.length但是会取出相同的。这样就不太对，哪有推荐两个相同的商品呢。 ​ 然后想到获取当前选择的下标，把选择的那个删除。下一次随机，就随机不到那个数了。 123456789101112131415161718192021//前台传来的当前商品的idconst nowGoodsIndex = req.query.goods_id-1 const goods = await Goods.find() let arr = [] //存入数组的id,因为id就是从1开始往上加。 goods.forEach((element, index) =&gt; &#123; arr.push(index+1) &#125;); //用splice把当前商品的id删除避免重复 arr.splice(nowGoodsIndex, 1); let newArr = [] //随机取出4个，取出来一个就把那个数在数组中删掉。避免重复。 for (let i = 0; i &lt;= 3; i++) &#123; let index = Math.floor(Math.random() * arr.length); newArr.push(arr[index]); //获取后，在数组中删除已经加入的随机数 arr.splice(index, 1); &#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"CSS margin折叠","slug":"2021-03-09-CSS-margin折叠","date":"2021-03-08T16:00:00.000Z","updated":"2021-03-09T09:49:37.080Z","comments":true,"path":"2021/03/09/2021-03-09-CSS-margin折叠/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/09/2021-03-09-CSS-margin%E6%8A%98%E5%8F%A0/","excerpt":"","text":"margin折叠今天在写页面的时候发现，子元素设置了margin-top:101px不生效，父元素却向下移动了。 这就是margin折叠 12345678910111213141516171819202122232425262728 //这里给子元素设置margin-top//父元素却向下移动了101px&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;car-message&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;style&gt; .main &#123; width: 1440px; height: 810px; background-image: url(~@/assets/bg.png); background-size: cover; box-sizing: border-box; padding: 0 19px 0 17px;&#125;.car-message &#123; margin-top: 101px; background-image: url(~@/assets/one.png); background-size: cover; width: 1404px; height: 51px; display: flex; align-items: center;&#125;&lt;/style&gt; 百度了下 外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。 解决办法兄弟间重叠时 底部元素变为行内盒子(display: inline-block); 底部元素的position的值为absolute/fixed 父元素与子元素重叠 父元素加入(overflow: hidden); 父元素添加透明边框(border:1px solid transparent); 子元素变为行内盒子(display: inline-block); 子元素加入浮动属性或定位 这里我给父元素设置了overflow:hidden就解决了。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"react 中使用Swiper轮播图插件","slug":"2021-03-08-react-中使用Swiper轮播图插件","date":"2021-03-07T16:00:00.000Z","updated":"2021-03-09T05:15:36.072Z","comments":true,"path":"2021/03/08/2021-03-08-react-中使用Swiper轮播图插件/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/08/2021-03-08-react-%E4%B8%AD%E4%BD%BF%E7%94%A8Swiper%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6/","excerpt":"","text":"第一步、安装1npm i swiper 第二步、使用12345678910111213141516171819import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/react&#x27;;//根据自己的需要引用样式import &#x27;swiper/swiper.less&#x27;;export default () =&gt; &#123; return ( &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;3&#125; onSlideChange=&#123;() =&gt; console.log(&#x27;slide change&#x27;)&#125; onSwiper=&#123;(swiper) =&gt; console.log(swiper)&#125; &gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;/Swiper&gt; );&#125;; 到这一个轮播图就已经实现了，但是只是轮播图没有别的东西，比如左右的按钮。这些需要我们手动添加。 第三步、添加功能（例：navigation按钮）1234567891011121314//引入所需功能和样式文件import SwiperCore, &#123; Navigation &#125; from &quot;swiper&quot;;import &quot;swiper/components/navigation/navigation.less&quot;;//使用SwiperCore.use([Navigation]);// 组件上添加属性 &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;1&#125; navigation style=&#123;&#123; padding: &quot;24px&quot; &#125;&#125; &gt; 以上就是在react中使用swiper插件。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"}]},{"title":"react hooks学习","slug":"2021-03-05-react hooks学习","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-23T07:16:48.075Z","comments":true,"path":"2021/03/05/2021-03-05-react hooks学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/05/2021-03-05-react%20hooks%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"react hooks学习01、什么是react hooksreact hooks就是react提供的内置函数，这些函数可以让，函数式组件和类组件一样拥有组件状态和副作用。 什么是状态？ React中的放数据的地方。 什么是副作用？ 在 React 组件中执行数据获取、订阅或者手动修改 DOM，我们统一把这些操作称为“副作用” 02、useStateuseState 就类似于类组件中的this.state useState的用法 12345678910111213141516171819202122import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0);return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getEementById(&#x27;root&#x27;)); 03、useEffectuseEffect就相当于生命周期的componentDidMount和componentDidUPdate 使用方法 12345678910111213141516171819202122232425262728293031import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0); // 相当于componentDidMount和componentDidUpdate //要加第二个参数空数组，不然会一直调用 useEffect(() =&gt; &#123; // 打印点击的次数 console.log( `You clicked $&#123;count/2&#125; times`) &#125;,[])return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#x27;root&#x27;));","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"扩展运算符(...)的复习","slug":"2021-03-04-扩展运算符(...)的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T01:39:59.558Z","comments":true,"path":"2021/03/04/2021-03-04-扩展运算符(...)的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6(...)%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"最近看项目代码，经常看到函数里运用扩展运算符。总是模模糊糊的，看明白又好像没有明白的感觉。 像下面这样 1234567891011121314151617181920212223 setCacheComponents([ ...cacheComponentsClone, &#123; ...currentPane, name: name || obj.item.props.children[1] // 如果调用addtab时传入了name则使用此name &#125; ]);//------------------------------------------------------------------------------------------ return &#123; ...state, tableData: [ ...state.tableData, &#123; params: &#123; ...payload.params, page: payload.page || 1, pageSize: payload.pageSize || 10 &#125;, tableKey: payload.tableKey, loading: true &#125; ] &#125; 就整理了一下扩展运算符的用法。 1234567891011121314151617181920212223242526272829// 浅拷贝const obj = &#123; name: &quot;张三&quot;, age: &quot;20&quot;, sex: &quot;男&quot;, hobby:&#123; play: &quot;ball&quot;, &#125;&#125;const newObj = &#123; ...obj&#125;console.log(newObj);//&#123; name: &#x27;张三&#x27;, age: &#x27;20&#x27;, sex: &#x27;男&#x27;, hobby: &#123; play: &#x27;ball&#x27; &#125; &#125;// 连接数组const arr = [1,2,3]const arr1 = [4,5,6]const newArr = [...arr,...arr1]console.log(newArr); //[ 1, 2, 3, 4, 5, 6 ]// 字符串转换成数组const str = &#x27;abcdefg&#x27; const newStr = [...str]console.log(newStr); //[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;g&#x27;]// 解构赋值 数组对象都可以const aa = [1,2,3]const bb = [...aa,4,5,6]console.log(bb); //[ 1, 2, 3, 4, 5, 6 ] 项目里常用的就是在函数里，用来解构赋值的比较多","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"javascript常用数组方法的复习","slug":"2021-03-04-javascript常用数组方法的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T04:00:22.334Z","comments":true,"path":"2021/03/04/2021-03-04-javascript常用数组方法的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-javascript%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"分析项目代码经常会看到一些数组方法，some,slice等等。概念都模糊不清，感觉知道又感觉不知道。还是要到W3C上去查一下用法。 所以这次把一些常用的数组方法整理一下，用来巩固复习 forEach()forEach() 对数组的每一项进行操作 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值undefined 1234567let arr = [1,2,3,4,5,6]let arr1 = []arr.forEach(item=&gt;&#123; arr1.push(item*2) &#125;)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ] filter()filter() 返回一个新数组，包含复合要求的所有元素 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：复合要求的新数组 123let arr = [1,2,3,4,5,6]let arr1 = arr.filter(item=&gt;item&gt;=3)console.log(arr1); //[ 3, 4, 5, 6 ] map()map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：原数组每个元素执行回调函数的结果组成的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.map(item=&gt;item*2)let arr2 = arr.map(item=&gt;item&gt;3)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ]console.log(arr2);//[ false, false, false, true, true, true ] slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 **begin 可选** 提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果省略 begin，则 slice 从索引 0 开始。 如果 begin 超出原数组的索引范围，则会返回空数组。 end 可选 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end） 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 被省略，则 slice 会一直提取到原数组末尾。 如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。 返回值：一个含有被提取元素的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.slice(2,4)let arr2 = arr.slice()console.log(arr1);//[ 3, 4 ]console.log(arr2);//[ 1, 2, 3, 4, 5, 6 ] find()find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [undefined] callback 函数接收3个值，item数组项，index元素下标，arr数组本身 数组中第一个满足所提供测试函数的元素的值，否则返回 [undefined] 123let arr = [1,2,3,4,5,6]let arr1 = arr.find(item=&gt;item&gt;4)console.log(arr1); //5 sort()sort()对数组的元素进行排序，并返回数组 如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 12345678910111213141516171819let arr = [5,4,3,2,1]let arr1 = arr.sort()console.log(arr1); //[ 1, 2, 3, 4, 5 ]let arr = [3,1,4,2,5,8,6,7]let arr3 = [3,1,4,2,5,8,6,7]let arr1 = arr.sort((a, b) =&gt; &#123; return a-b&#125;)console.log(arr1); //[ 1, 2, 3, 4, 5, 6, 7, 8 ]let arr2 = arr3.sort((a, b) =&gt; &#123; return b-a&#125;)console.log(arr2); //[ 8, 7, 6, 5, 4, 3, 2, 1 ] some()some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值： 数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false。 123456let arr = [1, 2, 3, 4, 5, 6]const aa = arr.some(item =&gt; item &gt; 5)const bb = arr.some(item =&gt; item &gt; 7)console.log(aa);//trueconsole.log(bb); //false every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：如果回调函数的每一次返回都为true，返回 true ，否则返回 false。 123456let arr = [2, 5, 6, 7, 8, 9]const aa = arr.every(item =&gt; item &gt; 3)const bb = arr.every(item =&gt; item &gt; 1)console.log(aa); //fasleconsole.log(bb); //true 差不多就是这些常用的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"一些小记录","slug":"2021-03-03-小记","date":"2021-03-02T16:00:00.000Z","updated":"2021-03-03T08:17:17.395Z","comments":true,"path":"2021/03/03/2021-03-03-小记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/03/2021-03-03-%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"开发中写样式less中，最外层取一个不易重的类名，其余子元素类名写在里面 尽量不要写到margin负值 样式遵循设计图 图片名称起相关英文名 flex布局多使用space-around做分割，除非必须用space-between 类名过长用xx-xx这样写 页面起名大驼峰比如ChargeManage","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"}]},{"title":"React项目(UmiJS)中使用高德地图","slug":"2021-03-02-React项目(UmiJS)中使用高德地图","date":"2021-03-01T16:00:00.000Z","updated":"2021-03-02T01:21:36.707Z","comments":true,"path":"2021/03/02/2021-03-02-React项目(UmiJS)中使用高德地图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/02/2021-03-02-React%E9%A1%B9%E7%9B%AE(UmiJS)%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"React AMap这是一个基于 React 封装的高德地图组件. 文档地址 https://uiw.gitee.io/react-amap/#/ 01、安装npm install @uiw/react-amap --save 02、使用在文档左侧找到需要使用的例子。在右侧直接复制对应代码。按需进行修改。 03、例子（贝塞尔曲线的使用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; useState &#125; from &quot;react&quot;;import &#123; Map, APILoader, BezierCurve &#125; from &quot;@uiw/react-amap&quot;;const CarLine = () =&gt; &#123; const [show] = useState(true); const path = [// 每个弧线段有两种描述方式 [116.39, 39.91, 116.37, 39.91],// 起点 // 第一段弧线 [116.380298, 39.907771, 116.38, 39.90],// 控制点，途经点 // 第二段弧线 [116.385298, 39.907771, 116.40, 39.90],// 控制点，途经点// 弧线段有两种描述方式1 // 第三段弧线 [// 弧线段有两种描述方式2 [116.392872, 39.887391],// 控制点 [116.40772, 39.909252],// 控制点 [116.41, 39.89]// 途经点 ], // 第四段弧线 [116.423857, 39.889498, 116.422312, 39.899639, 116.425273, 39.902273] // 控制点，控制点，途经点，每段最多两个控制点 ]; const handleParams = (values) =&gt; &#123; return values &#125; return ( &lt;&gt; &lt;APILoader akay=&quot;a7a90e05a37d3f6bf76d4a9032fc9129&quot;&gt; &lt;div style=&#123;&#123; width: &quot;100%&quot;, height: &quot;600px&quot; &#125;&#125; &gt; &lt;Map zoom=&#123;14&#125; center=&#123;[116.397637, 39.900001]&#125;&gt; &lt;BezierCurve visiable=&#123;show&#125; path=&#123;path&#125; isOutline=&#123;true&#125; outlineColor=&quot;&quot; borderWeight=&#123;3&#125; strokeColor=&quot;red&quot; strokeOpacity=&#123;1&#125; strokeWeight=&#123;6&#125; // 线样式还支持 &#x27;dashed&#x27; strokeStyle=&quot;solid&quot; // strokeStyle是dashed时有效 strokeDasharray=&#123;[10, 10]&#125; lineJoin=&quot;round&quot; lineCap=&quot;round&quot; zIndex=&#123;50&#125; /&gt; &lt;/Map&gt; &lt;/div&gt; &lt;/APILoader&gt; &lt;/&gt; );&#125;export default CarLine","categories":[],"tags":[{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"}]},{"title":"Vue3.0初探","slug":"2021-02-26-vue3笔记","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-16T02:54:39.632Z","comments":true,"path":"2021/02/26/2021-02-26-vue3笔记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/2021-02-26-vue3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"✨ 官网地址官网文档：https://v3.cn.vuejs.org/ 一、vue3安装与项目创建【掌握】参考地址：https://www.vue3js.cn/docs/zh/guide/installation.html 准备工作：升级脚手架对于 Vue 3，你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli@next。要升级，你应该需要全局重新安装最新版本的 @vue/cli： 123yarn global add @vue/cli@next# ORnpm install -g @vue/cli@next 然后在 Vue 项目运行： 1vue upgrade --next 方式1：以原有vueCli脚手架创建创建项目： 1vue create demo 直接选择 Vue 3 Preview ，并回车，不考虑eslint问题。 然后执行： 123456# 进入目录cd demo# 用vscode打开当前目录code .# 运行项目yarn serve 方式2：vite创建12345678910111213npm init vite-app demo# 相当于npx create-vite-app demo# 安装后执行npm install# oryarn# 运行项目npm run dev# oryarn dev 创建项目并运行，会发现我们 npm run dev 后是秒开项目的，运行速度极快。 二、Composition API（组合式API）【掌握】 相当于 React Hooks 我们先使用以前vue2的方式实现一个累加： 12345678910111213141516171819&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; btnClick()&#123; this.count++; &#125; &#125;&#125;&lt;&#x2F;script&gt; 这套代码可以实现一个累加的效果，但如果以后我们想把这个组件中的 count 字段与 btnClick 单独拎出来管理，那就比较麻烦了，因为 count 和 btnClick 不在同一个方法内，很难抽离。 1、setupsetup有以下特性： 1、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的 2、setup函数是 Composition API（组合API）的入口 3、在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用 4、由于我们不能在 setup函数中使用 data 和 methods，所以Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined 5、setup函数只能是同步的不能是异步的 2、API - ref我们先来体验一下vue3怎么处理这个累加效果： 123456789101112131415161718192021&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;vue&#39;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, setup()&#123; const count &#x3D; ref(1); &#x2F;&#x2F; 此时我们使用ref指定count的默认值为1，因此上面data中的count会失效 let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#x2F;&#x2F; 修改ref中的值要用xxx.value &#125; return &#123;count, btnClick&#125; &#125;&#125; 此时如果我想单独管理这个累加效果，我就可以这么操作： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;btnClick&quot;&gt;累加&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; data()&#123; return &#123; // count: 0 // 一旦把setup中的代码抽离，return中对应的值要去掉，否则ref无效 &#125; &#125;, setup()&#123; // 函数调用后就会返回一个对象，因此我们直接return return clickCountFn() // 如果后期还想同时返回其他数据，可以将clickCountFn()的返回结果展开 // return &#123;...clickCountFn(), 其他数据&#125; &#125;&#125;// 封装一个函数，这样这块功能我们就能单独管理了function clickCountFn()&#123; const count = ref(1); let btnClick = () =&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;/script&gt; 3、API - reactive再来了解另一个API ： reactive函数和ref作用非常接近，但是它的参数是一个对象，我们可以在对象中定义其方法，而通过这个形式，就不需要再对其进行进行 .value 调用了。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;p&gt;姓名：&#123;&#123;obj.username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref, reactive&#125; from &#39;vue&#39;export default &#123; setup()&#123; &#x2F;&#x2F; 使用reactive let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; return &#123;...clickCountFn(), obj, btnClick1&#125; &#125;&#125;function clickCountFn()&#123; const count &#x3D; ref(1); let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;&#x2F;script&gt; 使用 reactive 生成的对象与 ref 生成的值都是响应式的。 这里可以看到我们在 html 中调用数据时，使用的是 obj.username ，那我们是否可以直接写 username 呢？答案是可以的，但这里需要注意： 由于reactive返回的对象本质上已经是一个Proxy对象，所以通过…扩展符号展开的属性，是无法进行响应式的 也就是说，如果这么写： 1return &#123;...clickCountFn(), ...obj, btnClick1&#125; 那么是无法实现的。 4、API - toRefs正确的写法应该是： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;!-- 无需obj.username，直接username即可 --&gt; &lt;p&gt;姓名：&#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 新增toRefs方法import &#123;ref, reactive, toRefs&#125; from &#39;vue&#39;export default &#123; setup()&#123; let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; &#x2F;&#x2F; 通过toRefs方法 let refObj &#x3D; toRefs(obj); &#x2F;&#x2F; 通过...refObj将数据扩展 return &#123;...clickCountFn(), ...refObj, btnClick1&#125; &#125;&#125;&#x2F;&#x2F; 其他代码...&lt;&#x2F;script&gt; 三、Provide与Inject（提供/注入）【掌握】1、Vue2写法以往我们的父传子是通过props传的： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child :num&#x3D;&quot;num&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; data()&#123; return &#123; num: 123 &#125; &#125;, components: &#123; Child &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 这个时候限制死了数据必须来自父组件，我们其实还有 Provide 和 Inject ： 123456789101112131415161718192021222324252627&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, provide: &#123; num: 456 &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; Provide/Inject 相比于 props 的好处在于： 如果组件嵌套较多，那么 props 需要一级一级往下传递，后期很难维护。Provide+Inject 相当于是跨级组件传值，比如孙子组件也想用上面这个 num 的值，就不用一级一级往下传，直接在孙子组件使用即可： 1234567891011&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;num&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; &#x2F;&#x2F; 将Sun组件在Child组件中引入，即可实现跨级组件传值 inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 2、Vue3写法vue3中的 provide/inject。两者都只能在当前活动实例的 setup() 期间调用。 格式为： 123456789101112131415161718// provideimport &#123;provide&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup() &#123; // 此处name必须是String类型，value则不限制 provide(name, value) &#125;&#125;// injectimport &#123;inject&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup()&#123; // name即为传过来的字段，第二个参数可选，可填写默认值 const val = inject(name, defaultValue); return &#123;val&#125; &#125;&#125; 我们修改以上案例的代码： 1234567891011121314151617181920212223242526272829303132&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; provide(&#39;num&#39;, 789) &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;mynum&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;inject&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入export default &#123; setup()&#123; const mynum &#x3D; inject(&#39;num&#39;); return &#123;mynum&#125; &#125;&#125;&lt;&#x2F;script&gt; 3、响应性所谓的 Provide/Inject 响应性，其实就是把传递的值结合上文提及的 ref 或 reactive 一起使用： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt; &lt;button @click&#x3D;&quot;changeNumFn&quot;&gt;修改num&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide, ref&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; &#x2F;&#x2F; 使用ref来定义num的值 const num &#x3D; ref(123); &#x2F;&#x2F; 声明一个函数，专门用于修改num let changeNumFn &#x3D; () &#x3D;&gt; &#123; num.value &#x3D; 456; &#125; provide(&#39;num&#39;, num) &#x2F;&#x2F; 返回这个函数 return &#123;changeNumFn&#125; &#125;&#125;&lt;&#x2F;script&gt; 此时，当你点击按钮时，孙子组件接收到的 num 就会被修改了。 四、Teleport（传送门）【掌握】在vue2中，想要将子节点渲染到存在于父组件以外的 DOM 节点时，需要通过第三方库 portal-vue 去实现。而vue3中，Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术。 官方文档：《teleport》 举个最简单的例子： 我们在 index.html 中 #app 同级的地方新增一个 #test 元素： 12&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; 由于vue的 main.js 中规定了打包出来的代码都放入 #app 中： 1createApp(App).mount(&#x27;#app&#x27;) 因此，你现在没有办法将代码放入 #test 中。此时，我们可以使用传送门： App.vue 中： 12345678910111213&lt;template&gt; &lt;Home &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;export default &#123; name: &#39;App&#39;, components: &#123; Home &#125;&#125;&lt;&#x2F;script&gt; Home.vue 中： 123456789&lt;template&gt; &lt;p&gt;这段话是渲染在#app中的&lt;&#x2F;p&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--1&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--2&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt;&lt;&#x2F;template&gt; 此时，你打开浏览器控制台，就可以看到第2、3个p标签已经被渲染到 #test 中。 备注： 1、标签身上都to属性，填写的是css选择器。 2、多个传送门书写时，会按照自上而下的顺序传送至另一个DOM元素。 五、Suspense（等待）【掌握】Suspense组件用于在等待某个异步组件解析时显示后备内容。 那我们什么时候需要使用异步组件呢？多了去了，比如： 在页面加载之前显示加载动画 显示占位符内容 处理延迟加载的图像 那么，让我们看看 Suspense 怎么使用，我们先来提一个需求： 在等待组件获取数据并解析时显示“玩命加载中…”之类的内容 OK，我们来写一个 Article.vue 组件： 12345678910111213141516171819&lt;template&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;export default&#123; async setup() &#123; let content &#x3D; ref(&#39;内容&#39;) content.value &#x3D; await new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 3秒后修改content resolve(&quot;你好世界&quot;); &#125;, 3000); &#125;) return &#123;content&#125; &#125;,&#125;&lt;&#x2F;script&gt; 用个 Home.vue 组件来调用它： 12345678910111213141516171819&lt;template &lt;Suspense&gt; &lt;template #default&gt; &lt;Article&gt;&lt;&#x2F;Article&gt; &lt;&#x2F;template&gt; &lt;template #fallback&gt; &lt;p&gt;玩命加载中...&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Suspense&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Article from &#39;.&#x2F;Article.vue&#39;export default &#123; components:&#123; Article &#125;&#125;&lt;&#x2F;script&gt; 可以看出，&lt;Suspense&gt; 中，包含了两个template标签，#default 定义了我们要写入的内容， #fallback 定义了我们要预显示的内容。 ⚠️ 注意： 作为template中的内容（即插槽），必须要有根元素。 六、Fragment（碎片）【了解】vue2中，如果你创建一个Vue组件，那么它只能有一个根节点。这意味着不能创建这样的组件： 1234&lt;template&gt; &lt;div&gt;你好&lt;&#x2F;div&gt; &lt;div&gt;世界&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 原因是代表任何Vue组件的Vue实例需要绑定到一个单一的DOM元素中。唯一可以创建一个具有多个DOM节点的组件的方法就是创建一个没有底层Vue实例的功能组件。 这情况同样存在于react，但react可以使用空标签 &lt;&gt;&lt;/&gt; 来包裹，或者是使用一个名为Fragment的虚拟元素： 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;你好&lt;/td&gt; &lt;td&gt;世界&lt;/td&gt; &lt;/React.Fragment&gt; ) &#125;&#125; 尽管Fragment看起来像一个普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。目前你可以在Vue 2中使用vue-fragments库来使用Fragments，而在Vue 3中，你直接使用就行了，无需引入任何库。 七、TreeShaking（消除未使用代码）【了解】TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。 文档参考：https://vue3js.cn/docs/zh/guide/migration/global-api-treeshaking.html#_2-x-%E8%AF%AD%E6%B3%95 举个例子： vue2中我们常使用 Vue.nextTick(()=&gt;&#123;&#125;) 来预操作DOM，但有时候我们不用这个 nextTick ，比如改用别的方式来代替（如setTimeout），那么项目打包时，vue 全局的 nextTick 就成为一个多余的代码，从而使你的项目打包体积变大。 在vue3中，官方团队重构了所有全局 API 的组织方式，让所有的 API 都支持了 TreeShaking。所以vue3中如果还想使用全局的 nextTick ，就需要引入： 12345import &#123; nextTick &#125; from &#x27;vue&#x27;; nextTick(() =&gt; &#123; // 和 DOM 有关的一些操作&#125;); 如果你在 Vue 3 中不引入而直接调用 Vue.nextTick() ，就会得到一个报错：undefined is not a function。 官方也给出了Vue 2.x 中的受此更改影响的全局 API： Vue.nextTick Vue.observable (用 Vue.reactive 替换) Vue.version Vue.compile (仅全构建) Vue.set (仅兼容构建) Vue.delete (仅兼容构建) 八、Performance（性能）【了解】vue3.0相对于vue2.0来说性能快1.2到1.5倍，主要原因如下： 1、diff方法优化 \u001dVue2 中的虚拟dom是进行全量的对比 Vue3 新增了静态标记（PatchFlag），只比对带有 PF 的节点，并且通过 Flag 的信息得知 当前节点要比对的具体内容。 2、静态提升 Vue2中无论元素是否参与更新, 每次都会重新创建, 然后再渲染 Vue3中对于不参与更新的元素, 会做静态提升, 只会被创建一次, 在渲染时直接复用即可 3、cacheHandlers 事件侦听器缓存 默认情况下onClick会被视为动态绑定, 所以每次都会去追踪它的变化 但是因为是同一个函数，所以没有追踪变化, 直接缓存起来复用即可 4、ssr渲染 当有大量静态的内容时候，这些内容会被当做纯字符串推进一个buffer里面， 即使存在动态的绑定，会通过模板插值嵌入进去。这样会比通过虚拟dmo来渲染的快上很多很多。 当静态内容大到一定量级时候，会用_createStaticVNode方法在客户端去生成一个static node， 这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。 九、Setup的生命周期【了解】组合式API需要在setup中使用，setup中含有的生命钩子与vue的大体一致： 具体参考：《setup生命周期钩子》 十、TypeScript支持【了解】vue3新增了对TS语法的支持。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"对Ant-Design Table组件进行封装","slug":"2021-02-26-对Ant-Design-Table组件进行封装","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-09T05:15:22.392Z","comments":true,"path":"2021/02/26/2021-02-26-对Ant-Design-Table组件进行封装/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/2021-02-26-%E5%AF%B9Ant-Design-Table%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85/","excerpt":"","text":"Table组件封装页面, dataSource通过Modal中的获取的数据传过来，主要对columns进行封装。把一些常用的属性给暴露出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import &#123; connect &#125; from &quot;umi&quot;;import &#123; Spin, Table, Space, Popconfirm, Tooltip &#125; from &quot;antd&quot;;import CommonPagination from &quot;@/components/CommonPagination&quot;;import moment from &quot;moment&quot;;import &#123; formatNum &#125; from &quot;@/utils/utils&quot;const SearchForm = (&#123; tableConfig, tableData &#125;) =&gt; &#123; const tableItem = tableData.find((item) =&gt; item.tableKey === tableConfig.tableKey) || &#123;&#125;; const &#123; loading &#125; = tableItem; // 根据tablekey取到对应请求的loading状态 const dataSource = tableItem.data || []; const columns = tableConfig.columns.map(item =&gt; &#123; if (item.actionMap) &#123; item = &#123; ...item, render(res) &#123; // 生成action列表 const actionList = (item.actionMap || []).map((action, index) =&gt; &#123; switch (action.type) &#123; case &quot;href&quot;: if (action.render) &#123; return &lt;div key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.render(res)&#125;&lt;/div&gt; &#125; return &lt;a key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.text&#125;&lt;/a&gt; case &quot;confirm&quot;: return &lt;Popconfirm key=&#123;index&#125; title=&#123;&lt;div&gt;确认要执行&#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125;操作吗？&lt;/div&gt;&#125; onConfirm=&#123;() =&gt; &#123; if (action.onConfirm) &#123; action.onConfirm(res) &#125; &#125;&#125; onCancel=&#123;() =&gt; &#123; if (action.onCancel) &#123; action.onCancel(res) &#125; &#125;&#125; okText=&quot;确认&quot; cancelText=&quot;取消&quot; &gt; &#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125; &lt;/Popconfirm&gt; default: return &lt;span key=&#123;index&#125;&gt;未知类型，请检查&lt;/span&gt; &#125; &#125;); return &lt;Space size=&quot;middle&quot;&gt; &#123; actionList.map(action =&gt; action) &#125; &lt;/Space&gt; &#125; &#125; &#125; else if (item.numFormat) &#123; item = &#123; ...item, render(res) &#123; return formatNum(res, ...item.numFormat); &#125; &#125; &#125; else if (item.timeFormat) &#123; item = &#123; ...item, render(res) &#123; return res ? moment(res).format(item.timeFormat) : &quot;--&quot; &#125; &#125; &#125; else if (item.tipCol) &#123; const render = item.render; item = &#123; ...item, ellipsis: &#123; show: false &#125;, render(res) &#123; if (item.tipCol === false) &#123; return res &#125; if (item.tipCol === true) &#123; return ( &lt;Tooltip placement=&quot;topLeft&quot; title=&#123;render ? render(res) : res&#125;&gt; &lt;span&gt;&#123;render ? render(res) : res&#125;&lt;/span&gt; &lt;/Tooltip&gt; ) &#125; &#125; &#125; &#125; return item; &#125;) return ( &lt;Spin spinning=&#123;loading === true&#125;&gt; &lt;div style=&#123;&#123; marginTop: 24, padding: 24, background: &quot;#fff&quot; &#125;&#125;&gt; &lt;Table pagination=&#123;false&#125; columns=&#123;columns&#125; dataSource=&#123;dataSource || []&#125; scroll=&#123;&#123; x: &quot;max-content&quot; &#125;&#125; bordered /&gt; &lt;CommonPagination tableKey=&#123;tableConfig.tableKey&#125; /&gt; &lt;/div&gt; &lt;/Spin&gt; );&#125;;export default connect((&#123; global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(SearchForm); 分页封装页面 根据modal传过来的数据进行前台分页。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; connect &#125; from &quot;umi&quot;;import &#123; Pagination &#125; from &quot;antd&quot;;const styles = &#123; display: &quot;flex&quot;, justifyContent: &quot;flex-end&quot;, alignItems: &quot;center&quot;, backgroundColor: &quot;#fff&quot;, height: &quot;60px&quot;&#125;const CommonPagination = (props) =&gt; &#123; const &#123; dispatch, tableData, tableKey &#125; = props; const &#123; page: pageData, params &#125; = tableData.find(item =&gt; item.tableKey === tableKey) || &#123;&#125;; // 分页变化 const pageChange = (page) =&gt; &#123; dispatch(&#123; type: &quot;global/getTableData&quot;, payload: &#123; tableKey, params: &#123; page, &#125; &#125;, &#125;); &#125;; return ( &lt;div style=&#123;styles&#125;&gt; &#123;pageData &amp;&amp; ( &lt;Pagination total=&#123;pageData.total&#125; showTotal=&#123;() =&gt; `共计 $&#123;pageData.total&#125; 个`&#125; defaultCurrent=&#123;1&#125; showSizeChanger=&#123;false&#125; onChange=&#123;pageChange&#125; current=&#123;params.page&#125; /&gt; )&#125; &lt;/div&gt; );&#125;;export default connect((&#123;global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(CommonPagination); 使用 ### CommonTable（通用表格） 必传参数tableConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495tableConfig=&#123; tableKey:&#x27;tableKey&#x27;, // 必传 columns:[ // 必传 &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;, &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;, &#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ], &#125; ], config:&#123;&#125; // table的配置，与官方文档一致&#125;&lt;CommonTable tableConfig=&#123;tableConfig&#125; /&gt; 其中columns与官方文档配置一致，当有如下参数时会进行特殊处理： tipCol (文字过长省略,Tooltip上方提示) 12345678910111213141516171819columns: [ &#123; title: &quot;Address&quot;, dataIndex: &quot;address&quot;, width: 150, key: &quot;address&quot;, tipCol: true, &#125;,] true时开启false关闭 numFormat（时间格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;] numFormat[保留几位小数，是否进行千分位格式化]，numFormat[2,true]效果1234.567=&gt;1,234.57 timeFormat（日期格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;,] timeFormat:时间戳格式，格式化为指定格式 actionMap（操作栏） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ],&#125; actionMap的type用于决定操作类型，具体如下： href，text和render至少有一个，render优先级高于text。当只有text参数时，生成结果为&lt;a&gt;&#123;text&#125;&lt;/a&gt;。当有render时，生成结果为render的返回值。 confirm，用于操作前的确认。render与text的关系与href一致。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"}]},{"title":"davJs学习02","slug":"2021-02-24-umi中，davjs学习02","date":"2021-02-23T16:00:00.000Z","updated":"2021-02-24T07:30:24.443Z","comments":true,"path":"2021/02/24/2021-02-24-umi中，davjs学习02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/24/2021-02-24-umi%E4%B8%AD%EF%BC%8Cdavjs%E5%AD%A6%E4%B9%A002/","excerpt":"","text":"最近公司新项目用的UmiJs3.x，整个项目的数据，通过内置的Davjs来控制。 昨天自己分析了一下Davjs。但是脑海中的概念还是很模糊。今天再梳理一下。 第一步首先是在Models文件夹下创建一个JS文件 123456789101112131415161718192021222324252627282930313233const GlobalModel = &#123; //model的名称 namespace: &quot;global&quot;, state: &#123; //放数据的地方 user:&#123;&#125; &#125;, effects: &#123; // 异步获取数据，不能直接修改数据，需要通过put调用reducers的方法。 `其中call和普通是dva 提供的effect 函数内部的处理函数 call：执行异步函数， put：发出一个 Action，类似于 dispatch select获取数据，` *getTableData(&#123; payload &#125;, &#123; put, select, call &#125;) &#123; const tableList = yield select((state) =&gt; state.global.tableData); yield put(&#123; type: &quot;setTableParams&quot;, payload, &#125;); &#125;, reducers: &#123; //同步获取数据 setTableParams(state) &#123; return &#123; ...state &#125; &#125; &#125;,&#125;;export default GlobalModel; 第二步对应页面中 12345678910111213141516171819202122232425262728import React from &quot;react&quot;;import &#123; connect &#125; from &quot;umi&quot;;const TableDemo = (props) =&gt; &#123; //能直接获取到users const &#123;dispatch, users&#125; = props dispatch(&#123; //global这个model中，getTableData这个异步操作函数 type: &quot;global/getTableData&quot;, payload: &#123; &#125;, &#125;); return ( &lt;div&gt; &#123;users.name&#125; &lt;/div&gt; )&#125;//把global中state中的数据绑定到页面的props上export default connect((&#123; global &#125;) =&gt; (&#123; users: global.users&#125;))(TableDemo); 还可以调用Service文件夹里的接口，获取数据","categories":[],"tags":[{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"}]},{"title":"Dav结构的分析","slug":"2021-02-23-davjs学习","date":"2021-02-23T10:34:00.000Z","updated":"2021-03-06T01:55:47.053Z","comments":true,"path":"2021/02/23/2021-02-23-davjs学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/23/2021-02-23-davjs%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"下面是davjs models的一个基本结构 1234567891011121314151617181920212223242526272829303132333435export default &#123; //dav model的名字namespace: &#x27;example&#x27;,//数据state: &#123;num:1&#125;, //表示当前的example中的state状态，这里可以给初始值，这里num初始为1 //这里是做异步处理的相当于VueX的actioneffects: &#123; //payload是参数 put触发action ，select获取数据， call异步操作 *addByONe(&#123; payload&#125;, &#123; call, put,select &#125;) &#123; //这里使用selectconst num = yield select(state =&gt; state.num) //这里就获取到了当前state中的数据numlet param1; param1 = num + payload; 这里就可以使用num进行操作了yield put(&#123;type: &#x27;save&#x27;,num:param1&#125;);&#125;&#125;, //用来保存更新state值 上面的put方法调用这里的方法,reducers: &#123;save(state, action) &#123; //这里的state是当前总的state，这里的action包含了上面传递的参数和type return &#123; ...state, ...action.num &#125;; //这里用ES6语法来更新当前state中num的值&#125;&#125;, &#125;;","categories":[],"tags":[{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"关于我","slug":"2021-02-12-关于我","date":"2021-02-11T16:00:00.000Z","updated":"2021-04-12T08:26:57.639Z","comments":true,"path":"2021/02/12/2021-02-12-关于我/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/12/2021-02-12-%E5%85%B3%E4%BA%8E%E6%88%91/","excerpt":"","text":"一个正在慢慢成长的前端程序员。","categories":[],"tags":[{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]},{"title":"新年快乐","slug":"2021-02-11-新年快乐","date":"2021-02-10T16:00:00.000Z","updated":"2021-02-23T05:25:35.342Z","comments":true,"path":"2021/02/11/2021-02-11-新年快乐/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/11/2021-02-11-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/","excerpt":"","text":"大家新年快乐","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"nest","slug":"nest","permalink":"https://gitee.com/shimmer612/myBlog/tags/nest/"},{"name":"react-native","slug":"react-native","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-native/"},{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"},{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"Rollup","slug":"Rollup","permalink":"https://gitee.com/shimmer612/myBlog/tags/Rollup/"},{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"},{"name":"echarts","slug":"echarts","permalink":"https://gitee.com/shimmer612/myBlog/tags/echarts/"},{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"},{"name":"js","slug":"js","permalink":"https://gitee.com/shimmer612/myBlog/tags/js/"},{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"},{"name":"git","slug":"git","permalink":"https://gitee.com/shimmer612/myBlog/tags/git/"},{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"},{"name":"pinia","slug":"pinia","permalink":"https://gitee.com/shimmer612/myBlog/tags/pinia/"},{"name":"正则","slug":"正则","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%AD%A3%E5%88%99/"},{"name":"antd","slug":"antd","permalink":"https://gitee.com/shimmer612/myBlog/tags/antd/"},{"name":"观后感","slug":"观后感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"},{"name":"随感","slug":"随感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E6%84%9F/"},{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"-javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%8E%92%E5%BA%8F/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"webSocket","slug":"webSocket","permalink":"https://gitee.com/shimmer612/myBlog/tags/webSocket/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"},{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"},{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"},{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"},{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"},{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]}