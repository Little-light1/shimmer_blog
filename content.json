{"meta":{"title":"Shimmer","subtitle":"黑暗中寻光的人","description":"","author":"Shimmer","url":"https://gitee.com/shimmer612/myBlog","root":"/myBlog/"},"pages":[{"title":"相册","date":"2022-01-01T14:51:23.123Z","updated":"2022-01-01T14:51:23.123Z","comments":true,"path":"photos/index.html","permalink":"https://gitee.com/shimmer612/myBlog/photos/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-03-17T01:52:41.653Z","updated":"2021-03-17T01:52:41.653Z","comments":true,"path":"message/index.html","permalink":"https://gitee.com/shimmer612/myBlog/message/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-23T09:07:02.000Z","updated":"2021-02-23T09:08:25.950Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/shimmer612/myBlog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pinia新的状态管理工具","slug":"pinia的使用","date":"2022-03-24T16:00:00.000Z","updated":"2022-03-25T10:48:57.114Z","comments":true,"path":"2022/03/25/pinia的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/03/25/pinia%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"pinia新的状态管理工具1、安装npm install pinia --save 2、新建store,在main.js中引入在根目录下新建store文件夹，新建index.js 1234import &#123; createPinia &#125; from &quot;pinia&quot;;// 创建storeconst store = createPinia();export default store; main.js 12345678910import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store&quot;;const app = createApp(App);app.use(store);app.mount(&quot;#app&quot;); 3、在store文件夹下新建stateStore.js123456789101112131415161718192021222324252627282930313233343536import &#123; defineStore &#125; from &quot;pinia&quot;;export const stateStore = defineStore(&#123; id: &quot;state&quot;, //命名 state: () =&gt; &#123; return &#123; name: &quot;菠萝&quot;, age: 99, &#125;; &#125;, //类似于计算属性 getters: &#123; getterName(state) &#123; console.log(&quot;使用了getter&quot;); return &quot;我是什么水果？我是&quot; + state.name; &#125;, &#125;, actions: &#123; //还支持调用别的actions updateName(name, age) &#123; this.name = name; this.updateAge(age); &#125;, updateAge(age) &#123; this.age = age; &#125;, //action 可以像写一个简单的函数一样支持 async/await的语法 async asyncfun() &#123; const timer = setTimeout(() =&gt; &#123; this.name = &quot;桃子&quot;; &#125;, 1000); await timer; &#125;, &#125;,&#125;); 4、使用先引入创建的store 解构需要引入storeToRefs 修改state数据可以直接修改，也可以使用$patch,也可以使用actions修改 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;h1&gt;pinia:&#123;&#123; name &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;pinia:&#123;&#123; age &#125;&#125;&lt;&#x2F;h1&gt; &lt;h1&gt;pinia.getter:&#123;&#123; state.getterName &#125;&#125;&lt;&#x2F;h1&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;changeName&quot;&gt;修改pinia&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script setup&gt;import &#123; reactive, inject &#125; from &quot;vue&quot;;import &#123; stateStore &#125; from &quot;..&#x2F;store&#x2F;state&quot;;&#x2F;&#x2F;解构storeimport &#123; storeToRefs &#125; from &quot;pinia&quot;;const state &#x3D; stateStore();const &#123; age, name &#125; &#x3D; storeToRefs(state);const changeName &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 通过patch修改数据两种方式对象和函数 &#x2F;&#x2F; 1、对象 &#x2F;&#x2F; state.$patch(&#123; &#x2F;&#x2F; name: &quot;西瓜&quot;, &#x2F;&#x2F; age: 100, &#x2F;&#x2F; &#125;); &#x2F;&#x2F; 2、函数 &#x2F;&#x2F; state.$patch((state) &#x3D;&gt; &#123; &#x2F;&#x2F; state.name &#x3D; &quot;哈密瓜&quot;; &#x2F;&#x2F; state.age &#x3D; 999; &#x2F;&#x2F; &#125;); &#x2F;&#x2F; 通过action修改数据 state.updateName(&quot;香蕉&quot;, 88); state.asyncfun();&#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;&lt;&#x2F;style&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"},{"name":"pinia","slug":"pinia","permalink":"https://gitee.com/shimmer612/myBlog/tags/pinia/"}]},{"title":"react-hooks中useContext的使用","slug":"useContext","date":"2022-02-21T16:00:00.000Z","updated":"2022-03-24T08:54:37.871Z","comments":true,"path":"2022/02/22/useContext/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/02/22/useContext/","excerpt":"","text":"react-hooks中useContext的使用1、作用useContext可以多层嵌套传输数据和方法 2、使用1、新建一个store.js文件，使用React.createContext()创建一个自己的Context 12345import React from &quot;react&quot;;const myContext &#x3D; React.createContext(null);export &#123; myContext &#125;; 2、最外层组件 使用myContext.Provider包裹然后value传入自己需要的值 1234567891011121314import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useState &#125; from &quot;react&quot;;import Child from &quot;.&#x2F;child&quot;;const App &#x3D; () &#x3D;&gt; &#123; const [num, setNum] &#x3D; useState(0); return ( &lt;myContext.Provider value&#x3D;&#123;&#123; setNum, num &#125;&#125;&gt; &lt;Child&gt;&lt;&#x2F;Child&gt; &lt;&#x2F;myContext.Provider&gt; );&#125;;export default App; 3、子组件 引入myContext并通过useContext获取到传入的值 1234567891011121314151617181920212223import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useContext&#125; from &quot;react&quot;;import GrandSon from &quot;.&#x2F;grandSon&quot;;const Child &#x3D; (props) &#x3D;&gt; &#123; const &#123; setNum, num &#125; &#x3D; useContext(myContext); return ( &lt;&gt; &lt;h1&gt;&#123;num&#125;&lt;&#x2F;h1&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setNum((prev) &#x3D;&gt; prev + 1); &#125;&#125; &gt; 添加 &lt;&#x2F;button&gt; &lt;GrandSon num&#x3D;&#123;num&#125; &#x2F;&gt; &lt;&#x2F;&gt; );&#125;;export default Child; 3、孙组件 和子组件中一样 12345678910111213141516171819202122import &#123; myContext &#125; from &quot;.&#x2F;store&quot;;import React, &#123; useContext &#125; from &quot;react&quot;;const GrandSon &#x3D; (props) &#x3D;&gt; &#123; const &#123; setNum, num &#125; &#x3D; useContext(myContext); return ( &lt;&gt; &lt;h1&gt;我是孙子&lt;&#x2F;h1&gt; &lt;h1&gt;&#123;num&#125;&lt;&#x2F;h1&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setNum((prev) &#x3D;&gt; prev + 1); &#125;&#125; &gt; 添加 &lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125;;export default GrandSon; 多层传值的话结构比较清晰，不需要层层用props传值，在一个单独的组件中传值中比较方便","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"useRef的使用","slug":"useRef","date":"2022-02-20T16:00:00.000Z","updated":"2022-03-24T08:54:44.622Z","comments":true,"path":"2022/02/21/useRef/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/02/21/useRef/","excerpt":"","text":"react-hooks之useRef的使用1、函数内部使用useRef可以用来做数据持久化，也可以用来获取到元素实例 ref.current的变化并不会导致函数组件的重新加载不像useState 可以用一个假的useState，结合useEffect的依赖让useRef的值改变后重新加载函数 1234567891011121314151617181920212223242526272829import React, &#123; useState, useContext, useRef, useEffect &#125; from &quot;react&quot;;const App = () =&gt; &#123; const [num, setNum] = useState(0); const myRef = useRef(0); const btnRef = useRef(); useEffect(() =&gt; &#123; myRef.current += 1; &#125;, [num]); return ( &lt;div&gt; &lt;h1&gt;我是Ref:&#123;myRef.current&#125;&lt;/h1&gt; &lt;button ref=&#123;btnRef&#125; onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); console.log(&quot;button的文字: &quot;, btnRef.current.innerText);//改变ref &#125;&#125; &gt; 改变ref &lt;/button&gt; &lt;/div&gt; );&#125;;export default App; 2、子组件使用子组件使用不能直接&lt;Child ref=&#123;childRef&#125;&gt;&lt;Child/&gt; 这样子组件获取不到ref，要用forwordRef把子组件包裹起来传入两个参数（props,ref） 12345678910111213141516171819202122232425262728293031//父组件import React, &#123; useState, useContext, useRef, useEffect &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;const App = () =&gt; &#123; const [num, setNum] = useState(0); const myRef = useRef(0); const btnRef = useRef(); useEffect(() =&gt; &#123; myRef.current += 1; &#125;, [num]); return ( &lt;div&gt; &lt;h1&gt;我是Ref:&#123;myRef.current&#125;&lt;/h1&gt; &lt;button ref=&#123;btnRef&#125; onClick=&#123;() =&gt; &#123; setNum((prev) =&gt; prev + 1); console.log(&quot;button的文字: &quot;, btnRef.current.innerText);//改变ref &#125;&#125; &gt; 改变ref &lt;/button&gt; &lt;Child ref=&#123;childRef&#125;&gt;&lt;/Child&gt; &lt;/div&gt; );&#125;;export default App; 1234567891011121314//子组件import React, &#123;useEffect, forwardRef &#125; from &quot;react&quot;;const Child = forwardRef((props, ref) =&gt; &#123; console.log(&quot;props: &quot;, props); return ( &lt;div ref=&#123;ref&#125;&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;h1&gt;&#123;num&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;);export default Child;","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"react hooks介绍","slug":"react-hook","date":"2022-01-14T16:00:00.000Z","updated":"2022-03-24T08:54:52.864Z","comments":true,"path":"2022/01/15/react-hook/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/01/15/react-hook/","excerpt":"","text":"Hook 是什么？“Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。” 从使用感官上来说，主要是对class组件中 setState和生命周期的“替换”。 Hook的优势 脱离了class和this。（前端更偏爱组装而不是继承。this因为方法嵌套，箭头函数，call，apply，bind等，逐渐复杂化）。 拆分生命周期。（ 对于复杂组件， componentDidUpdate 中可能包含很多逻辑，用useeffect拆分后，条理更清晰 ）。 复用状态逻辑。 在react开发中经常关注的问题 什么行为会触发组件更新？ setState props useReducer 如何让数据在更新过程中不被重置？ useMemo useState const a = useRef(); a.current = 1; 把变量定义在组件的外层 useState和useEffect useState兼具触发更新和保存数据的功能。 useEffect用于弥补函数式组件生命周期的缺失 依赖缺失会导致哪些问题？ useEffect(fun, []); 读取到旧数据`` 依赖的数据类型？ useEffect(fun, [[123] === [123], props, fn]); function 用useCallback进行包裹，useCallback(fn ,[]) 哪些东西不需要写在依赖列表 import，service，moment useRef() useImperativeHandle和useRef useRef可以方便的实现数据持久化，对于不需要进行展示，或者可以依赖其它useState来借东风。 ref转发？ 12345678910function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;), []); return &lt;input ref=&#123;inputRef&#125; /&gt;;&#125;FancyInput = forwardRef(FancyInput); useCallback和useMemo1useCallback(fn, deps)` 相当于 `useMemo(() =&gt; fn, deps) 其它一些Hook useContext useReducer 自定义Hook复用状态逻辑","categories":[],"tags":[{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"2022年来啦","slug":"2022","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-01T14:38:19.748Z","comments":true,"path":"2022/01/01/2022/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2022/01/01/2022/","excerpt":"","text":"2022年元旦新的一年又到来了 工作的时间过的飞快，转眼间已经当了一年的打工人了。 这一年经历了很多，实习、毕业、工作、旅游、隔离、加班。 毕业后一个人留在了常州，开始没什么朋友，过的很烦闷和痛苦。 虽然工作中遇到了几个同事与好友，但是人的喜好并不相同。 但也是很开心的。至少工作中又很多欢乐。 经历了很多也收获了很多，从一开始的写一些小需求，到现在开发整个版本，调研新的技术。 现在应该算一个真正的前端程序员了吧。 就是自己技术的广度没多大提升。 每天从早写到晚，下班或者放假的时候学习新技术是可以屈指可数的。 今年慢慢加油吧。 今天元旦，华姐邀请我去她家吃饭，但是还要我自己烧饭，还是很快乐的，只是没有发挥好，最后出锅忘记了放盐，没有华姐做的好吃。饭后打打牌，做做小游戏，美中不足是没有打到羽毛球。 周末能和好朋友们一起玩一玩真的挺棒的，不会那么烦闷。 新的一年继续加油。 希望今年父母健康，一切都好。 自己一切都好，我爱的人和爱我的人一切都好。 新年快乐！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"react项目国际化","slug":"react项目国际化","date":"2021-12-03T16:00:00.000Z","updated":"2022-03-24T08:40:05.438Z","comments":true,"path":"2021/12/04/react项目国际化/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/12/04/react%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"react项目国际化这里使用的react-intl1、安装react-intlnpm install react-intl --save 或者 cnpm install react-intl --save 2、引入在需要国际化的文件引入react-intl 需要全局国际化就在app.js文件中引入 1234567891011121314import React, &#123; Component &#125; from &quot;react&quot;;import &#123; IntlProvider &#125; from &quot;react-intl&quot;;class Page extends Component &#123; render() &#123; return ( &lt;IntlProvider&gt; &lt;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;IntlProvider&gt; ) &#125;&#125; 3、创建翻译数据文件在src目录下新建一个文件夹i18n包含两个js文件一个locales.js 需要的语言一个messages.js需要翻译的数据 我这里是中文英语和尼泊尔语 1234567&#x2F;&#x2F;locales.jsexport const LOCALES &#x3D; &#123; NEPAIL: &quot;ne-Ne&quot;, CHINESE: &quot;zh-CN&quot;, ENGLISH: &quot;en&quot;,&#125;; 12345678910111213141516171819202122232425&#x2F;&#x2F;messages.jsimport &#123; LOCALES &#125; from &quot;.&#x2F;locales&quot;;export const messages &#x3D; &#123; [LOCALES.NEPAIL]: &#123; chinese: &quot;चिनियाँ&quot;, nepail: &quot;नेपाली&quot;, change_lan: &quot;एउटा भाषा छान्नुहोस्&quot;, station_name: &quot;चार्जिङ स्टेशनको नाम&quot;, &#125;, [LOCALES.CHINESE]: &#123; change_lan: &quot;选择语言&quot;, chinese: &quot;中文&quot;, nepail: &quot;尼泊尔语&quot;, station_name: &quot;电站名称&quot;, &#125;, [LOCALES.ENGLISH]: &#123; change_lan: &quot;languages&quot;, chinese: &quot;chinese&quot;, nepail: &quot;Nepail&quot;, station_name: &quot;stationName&quot;, &#125;,&#125;; 4、使用 使用FormattedMessage 组件，允许用户对简单到复杂的字符串和消息进行翻译和格式化 这个locale ，它接受一个字符串，决定了我们的应用程序是以什么语言呈现的。这里我使用select动态地改变这个值。 messages 对象包含一组准备在前台显示的翻译字符串。这些也将根据当前的语言环境动态地添加。 defaultLocale 道具是默认的locale，应该与应用程序的默认语言相匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from &quot;react&quot;;import &#123; IntlProvider,FormattedMessage &#125; from &quot;react-intl&quot;;import &#123; LOCALES &#125; from &quot;..&#x2F;..&#x2F;i18n&#x2F;locales&quot;;import &#123; messages &#125; from &quot;..&#x2F;..&#x2F;i18n&#x2F;messages&quot;;class Page extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; &#x2F;&#x2F;默认语言 locale: LOCALES.CHINESE, &#125;; render() &#123; const &#123; locale &#125; &#x3D; this.state; return ( &lt;IntlProvider messages&#x3D;&#123;messages[locale]&#125; locale&#x3D;&#123;locale&#125; &#x2F;&#x2F;默认语言 defaultLocale&#x3D;&#123;locale.CHINESE&#125;&gt; &lt;div&gt; &lt;span&gt; &lt;span style&#x3D;&#123;&#123; marginRight: &quot;5px&quot; &#125;&#125;&gt; &lt;FormattedMessage id&#x3D;&quot;change_lan&quot; &#x2F;&gt;: &lt;&#x2F;span&gt; &lt;Select defaultValue&#x3D;&#123;1&#125; placeholder&#x3D;&#123;&lt;FormattedMessage id&#x3D;&quot;change_lan&quot; &#x2F;&gt;&#125; onChange&#x3D;&#123;(val) &#x3D;&gt; &#123; if (val &#x3D;&#x3D;&#x3D; 1) &#123; this.setState(&#123; locale: LOCALES.CHINESE, &#125;); &#125; else if (val &#x3D;&#x3D;&#x3D; 2) &#123; this.setState(&#123; locale: LOCALES.NEPAIL, &#125;); &#125; else if (val &#x3D;&#x3D;&#x3D; 3) &#123; this.setState(&#123; locale: LOCALES.ENGLISH, &#125;); &#125; &#125;&#125; style&#x3D;&#123;&#123; width: &quot;150px&quot; &#125;&#125; &gt; &lt;Option value&#x3D;&#123;1&#125;&gt;中文&lt;&#x2F;Option&gt; &lt;Option value&#x3D;&#123;2&#125;&gt;Nepail&lt;&#x2F;Option&gt; &lt;Option value&#x3D;&#123;3&#125;&gt;Engilish&lt;&#x2F;Option&gt; &lt;&#x2F;Select&gt; &lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;IntlProvider&gt; ) &#125;&#125; 5、占位符placeholder使用、message提示的使用不能使用FormattedMessage因为返回的是一个html 首先使用injectIntl包装React组件， 注入intl上下文 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Form, Input, message &#125; from &quot;antd&quot;;import &#123; FormattedMessage, injectIntl &#125; from &quot;react-intl&quot;;class Add extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; &#125;; &#125; onFinish &#x3D; () &#x3D;&gt; &#123; this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; const msg2 &#x3D; this.props.intl.formatMessage(&#123; id: &quot;save_success&quot; &#125;); message.success(msg2, 5); this.props.form.resetFields(); &#125; &#125;); &#125; &#125;); &#125;; render() &#123; const &#123; getFieldDecorator, setFieldsValue &#125; &#x3D; this.props.form; const placeholder &#x3D; this.props.intl.formatMessage(&#123; id: &quot;input&quot; &#125;); return ( &lt;div&gt; &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125;&gt; &lt;Form.Item label&#x3D;&#123;&lt;FormattedMessage id&#x3D;&quot;station_name&quot; &#x2F;&gt;&#125;&gt; &#123;getFieldDecorator(&quot;name&quot;, &#123; rules: [&#123; required: true, whitespace: true, message: &lt;FormattedMessage id&#x3D;&quot;required&quot; &#x2F;&gt; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&#123;placeholder&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;div&gt; ); &#125;&#125;Add &#x3D; Form.create(&#123;&#125;)(Add);export default injectIntl(Add);","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"react中使用谷歌地图","slug":"react中使用谷歌地图","date":"2021-12-01T16:00:00.000Z","updated":"2022-03-24T08:40:00.030Z","comments":true,"path":"2021/12/02/react中使用谷歌地图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/12/02/react%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"react中使用谷歌地图1、引入index.html文件中引入谷歌地图 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt; &lt;title&gt;OMS&lt;/title&gt; &lt;script src=&quot;https://maps.googleapis.com/maps/api/js?key=AIzaSyDVTk78W-PvhqUC08l6MBqUHTjJXSGcP4g&amp;libraries=places&amp;language=&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2、使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Button, Input &#125; from &quot;antd&quot;;import &#123; FormattedMessage &#125; from &quot;react-intl&quot;;const googleMap &#x3D; window.google &amp;&amp; window.google.maps;class Map extends Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; map: null, lat: null, lng: null, marker: [], &#125;; &#125; &#x2F;&#x2F; 初始化谷歌地图 componentDidMount() &#123; if (&quot;geolocation&quot; in navigator) &#123; &#x2F;&#x2F;检测当前设备是否支持H5Geolocation API navigator.geolocation.getCurrentPosition((position) &#x3D;&gt; &#123; let mapProp &#x3D; &#123; center: new googleMap.LatLng(position.coords.latitude, position.coords.longitude), zoom: 17, mapTypeId: googleMap.MapTypeId.ROADMAP, &#125;; let map &#x3D; new googleMap.Map(document.getElementById(&quot;googleMap&quot;), mapProp); if (this.state.marker[0] &amp;&amp; this.state.marker[0].setMap) &#123; this.state.marker[0].setMap(null); &#125; const arr &#x3D; []; arr[0] &#x3D; new googleMap.Marker(&#123; position: new googleMap.LatLng(position.coords.latitude, position.coords.longitude), &#125;); this.setState( &#123; marker: arr, lat: position.coords.latitude, lng: position.coords.longitude, map, &#125;, () &#x3D;&gt; &#123; this.state.marker[0].setMap(map); &#125; ); &#125;); &#125; else &#123; alert(&quot;该浏览器不支持获取地理位置&quot;); &#125; &#125; addMap &#x3D; () &#x3D;&gt; &#123; googleMap.event.addListener(this.state.map, &quot;click&quot;, (e) &#x3D;&gt; &#123; if (this.state.marker[0] &amp;&amp; this.state.marker[0].setMap) &#123; this.state.marker[0].setMap(null); &#125; const arr &#x3D; []; arr[0] &#x3D; new googleMap.Marker(&#123; position: new googleMap.LatLng(e.latLng.lat(), e.latLng.lng()), &#125;); this.setState( &#123; marker: arr, lat: e.latLng.lat(), lng: e.latLng.lng(), &#125;, () &#x3D;&gt; &#123; this.state.marker[0].setMap(this.state.map); &#125; ); &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;div style&#x3D;&#123;&#123; display: &quot;flex&quot;, alignItems: &quot;center&quot;, marginBottom: 10 &#125;&#125;&gt; &lt;span&gt; &lt;FormattedMessage id&#x3D;&quot;lng&quot; &#x2F;&gt;： &lt;&#x2F;span&gt; &lt;Input style&#x3D;&#123;&#123; width: &quot;200px&quot; &#125;&#125; value&#x3D;&#123;this.state.lng&#125; disabled &#x2F;&gt; &lt;span style&#x3D;&#123;&#123; marginLeft: 20 &#125;&#125;&gt; &lt;FormattedMessage id&#x3D;&quot;lat&quot; &#x2F;&gt;： &lt;&#x2F;span&gt; &lt;Input style&#x3D;&#123;&#123; width: &quot;200px&quot; &#125;&#125; value&#x3D;&#123;this.state.lat&#125; disabled &#x2F;&gt; &lt;Button style&#x3D;&#123;&#123; marginLeft: 20 &#125;&#125; type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;() &#x3D;&gt; &#123; this.props.addLatLng(this.state.lat, this.state.lng); this.props.onCancel(); &#125;&#125; &gt; &lt;FormattedMessage id&#x3D;&quot;ok&quot; &#x2F;&gt; &lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;googleMap&quot; style&#x3D;&#123;&#123; width: &quot;900px&quot;, height: &quot;500px&quot; &#125;&#125; onClick&#x3D;&#123;this.addMap&#125;&gt;&lt;&#x2F;div&gt;; &lt;&#x2F;div&gt; ); &#125;&#125;export default Map;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Redux的使用方法（复习）","slug":"redux&&reacy-redux的使用","date":"2021-11-02T16:00:00.000Z","updated":"2022-03-29T12:25:35.770Z","comments":true,"path":"2021/11/03/redux&&reacy-redux的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/11/03/redux&&reacy-redux%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Redux 的使用方法1、安装 reduxnpm i redux --save 2、新建文件新建文件夹 store 包含 store.js/reducer.js/action.js 3、新建 reducer/action/引入 storereducer.js 123456789101112131415161718192021222324const defaultData = &#123; num: 0 &#125;;const reducer = (state = defaultData, action) =&gt; &#123; console.log(&quot;action: &quot;, action); console.log(&quot;state: &quot;, state); const newData = JSON.parse(JSON.stringify(state)); console.log(&quot;newData: &quot;, newData); switch (action.type) &#123; case &quot;add&quot;: newData.num++; return newData; case &quot;minus&quot;: newData.num--; return newData; case &quot;getVal&quot;: newData.num = action.value; return newData; default: return newData; &#125;&#125;;export default reducer; action.js 12345678910111213const add = (value) =&gt; &#123; return &#123; type: &quot;add&quot;, value &#125;;&#125;;const minus = (value) =&gt; &#123; return &#123; type: &quot;minus&quot;, value &#125;;&#125;;const changeVal = (value) =&gt; &#123; return &#123; type: &quot;getVal&quot;, value &#125;;&#125;;export &#123; add, minus, changeVal &#125;; store.js 123456import &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;const store = createStore(reducer);export default store;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"除法数值转换精度","slug":"除法的百分比精度","date":"2021-10-07T16:00:00.000Z","updated":"2022-03-24T08:40:53.916Z","comments":true,"path":"2021/10/08/除法的百分比精度/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/10/08/%E9%99%A4%E6%B3%95%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E7%B2%BE%E5%BA%A6/","excerpt":"","text":"除法数值转换精度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//arg1:除数//arg2:被除数// 除法转换数值精度export const editDiscountNum = (arg1, arg2) =&gt; &#123; arg1 = Number(arg1); arg2 = Number(arg2); if (!arg2) &#123; return null; &#125; if (!arg1 &amp;&amp; arg1 !== 0) &#123; return null; &#125; else if (arg1 === 0) &#123; return 0; &#125; arg1 = toNonExponential(arg1); arg2 = toNonExponential(arg2); let n1, n2; let r1, r2; // 小数位数 try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; n1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)); n2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)); return floatMultiply(n1 / n2, Math.pow(10, r2 - r1));&#125;;// 乘法数值精度const floatMultiply = (arg1, arg2) =&gt; &#123; arg1 = Number(arg1); arg2 = Number(arg2); if ((!arg1 &amp;&amp; arg1 !== 0) || (!arg2 &amp;&amp; arg2 !== 0)) &#123; return null; &#125; arg1 = toNonExponential(arg1); arg2 = toNonExponential(arg2); let n1, n2; let r1, r2; // 小数位数 try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; n1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)); n2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)); return (n1 * n2) / Math.pow(10, r1 + r2);&#125;;const toNonExponential = (num) =&gt; &#123; if (num == null) &#123; return num; &#125; if (typeof num == &quot;number&quot;) &#123; var m = num.toExponential().match(/\\d(?:\\.(\\d*))?e([+-]\\d+)/); return num.toFixed(Math.max(0, (m[1] || &quot;&quot;).length - m[2])); &#125; else &#123; return num; &#125;&#125;;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"常用正则表达式","slug":"常用正则表达式","date":"2021-09-26T16:00:00.000Z","updated":"2022-03-24T08:40:42.734Z","comments":true,"path":"2021/09/27/常用正则表达式/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/09/27/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"常用正则表达式1234567891011121314151617181920212223242526//手机号var phoneReg = /^1[3456789]\\d&#123;9&#125;$/; // 详细手机号校验规则var phoneReg1 = /^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$/; //验证手机号和固定电话var reg = /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1[34578]\\d&#123;9&#125;))$/;; //邮箱var emailReg = /[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?/;//用户名校验var userNameReg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; //6-16位的包含大小写字母、数字、特殊符号- _ 的用户名var userNameReg1 = /^(?![0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]&#123;6,20&#125;$/; //6-20位字母和数字组合//身份证验证 var idcardReg = /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/;//验证是否两位小数var twoDigReg = /(^[1-9]([0-9]+)?(\\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\\.[0-9]([0-9])?$)/;//内容只能由英文、数字、下划线组成var reg = /^\\w+$/;//内容只能包含英文字母和数字var reg = /^[a-z0-9]+$/i；","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"数组的map方法会不会改变原数组","slug":"数组的map方法","date":"2021-09-20T16:00:00.000Z","updated":"2022-03-24T08:40:24.612Z","comments":true,"path":"2021/09/21/数组的map方法/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/09/21/%E6%95%B0%E7%BB%84%E7%9A%84map%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组的map方法会不会改变原数组****父组件朝子组件传值，二次渲染以后有一个数组的值改变了，发现该数组使用了map，map不是不会改变原数组吗。 会改变原数组于是就自己试了一下 1234567891011121314const arr = [&#123; name: &quot;aa&quot;, num: 1 &#125;];const newArr = arr.map((item) =&gt; &#123; item.num *= 10; return item;&#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/*********************arr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]newArr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]*******************/ 上面代码我们看出原数组arr的值改变了，数组内是引用类型 不会改变原数组123456789101112 const arr = [1, 2, 3, 4, 5]; const newArr = arr.map((item) =&gt; &#123; return item * 10; &#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/**arr: [ 1, 2, 3, 4, 5 ]newArr: [ 10, 20, 30, 40, 50 ]**/ 我又试了一下值类型，发现值类型不会被改变 看来数组的map方法会改变原数组 不改变的写法怎么样能让map方法不改变原数组呢？ 改变原数组的原因是直接对item进行操作。 可以返回一个新的，如下 12345678910111213141516const arr = [&#123; name: &quot;aa&quot;, num: 1 &#125;];const newArr = arr.map((item) =&gt; &#123; return &#123; name:item.name, num:item.num*10 &#125;&#125;);console.log(&quot;arr: &quot;, arr);console.log(&quot;newArr: &quot;, newArr);/***arr: [ &#123; name: &#x27;aa&#x27;, num: 1 &#125; ]newArr: [ &#123; name: &#x27;aa&#x27;, num: 10 &#125; ]***/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"}]},{"title":"文件作为参数上传","slug":"文件作为参数上传","date":"2021-08-11T16:00:00.000Z","updated":"2022-03-24T08:40:57.755Z","comments":true,"path":"2021/08/12/文件作为参数上传/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/08/12/%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"文件作为参数上传文件作为参数上传，需要使用formData格式。 本次是使用Ant Design的form组件和Upload组件实现 若需要别的参数，也要通过formData的append的方法把参数添加到formData中 12//formData中添加参数formData.append(&quot;参数名&quot;，&quot;参数值&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Form, Button, Input, message, Upload &#125; from &quot;antd&quot;;import fetchHandler from &quot;@&#x2F;fetch&#x2F;fetchHandler&quot;;import &#123; prefixFile, rebateUpload &#125; from &quot;@&#x2F;fetch&#x2F;fetchApi&quot;;import axios from &quot;axios&quot;;const &#123; TextArea &#125; &#x3D; Input;class UploadForm extends Component &#123; constructor(props) &#123; super(props); this.props &#x3D; props; this.state &#x3D; &#123; fileList: [], &#125;; &#125; normFile &#x3D; (e) &#x3D;&gt; &#123; console.log(&quot;Upload event:&quot;, e); if (Array.isArray(e)) &#123; return e; &#125; return e &amp;&amp; e.fileList; &#125;; &#x2F;&#x2F; 表单提交 onFinish &#x3D; (e) &#x3D;&gt; &#123; e.preventDefault(); this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; const &#123; fileList &#125; &#x3D; this.state; const formData &#x3D; new FormData(); fileList.forEach((file) &#x3D;&gt; &#123; formData.append(&quot;file&quot;, file); formData.append(&quot;rebateName&quot;, values.rebateName); formData.append(&quot;remark&quot;, values.remark); formData.append(&quot;activityName&quot;, values.activityName); &#125;); axios(&#123; method: &quot;post&quot;, url: &#96;$&#123;prefixFile&#125;&#x2F;webApi&#x2F;rebate&#x2F;upload&#96;, data: formData, header: &#123; Authorization: window.sessionStorage.getItem(&quot;token&quot;), &#125;, &#125;).then((res) &#x3D;&gt; &#123; console.log(res); &#125;); &#125; &#125;); &#125;; &#x2F;&#x2F; 模板下载 downloadTemplate &#x3D; () &#x3D;&gt; &#123; if (this.fileUrl) &#123; window.location.href &#x3D; this.fileUrl; &#125; else &#123; window.location.href &#x3D; &#96;$&#123;prefixFile&#125;&#x2F;templates&#x2F;批量返利模板.xls&#96;; &#125; &#125;; render() &#123; const &#123; getFieldDecorator &#125; &#x3D; this.props.form; const &#123; fileList &#125; &#x3D; this.state; const tailFormItemLayout &#x3D; &#123; wrapperCol: &#123; xs: &#123; span: 24, offset: 0 &#125;, sm: &#123; span: 16, offset: 5 &#125;, &#125;, &#125;; const formItemLayout &#x3D; &#123; labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 4 &#125;, &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 12, offset: 1 &#125;, &#125;, &#125;; const uploadProps &#x3D; &#123; name: &quot;file&quot;, accept: &quot;.xls&quot;, &#x2F;&#x2F; onChange: this.handleChange, onRemove: (file) &#x3D;&gt; &#123; this.setState((state) &#x3D;&gt; &#123; const index &#x3D; state.fileList.indexOf(file); const newFileList &#x3D; state.fileList.slice(); newFileList.splice(index, 1); this.props.form.setFieldsValue(&#123; file: &quot;&quot;, &#125;); return &#123; fileList: newFileList, &#125;; &#125;); &#125;, beforeUpload: (file) &#x3D;&gt; &#123; this.setState( &#123; fileList: [file], &#125;, () &#x3D;&gt; &#123; const &#123; fileList &#125; &#x3D; this.state; const formData &#x3D; new FormData(); fileList.forEach((file) &#x3D;&gt; &#123; formData.append(&quot;file&quot;, file); &#125;); this.props.form.setFieldsValue(&#123; file: formData, &#125;); &#125; ); return false; &#125;, fileList, &#125;; return ( &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125;&gt; &lt;Form.Item label&#x3D;&quot;返利批次名称&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;rebateName&quot;, &#123; rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&quot;请输入返利批次名称&quot; maxLength&#x3D;&#123;100&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;活动名称&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;activityName&quot;, &#123; rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], initialValue: &quot;&quot;, &#125;)(&lt;Input placeholder&#x3D;&quot;请输入活动名称&quot; maxLength&#x3D;&#123;100&#125; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;备注&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;remark&quot;, &#123; rules: [&#123; required: false &#125;], initialValue: &quot;&quot;, &#125;)(&lt;TextArea rows&#x3D;&#123;5&#125; maxLength&#x3D;&#123;50&#125; placeholder&#x3D;&quot;请输入备注&quot; &#x2F;&gt;)&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item label&#x3D;&quot;批量上传&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&quot;file&quot;, &#123; valuePropName: &quot;fileList&quot;, getValueFromEvent: this.normFile, rules: [&#123; required: true, message: &quot;该项是必填项&quot; &#125;], &#125;)( &lt;div&gt; &lt;Upload &#123;...uploadProps&#125;&gt; &lt;Button type&#x3D;&quot;dashed&quot;&gt;上传文件&lt;&#x2F;Button&gt; &lt;&#x2F;Upload&gt; &lt;a style&#x3D;&#123;&#123; marginRight: &quot;10px&quot; &#125;&#125;&gt;模板&lt;&#x2F;a&gt; &lt;a onClick&#x3D;&#123;this.downloadTemplate&#125;&gt;点击下载&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; )&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item &#123;...tailFormItemLayout&#125;&gt; &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; &#123; this.props.onCancel(); &#125;&#125; style&#x3D;&#123;&#123; marginRight: &quot;20px&quot; &#125;&#125; &gt; 退出 &lt;&#x2F;Button&gt; &lt;Button type&#x3D;&quot;primary&quot; htmlType&#x3D;&quot;submit&quot;&gt; 提交 &lt;&#x2F;Button&gt; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;Form&gt; ); &#125;&#125;UploadForm &#x3D; Form.create(&#123;&#125;)(UploadForm);export default UploadForm;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"表单添加多组规则","slug":"2021-07-30-表单添加多组规则","date":"2021-07-29T16:00:00.000Z","updated":"2022-03-24T08:25:35.162Z","comments":true,"path":"2021/07/30/2021-07-30-表单添加多组规则/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/07/30/2021-07-30-%E8%A1%A8%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BB%84%E8%A7%84%E5%88%99/","excerpt":"","text":"起因 框架 react+ant3（老项目重构很难） 新版本一个需求原型如下：[ 可以有多个规则，且规则之间时间需要连续。上一个结束时间的第二天要是下一个规则的开始时间。 如果第一个结束时间是 7 月 30 号,下个月的开始时间要是 7.31 号。依次类推。 还要可以批量设置。就是一次性设置多个。 首先肯定想到的是用数组 map,用的 form 表单。就新建一个数组arr=[0],点击添加按钮的时候就再push一个 0，删除按钮就arr.splice(index,1),index 是当前元素下标。但是form.item的依赖字段会重复。 然后只能自己用datePicker、Input还有框架封装好的获取企业 Id 的模糊查询的组件。 且有规则后再修改可以回显数据。 如下： 这是外层的 Modal: 因为批量多个参数逗号分隔。 初始化indexOf判断有没有逗号，是单个还是批量，单个的话就获取数据，且把获取到的数据通过 props 传到子组件当中。因为 render 是先 render。所以这里用个 flag。保证获取到的数据可以传到子组件。 再把需要的一些方法传到子组件当中。 子组件中，通过onChange获取到值放到一个对象中添加到数组里。 添加的时候获取到当前的结束时间。通过moment().add(1,&#39;day&#39;)当然这里要判断是不是数组中的第一个 还有就是对时间的判断。 因为时间的连续的删除只能删除最后一个。 基本完成了功能，但是感觉很冗余，还要修改，一些细节还要完善。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import React,&#123;Component&#125; from &#39;react&#39;import &#123; Form, Button, Input, message &#125; from &quot;antd&quot;import fetchHandler from &#39;@&#x2F;fetch&#x2F;fetchHandler&#39;import TrusteeshipForm from &#39;.&#x2F;TrusteeshipForm&#39;;import moment from &#39;moment&#39;;import &#123;settlementSetting,getSettlementSetting&#125; from &#39;@&#x2F;fetch&#x2F;fetchApi&#39;class Trusteeship extends Component &#123; constructor(props) &#123; super(props) this.props &#x3D; props this.state &#x3D; &#123; domArr : [], stubId:this.props.stubId, info:[], flag:true &#125; &#125; componentWillMount() &#123; this.getInfo() &#125; async getInfo () &#123; if(this.props.stubId.indexOf(&#39;,&#39;)&gt;0) &#123; return &#125; this.setState(&#123; flag:false &#125;) await fetchHandler(getSettlementSetting,&#123; stubId:this.props.stubId &#125;).then( (res)&#x3D;&gt;&#123; if(res&amp;&amp;res.code&#x3D;&#x3D;&#x3D;&#39;success&#39;) &#123; const domArr &#x3D; [] res.data.map((item,index)&#x3D;&gt;&#123; let obj &#x3D; &#123;&#125; obj.unitPrice &#x3D; item.unitPrice obj.paymentCompanyId&#x3D;item.paymentCompanyId obj.startDate &#x3D; moment(item.startDate).format(&quot;YYYY-MM-DD&quot;) obj.endDate &#x3D; moment(item.endDate).format(&quot;YYYY-MM-DD&quot;) obj.companyName &#x3D; item.companyName domArr.push(obj) &#125;) this.setState(&#123; domArr, info:res.data, flag:true &#125;) &#125; &#125;) &#125; onAdd &#x3D; (newArr)&#x3D;&gt;&#123; this.setState(&#123; domArr:newArr &#125;)&#125; onDel &#x3D; ()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr domArr.splice(domArr.length-1,1) this.setState(&#123; domArr &#125;) &#125;&#x2F;&#x2F; 判断对象是否存在空值 getDetaios(arr) &#123; for (var i in arr) &#123; if (arr[i] &#x3D;&#x3D; null) &#123; return true &#125; &#125; return false &#125; onChange &#x3D; (obj)&#x3D;&gt;&#123; this.props.form.setFieldsValue(&#123; stubPeriodSetting: obj &#125;) &#125;onFinish &#x3D; (e) &#x3D;&gt; &#123; const domArr &#x3D; this.state.domArr const isNull &#x3D; this.getDetaios(domArr[domArr.length-1]) console.log(domArr); if(isNull) &#123; message.warning(&quot;存在未填项或开始时间在结束时间之前，请检查&quot;) return &#125; e.preventDefault(); this.props.form.validateFields((err, values) &#x3D;&gt; &#123; if (!err) &#123; values.stubIds &#x3D; this.state.stubId fetchHandler(settlementSetting,values ).then((res) &#x3D;&gt; &#123; console.log(res); if (res.code &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123; message.success(&quot;保存成功！&quot;) this.props.fresh() this.props.onCancel() &#125; &#125;) &#125; &#125;);&#125;;setFlag () &#123; this.setState(&#123; flag:true &#125;)&#125;render () &#123; const &#123;getFieldDecorator&#125; &#x3D; this.props.form const &#123;domArr,flag,info&#125; &#x3D; this.state console.log(domArr); console.log(info); return ( &lt;Form name&#x3D;&quot;basic&quot; onSubmit&#x3D;&#123;this.onFinish&#125; &gt; &lt;h5&gt;收费规则&lt;&#x2F;h5&gt; &#123;flag? &lt;div&gt;&lt;Form.Item label&#x3D;&quot;合同编号&quot; style&#x3D;&#123;&#123; display:&quot;flex&quot; &#125;&#125; &gt; &#123;getFieldDecorator(&#39;concatNo&#39;, &#123; rules: [&#123; required: true, message: &#39;该项是必填项&#39; &#125;], initialValue: (info.length!&#x3D;&#x3D;0)?info[0].concatNo:&quot;&quot; &#125;)( &lt;Input style&#x3D;&#123;&#123; &#39;width&#39;: &#39;300px&#39; &#125;&#125; placeholder&#x3D;&quot;请输入合同编号&quot; &#x2F;&gt;, )&#125; &lt;&#x2F;Form.Item&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&#39;stubPeriodSetting&#39;, &#123; rules: [&#123; required: true, message: &#39;该项是必填项&#39;,type: &#39;array&#39; &#125;], initialValue: &quot;&quot; &#125;)( &lt;TrusteeshipForm setFlag&#x3D;&#123;()&#x3D;&gt;&#123;this.setFlag&#125;&#125; domArr&#x3D;&#123;domArr&#125; onAdd &#x3D; &#123;this.onAdd&#125; onDel&#x3D;&#123;this.onDel&#125; onChange&#x3D;&#123;this.onChange&#125; &#x2F;&gt;, )&#125; &lt;&#x2F;Form.Item&gt;&lt;&#x2F;div&gt;:&quot;&quot;&#125; &lt;Form.Item style&#x3D;&#123;&#123;display: &quot;flex&quot;,justifyContent:&quot;center&quot;&#125;&#125;&gt; &lt;Button type&#x3D;&quot;dashed&quot; htmlType&#x3D;&quot;submit&quot;&gt; 保存 &lt;&#x2F;Button&gt; &lt;&#x2F;Form.Item&gt; &lt;&#x2F;Form&gt; )&#125;&#125;Trusteeship &#x3D; Form.create(&#123;&#125;)(Trusteeship)export default Trusteeship 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&#x2F;&#x2F; 引入reactimport React, &#123; PureComponent&#125; from &#39;react&#39;;import &#123; Form, Button, Input, message,DatePicker &#125; from &quot;antd&quot;import fetchHandler from &#39;@&#x2F;fetch&#x2F;fetchHandler&#39;import &#123;companyList &#125; from &#39;@&#x2F;fetch&#x2F;fetchApi&#39;import AutoSearch from &#39;@&#x2F;components&#x2F;display&#x2F;input&#x2F;AutoSearch&#39;;import moment from &#39;moment&#39;;class TrusteeshipForm extends PureComponent &#123; constructor(props) &#123; super(props); this.props &#x3D; props this.state &#x3D; &#123; domArr :this.props.domArr &#125; &#125; style &#x3D; &#123; display: &#39;flex&#39;, alignItems:&quot;center&quot;, marginBottom:&quot;20px&quot; &#125;&#x2F;&#x2F; 判断对象是否存在空值 getDetaios(arr) &#123; for (var i in arr) &#123; if (arr[i] &#x3D;&#x3D; null) &#123; return true &#125; &#125; return false &#125;componentDidMount () &#123; this.props.onChange(this.state.domArr)&#125; onAdd &#x3D; ()&#x3D;&gt;&#123; const &#123;domArr&#125; &#x3D; this.state this.props.setFlag() if(domArr.length&gt;&#x3D;10) &#123; message.warning(&quot;最多添加10条！&quot;) return &#125; if(this.getDetaios(domArr[domArr.length-1])) &#123; message.warning(&quot;存在未填项或数据不正确，请检查！&quot;) return &#125; let nextStartDate &#x3D; moment(new Date()).format(&quot;YYYY-MM-DD&quot;) let nextEndDate &#x3D; moment(new Date()).add(7,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) if(domArr.length&gt;0) &#123; nextStartDate &#x3D; moment(domArr[domArr.length-1].endDate).add(1,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) nextEndDate &#x3D; moment(nextStartDate).add(7,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) &#125; const obj &#x3D;&#123; unitPrice:null, paymentCompanyId:null, startDate:nextStartDate, endDate: nextEndDate, &#125; domArr.push(obj) this.setState(&#123; domArr, &#125;,()&#x3D;&gt;&#123; this.props.onAdd(domArr) &#125; ) &#125; startChange (startDate,index) &#123; const domArr &#x3D; this.state.domArr const time &#x3D; moment(startDate).diff(moment(domArr[index].endDate)) if(time&gt;0) &#123; message.warning(&quot;开始时间必须在结束时间之前！&quot;) return &#125; domArr[index].startDate &#x3D; startDate this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; endChange (endDate,index) &#123; const domArr &#x3D; this.state.domArr let time if( domArr[index+1]) &#123; time &#x3D; moment(endDate).diff(moment(domArr[index+1].endDate)) &#125; if(time&gt;0||time&#x3D;&#x3D;&#x3D;0) &#123; domArr.forEach((item,i)&#x3D;&gt;&#123; if(i&gt;index) &#123; item.endDate &#x3D; null item.startDate &#x3D; null &#125; &#125;) &#125; if(domArr[index+1]) &#123; domArr[index+1].startDate &#x3D; moment(endDate).add(1,&#39;day&#39;).format(&quot;YYYY-MM-DD&quot;) &#125; domArr[index].endDate &#x3D; endDate this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; feeChange (fee,index) &#123; const domArr &#x3D; this.state.domArr domArr[index].unitPrice &#x3D; fee this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; companyChange (e,index) &#123; const domArr &#x3D; this.state.domArr domArr[index].paymentCompanyId &#x3D; e this.setState(&#123; domArr &#125;,()&#x3D;&gt;&#123; const domArr &#x3D; this.state.domArr this.props.onChange(domArr) this.props.onAdd(domArr) &#125;) &#125; render() &#123; const &#123;domArr&#125; &#x3D; this.state return &lt;div style&#x3D;&#123;&#123;width:&quot;552px&quot;&#125;&#125;&gt; &#123;domArr&amp;&amp;domArr.map((item,index)&#x3D;&gt;&#123; return &lt;div key&#x3D;&#123;index&#125;&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 时间周期：&lt;&#x2F;label&gt; &lt;DatePicker placeholder&#x3D;&quot;开始时间&quot; disabled&#x3D;&#123;index!&#x3D;&#x3D;0&#125; value &#x3D; &#123;moment(item.startDate,&quot;YYYY-MM-DD&quot;)&#125; onChange&#x3D;&#123;(e,date)&#x3D;&gt;&#123; this.startChange(date,index) &#125;&#125;&#x2F;&gt; &lt;span&gt;—&lt;&#x2F;span&gt; &lt;DatePicker placeholder&#x3D;&quot;结束时间&quot; defaultValue&#x3D;&#123;moment(item.endDate,&quot;YYYY-MM-DD&quot;)&#125; disabledDate&#x3D;&#123;(current)&#x3D;&gt; &#123; return current &amp;&amp; current &lt;moment(item.startDate) &#125;&#125; onChange&#x3D;&#123;(e,date)&#x3D;&gt;&#123; this.endChange(date,index) &#125;&#125; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 托管费用：&lt;&#x2F;label&gt; &lt;Input defaultValue&#x3D;&#123;item.unitPrice&#125; type&#x3D;&quot;number&quot; style&#x3D;&#123;&#123; &#39;width&#39;: &#39;300px&#39; &#125;&#125; onChange&#x3D;&#123;(e)&#x3D;&gt;&#123; this.feeChange(e.target.value,index) &#125;&#125; placeholder&#x3D;&quot;请输入托管费用&quot; addonAfter&#x3D;&quot;元&#x2F;年&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&#123;this.style&#125;&gt; &lt;label&gt;&lt;span style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;*&lt;&#x2F;span&gt; 承担企业：&lt;&#x2F;label&gt; &lt;AutoSearch key&#x3D;&#123;item.companyName||&#39;add&#39;&#125; placeholder&#x3D;&#39;请输入商户名称模糊搜索&#39; config&#x3D;&#123;&#123; allowClear: true,&#x2F;&#x2F;是否允许清除, showParam: &#39;companyName&#39;, &#x2F;&#x2F; 展示的条目参数 choseParam: &#39;companyId&#39;, &#x2F;&#x2F; 选中的参数 sourceApi: companyList, &#x2F;&#x2F; 选项接口 initialValue: item.companyName, fetchParams:&#123; status:1 &#125; &#125;&#125; module&#x3D;&#39;company&#39; setValue&#x3D;&#123;(e) &#x3D;&gt; &#123; this.companyChange(e,index) &#125;&#125; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;hr&#x2F;&gt; &lt;&#x2F;div&gt; &#125;) &#125; &lt;div style&#x3D;&#123;&#123;display: &quot;flex&quot;,justifyContent:&quot;center&quot;&#125;&#125;&gt; &lt;Button type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123; this.onAdd() &#125;&#125;&gt; 添加规则&lt;&#x2F;Button&gt; &#123;domArr&amp;&amp;domArr.length!&#x3D;&#x3D;0? &lt;Button style&#x3D;&#123;&#123;marginLeft:&quot;20px&quot;&#125;&#125; type&#x3D;&quot;primary&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123; this.props.onDel() &#125;&#125;&gt;删除&lt;&#x2F;Button&gt;:&quot;&quot;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#125;&#125;TrusteeshipForm &#x3D; Form.create(&#123;&#125;)(TrusteeshipForm)export default TrusteeshipForm;","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"https://gitee.com/shimmer612/myBlog/tags/antd/"}]},{"title":"星球空间站项目总结","slug":"2021-06-30-星球空间站项目总结","date":"2021-06-29T16:00:00.000Z","updated":"2021-06-30T14:10:40.226Z","comments":true,"path":"2021/06/30/2021-06-30-星球空间站项目总结/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/30/2021-06-30-%E6%98%9F%E7%90%83%E7%A9%BA%E9%97%B4%E7%AB%99%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"“星球空间站”项目总结星球空间站是OMS项目的3.0版本，入职以来，都是在老项目中写页面，上一个项目组中的新项目《重卡换电》场站管理系统，做到80%,就被调走了，不过也只是写写页面，项目都是健哥搭的umijs 星球空间站算是第一个全部由我开发的项目。虽然只算是OMS的一个导航页面。不过对于我来说，也是很好的锻炼了。 今天把遇到的一些知识点记录一下。 最终图差不多如下。 如下 1、首页有三个echarts图表，一个曲线折线图。两个环形图。 ​ 这个比较简单一些，因为之前有recat引用echarts的经验，所以官网找到相关的示例。 只是改样式比较麻烦。只能慢慢找配置项。 这里记录一下用到的配置项，里面详细的配置就不记录了。 配置项的地址如下 https://echarts.apache.org/zh/option.html 1234567legend 图例。dataZoom 用于区域缩放，就是图表可以放大缩小，左右滑动tooltip提示框。 鼠标移到表格上可以提示数据series系列列表。每个系列通过 type 决定自己的图表类型，放数据以及数据怎么展示的地方xAxis 直角坐标轴 x轴yAxis 直角坐标轴 y轴 等等 然后还有的就是。echarts的加载、数据动态绑定等，大小随窗口变化等要注意的地方 2、下面导航按钮图标使用iconfont 之前使用iconfont都是下载的png图片，这里要用代码引入 一开始使用的css引入发现图标没有颜色都是黑的，问了一下，要用symbol 方式引入，就是js方式： 1：我是先新建了一个iconfont的js文件 12345678910 import &#123; Icon &#125; from &#x27;antd&#x27;; const IconFont = Icon.createFromIconfontCN(&#123; scriptUrl: &#x27;symbol方式在线地址&#x27; &#125;); export default IconFont; 2：使用，type就是图标的名 1&lt;IconFont type=&quot;icon-ali-pay&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;lightblue&#x27; &#125;&#125; /&gt; 3、日历组件 最烦的就是这个花了我大量的时间，本来想使用ant的现成组件，可是不会复写样式，而且也麻烦，心一横手写吧。 因为之前在小程序中写过，获取到当月的天数，然后通过第一天是星期几，来判断上月显示几天，下月显示几天。我这里第一天是兴趣一，要是上个月最后一天是星期天就不用显示了。是星期一的话就显示最后一天，星期二最后2天以此类推。下个月就是下个月第一天是星期一就不用显示。星期天就显示下个月第一天。星期二就显示下个月一二两天，依次类推。 然后三个数组拼成一个数组用arr.concat()连接数组。 又因为日期要可以点击，样式产生变化，而且可以获取到当前日期， 日期数组中，每一项的结构如下, flag是判断当前哪个日期被选中了，初始化当天的flag为true isActivity是判断当前日前有没有活动 1234567[&#123;year:2021,month：6,day:30,flag:true,isActivity:true&#125;] 然后就是点击上月日期和下月日期切换月份。 判断当前点击的日期月份。 select框也是和数据绑定， 需要考虑的就是setState()是异步的，需要在setState()的回调中，或者setTimeout()调用相关的方法,以及方法的传参等等。 4、主要的就是这些，还有的就是路由传值、跳转，因为oms没有路由通过tabs页签切换页面的，吧tab的 key传过去等 父组件中跳转传参 12345this.props.history.push(&#123; pathname:&quot;/index&quot;, name:&quot;xxx&quot;,//参数 age:&quot;18&quot;&#125;) 子组件中： 12345678//父组件通过props传给子组件&lt;Child history=&#123;this.props.history&#125;/&gt; this.props.history.push(&#123; pathname:&quot;/index&quot;, name:&quot;xxx&quot;,//参数 age:&quot;18&quot;&#125;) 接收在location： 12this.props.history.location.namethis.props.history.location.age 还有就是moment.js计算两天某天相差多少天,倒计时 moment(endTime).diff(moment(startTime),&#39;day&#39;) 天 moment(endTime).diff(moment(startTime),&#39;month&#39;)月 moment(endTime).diff(moment(startTime),&#39;year&#39;) 年 还有就是一些布局方面注意的东西。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"}]},{"title":"菊次郎的夏天观后感","slug":"2021-06-12-菊次郎的夏天观后感","date":"2021-06-11T16:00:00.000Z","updated":"2021-06-12T09:56:33.113Z","comments":true,"path":"2021/06/12/2021-06-12-菊次郎的夏天观后感/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/12/2021-06-12-%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/","excerpt":"","text":"《菊次郎的夏天》观后感1、《菊次郎的夏天》这部电影评分很高 久石让给电影配乐 就算你不知道这部电影 也应该听过 让人很舒服的曲子 剧中大叔菊次郎帮正太找妈妈 结果正太的妈妈有了新的家庭 ”地方对了，人不对“ 欢笑中见温情 剧中他们遇到的人都很温柔 小情侣、摩托二人组、吟游诗人 其实这个电影就是说大叔菊次郎小时候的故事 熟悉的音乐开始 熟悉的音乐结束 只是片尾的音乐多了一丝轻快与愉悦 温馨的音乐， 像夏天傍晚微凉的风迎面吹来，看着大海 这样的音乐 却不经意就让人湿了眼眶 2、其实很怀念剧中的夏天 谁的童年不曾有过那样的一个类似的暑假呢 只是现在就算回到了童年的场景 也不有当时的人了 那时的景那时的人 停留在那时空了 3、最近很闲 有个十天左右的时间 不用上班 很闲 九十点就睡觉，五六点就起床 睡得早、起的早 像个老年人 想想人生的前几个阶段 我好像不是一个善于维护关系的人 每一个阶段看起来都和身边的人玩的很好 当那个阶段结束 就从来不联系了 仿佛这个人没有在我的生命中出现过一样 我总以为 该在的人，总会一直在那的 无需联系 需要联系我也不知道联系什么 我本是一个无趣的人 生活中见不起什么波澜 也没有什么分享欲 按理说我应该很合适一个人的 但是我有希望时不时能有个人陪我一起去干点什么 其实每个人身边都应该有一两个好朋友的 可我没有 按理说我其实也不差 做事情从来不会想太多 直言直语 可为什么有人背后说我有心机太重 很莫名其妙","categories":[],"tags":[{"name":"观后感","slug":"观后感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"杂记07(再见我的学生时代)","slug":"2021-06-10-杂记07(再见我的学生时代)","date":"2021-06-09T16:00:00.000Z","updated":"2021-06-10T04:13:52.028Z","comments":true,"path":"2021/06/10/2021-06-10-杂记07(再见我的学生时代)/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/06/10/2021-06-10-%E6%9D%82%E8%AE%B007(%E5%86%8D%E8%A7%81%E6%88%91%E7%9A%84%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3)/","excerpt":"","text":"和学生的身份说再见时间真的过的很快 曾经遥遥无期的毕业 也来到了眼前 这次的毕业也真正的要与学生的身份说再见了 以前总是想尽快的告别学生的身份 走进社会干一番大事业 当这个时间点真实的到达眼前 却想着时间你能不能再慢一点 小学、初中、高中以往的毕业总是离别中带着一丝轻松愉快的 考完试，就是漫长的假期，不紧不慢 有大把的时间能让我们去迎接下一阶段的生活 大学毕业却是紧迫的 实习的我，半只脚已经踏入社会 请假答辩交材料 聚会、离别 租房、搬家 在一天天的忙碌中 我离开了校园 自由却又束缚 不像我想的那样美好 租房确实给了自己一方天地 我养了猫 名字叫 拾月 是个橘猫妹妹 这个小家伙 给我的生活带来了很多的惊喜 同时也很闹心 就和养一个孩子一样 我不是一个很乐观的人 但总是会在悲观的情绪中给自己一点暗示 会好起来的 最后 再见我的学生时代 （睡觉的拾月）","categories":[],"tags":[{"name":"随感","slug":"随感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E6%84%9F/"}]},{"title":"把多层嵌套的一层数据结构转换成原本的多层","slug":"2021-04-20-把多层嵌套的一层数据结构转换成原本的多层","date":"2021-04-19T16:00:00.000Z","updated":"2021-04-21T00:44:36.572Z","comments":true,"path":"2021/04/20/2021-04-20-把多层嵌套的一层数据结构转换成原本的多层/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/20/2021-04-20-%E6%8A%8A%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E4%B8%80%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8E%9F%E6%9C%AC%E7%9A%84%E5%A4%9A%E5%B1%82/","excerpt":"","text":"背景一个多层嵌套评论回复的场景，但是孤儿后端，把所有的回复数据，放到一个数组里返回给我，只有一层，我要给数据转换成原先的多层嵌套的模式。 数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//commitId是最外层的评论ID//id是每条回复自己的ID//replyId是回复父级的Id//现在要把每个子级回复放到父级回复的child里面let data = [ &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;da642ba6-52b2-4965-bf39-c21f8f2ceaf0&quot;, replyId: &quot;fb0a7604-68cb-45c7-b149-99dceb5a6004&quot;, replyMsg: &quot;1-1-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;e5def846-c747-496b-9ab8-270655bc269b&quot;, replyId: &quot;a583dd34-ff71-44dd-9eaa-5b753501b9a6&quot;, replyMsg: &quot;2-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;a583dd34-ff71-44dd-9eaa-5b753501b9a6&quot;, replyId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, replyMsg: &quot;2&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;9de4bb96-16e5-4570-b03f-60ac2beb8965&quot;, replyId: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyMsg: &quot;1-2&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;fb0a7604-68cb-45c7-b149-99dceb5a6004&quot;, replyId: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyMsg: &quot;1-1&quot;, child: [] &#125;, &#123; commentId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, id: &quot;f7788b92-66cf-4463-ac44-5da0fcd95aa0&quot;, replyId: &quot;5786ea2a-7921-4d2e-bb1e-fc8ddb69d2b4&quot;, replyMsg: &quot;1&quot;, child: [] &#125;] 看到这个场景，第一时间想到的就是递归。 但是逻辑想了很久才想出来。 其实很简单，想不通，想死了都想不出来。 想通了就很简单。 12345678910111213function dg(id) &#123; let arr = [] for(let i = 0;i&lt;data.length;i++) &#123; if(data[i].replyId === id)&#123; arr.push(data[i]) data[i].child = dg(data[i].id) &#125; &#125; return arr&#125; 如下 tips:今天是她的生日，我什么都没干，太棒了！","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"递归实现多层评论","slug":"2021-04-19-递归实现多层评论","date":"2021-04-18T16:00:00.000Z","updated":"2021-04-19T09:12:22.880Z","comments":true,"path":"2021/04/19/2021-04-19-递归实现多层评论/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/19/2021-04-19-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E8%AF%84%E8%AE%BA/","excerpt":"","text":"多层评论递归嵌套递归函数两部曲 1：找规律 2：找出口 数据格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const obj = [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [] &#125;, &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [ &#123; commentId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, commentIdList: null, commentReplyId: &quot;c800325e-e123-4ac3-81cf-a24c8ba54d5f&quot;, replyId: &quot;6cfc5ff4-2af1-4621-bc52-b3d6ff22973c&quot;, replyImg: null, replyMsg: &quot;哦看看&quot;, replyTargetUserId: null, replyTargetUserName: null, replyTime: &quot;2021.04.15 17:02:26&quot;, replyUserAvatar: &quot;https://app-cdn.starcharge.com/32360E48-6011-47CA-99BE-171AD0B555AC-iOS.jpg&quot;, replyUserId: &quot;6266ff37-29fb-46fe-b8a3-76e1b5da75dc&quot;, replyUserName: &quot;03591的昵称真的很长哦看❤️这里&quot;, replyUserType: null, childCommentReplyBo: [] &#125;, ] &#125; ] &#125; ] &#125;] 1234567891011121314151617181920212223242526272829303132333435363738394041// 评论递归 repleyRecursion = (k) =&gt; &#123; const &#123; replyArr &#125; = this.state if (k.length !== 0) &#123; k.map((item, index) =&gt; &#123; replyArr.push(&lt;div style=&#123;&#123; width: &quot;700px&quot;, display: &quot;flex&quot;, justifyContent: &quot;space-between&quot;, alignItems: &quot;center&quot;, marginBottom: &quot;10px&quot; &#125;&#125;&gt; &lt;span&gt;用户账号：&#123;item.replyUserName&#125;&lt;/span&gt; &lt;span&gt;回复时间: &#123;item.replyTime&#125;&lt;/span&gt; &lt;span&gt;回复内容：&#123;item.replyMsg&#125;&lt;/span&gt; &lt;div&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; &#123; this.setState(&#123; replyVisible: true, commentId: item.commentReplyId, userId: item.replyUserId &#125;) &#125;&#125;&gt;回复&lt;/Button&gt; &lt;Popconfirm title=&quot;确认删除评论吗？&quot; onConfirm=&#123;() =&gt; &#123; this.deleteReply(item.commentId) &#125;&#125; onCancel=&#123;&quot;&quot;&#125; okText=&quot;确定&quot; cancelText=&quot;取消&quot; &gt; &lt;Button type=&quot;primary&quot;&gt;删除&lt;/Button&gt; &lt;/Popconfirm&gt; &lt;/div&gt; &lt;/div&gt;) this.repleyRecursion(item.childCommentReplyBo) &#125;) &#125; else &#123; return replyArr.map((item, i) =&gt; &#123; return item &#125;) &#125; &#125;","categories":[],"tags":[{"name":"-javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"javascript排序算法01","slug":"2021-04-15-javascript排序算法01","date":"2021-04-14T16:00:00.000Z","updated":"2021-04-15T09:42:04.768Z","comments":true,"path":"2021/04/15/2021-04-15-javascript排序算法01/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/15/2021-04-15-javascript%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/","excerpt":"","text":"冒泡排序两两对比，如果n项大于n+1项，就交换位置。 基本的 forEach执行就是所有循环结束，不能break。map同理 12345678910111213141516171819const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]// const arr = [1, 2, 3, 4, 5, 6, 7]let a = 0//基本 arr.forEach(() =&gt; &#123; arr.forEach((k, i) =&gt; &#123; const count = arr[i + 1] if (arr[i] &gt; arr[i + 1]) &#123; arr[i + 1] = arr[i] arr[i] = count &#125; &#125;) &#125;)console.log(a);console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 优化版 123456789101112131415161718192021// 优化const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]for (var i = 0; i &lt; arr.length - 1; i++) &#123; var flag = false; for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; a++ if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if (flag == false) &#123; break; &#125;&#125;console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 选择排序每次排序把最大的或者最小的放到开头或者末尾 1234567891011121314151617181920212223const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]function selectSort(arr) &#123; let minIndex, temp for (let i = 0; i &lt; arr.length - 1; i++) &#123; // 保存当前下标 minIndex = i // 找到最小的数的下标 for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; // 每次找出的最小数和当前的数交换位置 temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr&#125;selectSort(arr)console.log(arr);//[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ] 插入排序从第二个数开始，如果当前数大于或者小于前一个数，就交换位置 123456789101112131415161718192021222324252627282930313233343536const arr = [90, 33, 23, 43, 54, 123, 78, 56, 76, 112]function insertSort(arr) &#123; var len = arr.length; for (var i = 1; i &lt; len; i++) &#123; //key为当前数 var key = arr[i]; // j为前一个数的下标 var j = i - 1; //如果前一个数大于当前数 while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; //当前数等于前一个数 arr[j + 1] = arr[j]; //j减一 j--; &#125; //满足条件的最前面的数等于当前数 arr[j + 1] = key; &#125; return arr;&#125;insertSort(arr)console.log(arr); //[ 23, 33, 43, 54, 56, 76, 78, 90, 112, 123 ]","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"聊天框自动定位到最底部","slug":"2021-04-12-聊天框自动定位到最底部","date":"2021-04-11T16:00:00.000Z","updated":"2021-04-12T08:52:27.818Z","comments":true,"path":"2021/04/12/2021-04-12-聊天框自动定位到最底部/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/12/2021-04-12-%E8%81%8A%E5%A4%A9%E6%A1%86%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%9C%80%E5%BA%95%E9%83%A8/","excerpt":"","text":"介绍最近通过webSocket实现了客服聊天的功能，但是当消息超出聊天框的时候，消息框并不会自动滚到到最新消息的地方。要手动滚动，很蠢。 而且一开始的滚动条很丑，顺便美化了一下滚动条。 vue中写在updated的生命周期里/react写在componentDidUpdate生命周期里 1234567updated () &#123; // 聊天定位到底部 this.$nextTick(() =&gt; &#123; const msg = document.getElementsByClassName(&#x27;chat-info&#x27;) // 获取对象 msg[0].scrollTop = msg[0].scrollHeight // 滚动高度 &#125;) &#125;, css 1234567891011::-webkit-scrollbar &#123; // display: none; width: 5px; height: 100%; background: rgb(239, 239, 239); border-radius: 2px;&#125;::-webkit-scrollbar-thumb &#123; background: #bfbfbf; border-radius: 10px;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"express-ws实现webSocket通信","slug":"2021-04-10-express-ws实现webSocket通信","date":"2021-04-09T16:00:00.000Z","updated":"2021-04-12T00:42:03.873Z","comments":true,"path":"2021/04/10/2021-04-10-express-ws实现webSocket通信/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/10/2021-04-10-express-ws%E5%AE%9E%E7%8E%B0webSocket%E9%80%9A%E4%BF%A1/","excerpt":"","text":"前言最近要给自己写的项目中加一个客服聊天的功能。就是前端商城和后台管理系统通信。但是是两个不同的端口。 百度了一下就找到了webSocket。 什么是webSocket？WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。(来自菜鸟教程：https://www.runoob.com/html/html5-websocket.html) express-ws实现1、首先在express项目中安装express-ws npm i express-ws --save 2、然后引入 123456const express = require(&#x27;express&#x27;)const app = express()// 引入WebSocketconst ws = require(&quot;express-ws&quot;)// 将webSocket服务混入app，相当于为app添加.ws方法ws(app) 3、启动服务 12345678910111213141516171819202122232425//为了获取到所以的客户端const wss = ws(app).getWss(&#x27;/&#x27;)// 建立webSocket服务app.ws(&#x27;/&#x27;, (ws, req) =&gt; &#123; console.log(&quot;连接成功！&quot;); // send给客户端发消息 // on是监听事件 // message表示服务端传来的数据 ws.on(&quot;message&quot;, (msg) =&gt; &#123; // 给所有的客户端广播消息 wss.clients.forEach((e) =&gt; &#123; e.send(msg) &#125;) &#125;) // close 事件表示客户端断开连接时执行的回调函数 ws.on(&#x27;close&#x27;, function (e) &#123; console.log(&#x27;close connection&#x27;) &#125;) &#125;)app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 此时服务已经在3002端口跑起来了 前端接收消息1、vue中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;script&gt; //连接webSocketconst ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)export default &#123; data () &#123; return &#123; msg: &#x27;&#x27;, msgList: [] &#125; &#125;, mounted () &#123; // 绑定webSocket事件 //连接成功的回调 ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) //关闭的回调 ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) //连接错误的回调 ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) //接收发送消息的回调 ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125;, methods: &#123; sendMessage () &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = window.sessionStorage.getItem(&#x27;nickname&#x27;) const msg = JSON.stringify(&#123; msg: this.msg, name: name, date: date, left: true &#125;) ws.send(msg) // 发送完清空聊天框 this.msg = &#x27;&#x27; &#125;, handleWsOpen () &#123; console.log(&#x27;聊天已经启动！&#x27;) &#125;, handleWsClose () &#123; console.log(&#x27;聊天已经关闭！&#x27;) &#125;, handleWsError () &#123; console.log(&#x27;聊天出错！&#x27;) &#125;, // 收发消息 handleWsMessage (e) &#123; console.log(e) const msg = JSON.parse(e.data) this.msgList.push(msg) &#125; &#125;&#125;&lt;/script&gt; 2、react中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)class Chat extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &quot;&quot;, msgList:[] &#125; &#125; componentDidMount () &#123; ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125; sendMessage = ()=&gt; &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = &quot;客服&quot; const msg = JSON.stringify(&#123; msg: this.state.msg, name: name, date: date, left: false &#125;) ws.send(msg) // 发送完清空聊天框 this.setState(&#123; msg:&quot;&quot; &#125;) &#125; handleWsOpen () &#123; message.success(&quot;连接成功&quot;) &#125; handleWsClose () &#123; message.info(&quot;聊天结束&quot;) &#125; handleWsError () &#123; message.error(&quot;连接失败&quot;) &#125; // 收发消息 handleWsMessage (e) &#123; const msg = JSON.parse(e.data) let arr = this.state.msgList arr.push(msg) this.setState(&#123; msgList:arr &#125;) &#125; render () &#123; const msgList = this.state.msgList return ( &lt;Content className=&quot;site-layout-background&quot; &gt; &lt;div className=&quot;chatBox&quot;&gt; &lt;div className=&quot;chat&quot;&gt; &#123;/* 展示消息 */&#125; &lt;div className=&quot;chat-info&quot;&gt; &#123;msgList.map((item, k) =&gt; &#123; return &lt;div className=&quot;info-detail&quot;&gt; &lt;div className=&#123;item.left?&#x27;head-a&#x27;:&#x27;head&#x27;&#125;&gt; &lt;span className=&#123;item.left?&#x27;name-a&#x27;:&#x27;name&#x27;&#125;&gt;&#123;item.name&#125;&lt;/span&gt; &lt;span&gt;&#123;item.date&#125;&lt;/span&gt; &lt;/div&gt; &lt;div className=&#123;item.left?&#x27;info-main-a&#x27;:&#x27;info-main&#x27;&#125;&gt; &lt;span&gt;&#123;item.msg&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#125;) &#125; &lt;/div&gt; &#123;/* 发送消息 */&#125; &lt;div className=&quot;send-msg&quot;&gt; &lt;Input value=&#123;this.state.msg&#125; onChange=&#123;(e) =&gt; &#123; this.setState(&#123; msg:e.target.value &#125;) &#125;&#125; placeholder=&quot;请输入...&quot; style=&#123;&#123; width: &quot;350px&quot;, marginRight: &quot;10px&quot; &#125;&#125; onPressEnter=&#123;() =&gt; &#123; this.sendMessage() &#125;&#125; &gt; &lt;/Input&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; &#123; this.sendMessage() &#125;&#125;&gt; 发送 &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Content &gt; ) &#125;&#125; 效果如下： vue全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;template&gt; &lt;div class=&quot;chat&quot;&gt; &lt;div class=&quot;chat-box&quot;&gt; &lt;div class=&quot;chat-info&quot;&gt; &lt;div class=&quot;info-detail&quot; v-for=&quot;(item,k) in msgList&quot; :key=&quot;k&quot;&gt; &lt;div :class=&quot;item.left?&#x27;head&#x27;:&#x27;head-a&#x27;&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;item.date&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div :class=&quot;item.left?&#x27;info-main&#x27;:&#x27;info-main-a&#x27;&quot;&gt; &lt;span&gt;&#123;&#123;item.msg&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;chat-message&quot;&gt; &lt;el-input v-model=&quot;msg&quot; placeholder=&quot;请输入内容&quot; @keyup.enter.native=&quot;sendMessage&quot; &gt; &lt;el-button slot=&quot;append&quot; type=&quot;primary&quot; @click=&quot;sendMessage&quot; &gt;发送&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const ws = new WebSocket(&#x27;ws://localhost:3002&#x27;)export default &#123; data () &#123; return &#123; msg: &#x27;&#x27;, msgList: [] &#125; &#125;, mounted () &#123; // 绑定webSocket事件 ws.addEventListener(&#x27;open&#x27;, this.handleWsOpen.bind(this), false) ws.addEventListener(&#x27;close&#x27;, this.handleWsClose.bind(this), false) ws.addEventListener(&#x27;error&#x27;, this.handleWsError.bind(this), false) ws.addEventListener(&#x27;message&#x27;, this.handleWsMessage.bind(this), false) &#125;, methods: &#123; sendMessage () &#123; const currentY = new Date().getFullYear() let currentM = new Date().getMonth() + 1 let currentD = new Date().getDate() let currentH = new Date().getHours() let currentMin = new Date().getMinutes() let currentS = new Date().getSeconds() if (currentM &lt; 10) &#123; currentM = `0$&#123;currentM&#125;` &#125; if (currentD &lt; 10) &#123; currentD = `0$&#123;currentD&#125;` &#125; if (currentH &lt; 10) &#123; currentH = `0$&#123;currentH&#125;` &#125; if (currentMin &lt; 10) &#123; currentMin = `0$&#123;currentMin&#125;` &#125; if (currentS &lt; 10) &#123; currentS = `0$&#123;currentS&#125;` &#125; const date = `$&#123;currentY&#125;-$&#123;currentM&#125;-$&#123;currentD&#125; $&#123;currentH&#125;:$&#123;currentMin&#125;:$&#123;currentS&#125;` const name = window.sessionStorage.getItem(&#x27;nickname&#x27;) const msg = JSON.stringify(&#123; msg: this.msg, name: name, date: date, left: true &#125;) ws.send(msg) // 发送完清空聊天框 this.msg = &#x27;&#x27; &#125;, handleWsOpen () &#123; console.log(&#x27;聊天已经启动！&#x27;) &#125;, handleWsClose () &#123; console.log(&#x27;聊天已经关闭！&#x27;) &#125;, handleWsError () &#123; console.log(&#x27;聊天出错！&#x27;) &#125;, // 收发消息 handleWsMessage (e) &#123; console.log(e) const msg = JSON.parse(e.data) this.msgList.push(msg) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chat &#123;padding: 100px 300px 0 300px;display: flex;justify-content: center;.chat-box&#123;margin-top: 20px;padding: 10px 10px 10px 10px;width: 400px;height: 600px;background-color: #fff;border-radius: 10px 10px 0 0 ;.chat-info&#123; height: 550px; overflow: auto; .info-detail&#123; margin-bottom: 5px; .head&#123; width: 100%; margin-bottom: 5px; display:flex; flex-direction: row-reverse; .name&#123; margin-left: 5px; color: rgb(240, 74, 74); &#125; &#125; .head-a&#123; width: 100%; margin-bottom: 5px; .name&#123; margin-right: 5px; color: rgb(22, 189, 240); &#125; &#125; .info-main-a&#123; font-size: 18px; font-family: 楷体; &#125; .info-main&#123; font-size: 18px; font-family: 楷体; display:flex; flex-direction: row-reverse; &#125; &#125;&#125;.chat-message&#123; height: 50px;&#125;&#125;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"webSocket","slug":"webSocket","permalink":"https://gitee.com/shimmer612/myBlog/tags/webSocket/"}]},{"title":"最近遇到的一些知识点","slug":"2021-04-07-最近遇到的一些知识点","date":"2021-04-06T16:00:00.000Z","updated":"2021-04-07T06:18:26.948Z","comments":true,"path":"2021/04/07/2021-04-07-最近遇到的一些知识点/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/07/2021-04-07-%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"判断一个数组是否为空12345const arr = []if(arr.length===0) &#123; console.log(&quot;改数组是空数组&quot;)&#125; 判断一个数组里是否有重复值1234567891011121314//循环添加到一个对象里，判断对象里是否有这个值var arr = [&quot;1111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;111&quot;, &quot;222&quot;]function isRepeat(arr) &#123; var hash = &#123;&#125;; for (var i in arr) &#123; if (hash[arr[i]]) &#123; console.log(arr[i] + &quot;重复了&quot;) &#125; hash[arr[i]] = &quot;have&quot;; &#125; console.log(hash); return false;&#125;isRepeat(arr) 两个对应的数组，删除对应值比如一个数组是[1,0,0,1,0,1,0,1,0,0]另外一个数组是[a,b,c,d,e,f,g,h,i,j],要删除后一个数组中对应前一个数组为1的元素。 我一开始想的是用找出第一个数组中元素1相对于的index然后用splice删除后一个数组中对应的项。 但是删除一次后，数组的长度就发生了改变，因为splice方法会改变原数组第二个splice删除的就不是正确的了。正确做法应该是删除的时候，往删除的地方添加一个空值，删除完后，删除这个空值。 1234567891011121314151617const a = [1,0,0,1,0,1,0,1,0,0]const b = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;]a.map((k,i)=&gt;&#123; if(k===1) &#123; b.splice(i,1,&quot; &quot;) &#125;&#125;)let c = []b.map((k,i)=&gt;&#123; if(k !== &quot; &quot;)&#123; c.push(k) &#125;&#125;)console.log(c) //[ &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;i&#x27;, &#x27;j&#x27; ]//c数组就是最后的数组","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"react类组件的数据顺序","slug":"2021-04-02-react类组件的数据顺序","date":"2021-04-01T16:00:00.000Z","updated":"2021-04-02T04:00:31.357Z","comments":true,"path":"2021/04/02/2021-04-02-react类组件的数据顺序/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/04/02/2021-04-02-react%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"昨日昨天写代码的时候，父组件通过props传值给子组件。我在子组件中在ComponentDidMount中用setState赋值render中拿不到。 代码如下 123456789101112131415161718192021class useDetail extends Component &#123; constructor(props) &#123; super(props) this.props = props this.state = &#123; useInfo: null &#125; &#125; componentDidMount () &#123; this.setState(&#123; useInfo:this.props.UseInfo &#125;) &#125; render() &#123; //拿不到值 const useInfo = this.state.useInfo const strategy = useInfo &amp;&amp; useInfo.strategy ? JSON.parse(useInfo.strategy.discountStrategy) : [] &#125; 这样就能获取到值，render在componentDidMount之前,所以值为undefined,传入的值可以直接放在state中赋值。 123456789101112class useDetail extends Component &#123; constructor(props) &#123; super(props) this.props = props this.state = &#123; useInfo: this.props.UseInfo &#125; &#125; render() &#123; const useInfo = this.state.useInfo const strategy = useInfo &amp;&amp; useInfo.strategy ? JSON.parse(useInfo.strategy.discountStrategy) : []&#125; over~","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"}]},{"title":"react hooks理解","slug":"2021-03-25-react-hooks理解","date":"2021-03-24T16:00:00.000Z","updated":"2021-03-25T05:50:55.167Z","comments":true,"path":"2021/03/25/2021-03-25-react-hooks理解/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/25/2021-03-25-react-hooks%E7%90%86%E8%A7%A3/","excerpt":"","text":"在函数式组件中发现了这样的一个问题，代码如下。按理说1处打印出来的isShow应该为true可是却是false 2处打印出来的是true 12345678910111213const demo = ()=&gt; &#123; const [isShow, setIsShow] = useState(false) //2console.log(isShow) return ( &lt;button onClick=&#123;()=&gt;&#123; setIsShow(true) //1 console.log(isShow) &#125;&#125;&gt;新增&lt;/button&gt; )&#125; 去百度了一些资料。 原来函数式组件每次更新的时候都会重新执行一次函数，此时 1处打印的isShow其实是初始的状态的旧值。形成了闭包。 2处外层能打印出来，是因为函数每次更新都要执行。 只有用useEffect才能获取到,绑定isShow为依赖。可以这样写: 123456789101112131415161718const demo = ()=&gt; &#123; const [isShow, setIsShow] = useState(false)useEffect(()=&gt;&#123; console.log(isShow)&#125;,[isShow]) //2console.log(isShow) return ( &lt;button onClick=&#123;()=&gt;&#123; setIsShow(true) //1 console.log(isShow) &#125;&#125;&gt;新增&lt;/button&gt; )&#125; hooks是有序的，会被react从上到下依次读取，所以不能在条件中使用，这样会导致解析的时候前后声明顺序不一致。hooks必须放在函数内部顶层。","categories":[],"tags":[{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"react hooks useEffect的使用","slug":"2021-03-24-react-hooks-useEffect的使用","date":"2021-03-23T16:00:00.000Z","updated":"2021-03-24T05:47:33.481Z","comments":true,"path":"2021/03/24/2021-03-24-react-hooks-useEffect的使用/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/24/2021-03-24-react-hooks-useEffect%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"useEffect的tipsuseEffect的语法： 123useEffect(()=&gt;&#123;//逻辑&#125;,[]) 如果没有第二个空数组参数，useEffect就会在页面状态改变的时候执行，加了空数组参数，只会在页面mount的时候更新一次。 传第二个参数：可以用作页面数据初始化 不传第二个参数 按照useEffect的这个在页面状态变化的时候调用的特性，可以做很多东西。 可以每次数据变化的时候，把数据传给后台，相当于监听。 分数变化的时候打印当前得了多少分。 12345678910111213141516171819202122232425262728import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main = () =&gt; &#123; const [count, setCount] = useState(0); // 相当于componentDidMount和componentDidUpdate useEffect(() =&gt; &#123; // 打印点击的次数 console.log(`当前得分为$&#123;count&#125;`) &#125;) return ( &lt;div&gt; &lt;h1 onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;当前得分为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#x27;root&#x27;)); useEffect 不应该返回任何内容但是使用async await 会返回一个隐式的promise 1234//这样写是错误的useEffect(async()=&gt; &#123; await ...... &#125;) 应该把async await 写在useEffect里面，如： 12345678//应该这样写useEffect(()=&gt; &#123; async () =&gt; &#123; await..... &#125; &#125;,[]) 今天就记录到这，马上我把react-redux在复习一下。好久不用都忘的差不多了。","categories":[],"tags":[{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"}]},{"title":"杂记02","slug":"2021-03-22-杂记02","date":"2021-03-21T16:00:00.000Z","updated":"2021-03-22T09:28:12.629Z","comments":true,"path":"2021/03/22/2021-03-22-杂记02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/22/2021-03-22-%E6%9D%82%E8%AE%B002/","excerpt":"","text":"今天也没学什么新东西，但是博客总要点新的东西吧。就随便写一点吧。 今天想给自己的在线购物商城加一个客服聊天功能。百度了下用socket.io可以实现，但是自己折腾了半天也没有成功，就放弃了。 不过给订单页面加了一个快递查询的功能，用的假数据，点击直接返回一串快递信息，是我自己淘宝买东西的物流信息。用element-ui的TimeLine实现的。 其实想了很多功能，却不知道怎么实现，比如点击付款按钮，跳出来一个二维码，扫描二维码，跳转到订单页面，没有找到什么插件可以监听二维码的扫描事件。用的qrimage只能生成二维码，扫描跳转到设置特定的页面。 痛点很多，要学习的东西也很多。 总感觉自己不是一个合格的前端。 不务正业去学了后台。写了几个接口学了mongo,也满足自己平时写写小项目自己写后台了。也挺不错的。express真的挺香的。 昨天去滆湖公园放了风筝，很开心。和高中同学聊聊天散散步真的很愉快。 还是没事多出去走一走，呼吸呼吸新鲜的空气。 整个人的精神会好很多。 看着漫天的飞翔的风筝，抽芽的柳树，盛开的油菜花和家乡的Sakura。 那时候之前所有的烦闷与苦痛全部抛在脑后。 真好！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"创建一个vue3.0+element-plus项目","slug":"2021-03-20-创建一个vue3.0+element-plus项目","date":"2021-03-19T16:00:00.000Z","updated":"2021-03-20T06:15:27.903Z","comments":true,"path":"2021/03/20/2021-03-20-创建一个vue3.0+element-plus项目/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/20/2021-03-20-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAvue3.0+element-plus%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"创建一个vue3.0+element-plus项目首先要确认自己电脑中的@vue/cli&gt;4.5 可以用vue -V查看 没有的话可以用npm i -g @vue/cli升级 升级成功后 **vue create my-pro**这里选择Vue 3的项目。 创建成功后。 执行下面的命令。 12cd my-provue add element-plus 全局加载和按需加载自己选择。 安装成功后。 npm run serve 发现项目跑起来了。 按需加载的话，需要在src/plugins/element.js文件里，引入自己所需要的组件就可以了。 1234567import &#123; ElButton,ElTimeline &#125; from &#x27;element-plus&#x27;export default (app) =&gt; &#123; app.use(ElButton) app.use(ElTimeline)&#125;","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"}]},{"title":"Vue3中路由的相关配置","slug":"Vue3中路由的相关配置","date":"2021-03-15T16:00:00.000Z","updated":"2021-03-17T01:25:00.647Z","comments":true,"path":"2021/03/16/Vue3中路由的相关配置/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/16/Vue3%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Vue3中路由的相关配置1、路由的配置在src路径下新建router文件夹，然后在该文件夹新建index.js文件 安装vue-router 1cnpm i vue-router@next --save index.js文件配置如下。 12345678910111213141516171819202122232425262728import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const addCount = () =&gt; import(&#x27;../components/addCount.vue&#x27;)const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/add&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, &#125;, &#123; path: &quot;/add&quot;, component: addCount &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router 然后配置main.js 引入router 1234567891011121314151617import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./index.css&#x27;//使用router//引入elementPlusimport ElementPlus from &#x27;element-plus&#x27;;import &#x27;element-plus/lib/theme-chalk/index.css&#x27;;//引入routerimport router from &#x27;./router/index&#x27;const app = createApp(App)//使用ElementPlusapp.use(ElementPlus)//使用routerapp.use(router)app.mount(&#x27;#app&#x27;) 2、路由的跳转方式一 引入useRouter 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter&#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const changeRouter = () =&gt; &#123; router.push(&#x27;/father&#x27;) &#125; return &#123; changeRouter &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 方式二router-link 1&lt;router-link to=&quot;/child&quot;&gt;子页面&lt;/router-link&gt; 方式三 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;toAdd&quot;&gt;下一页&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from &#x27;../router/index.js&#x27;export default &#123; methods: &#123; toAdd() &#123; router.push(&#x27;/add&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3、路由的传参引入useRoute 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const route = useRoute() const changeRouter = () =&gt; &#123; router.push(&#123; path: &#x27;/father&#x27;, query: &#123; name: &#x27;zz&#x27;, &#125;, &#125;) &#125; return &#123; changeRouter &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 如下图：在father页面就可以通过route.query.name获取到”zz” 4、路由的嵌套通过router-view和子路由的方式嵌套 router/index.js 123456789101112131415161718192021222324252627282930import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const children = () =&gt; import(&#x27;../components/child.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/father&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, children: [ &#123; path: &#x27;/child&#x27;, component: children &#125; ] &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router father.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h&quot;&gt;我是爷爷&lt;/h1&gt; &lt;br /&gt; &lt;router-link to=&quot;/child&quot;&gt;下一页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; child.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;hr&gt; &lt;h1&gt;我是儿子&lt;/h1&gt; &lt;/div&gt; &lt;Sunzi /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sunzi from &#x27;./sunzi.vue&#x27;export default &#123; components: &#123; Sunzi, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行如下图所示：","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"如何在vue的css中使用data中的变量","slug":"如何在vue的css中使用data中的变量","date":"2021-03-14T16:00:00.000Z","updated":"2021-03-16T02:54:26.599Z","comments":true,"path":"2021/03/15/如何在vue的css中使用data中的变量/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/15/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E7%9A%84css%E4%B8%AD%E4%BD%BF%E7%94%A8data%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/","excerpt":"","text":"如何在vue的css中使用data中的变量。 很简单用v-bind 一个简单的例子 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; &gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; color: &#x27;red&#x27;, &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行如下图所示：成功设置了文字的颜色。 这样就可以做一个文字颜色不断变化的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; @click=&quot;changeColor&quot;&gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeColor&quot;&gt;变色&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; Child, &#125;, data() &#123; return &#123; color: &#x27;red&#x27;, count: 1, &#125; &#125;, created () &#123; setInterval(()=&gt;&#123; this.changeColor() &#125;,500) &#125;, methods: &#123; changeColor() &#123; const arr = [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;black&#x27;, &#x27;hotpink&#x27;, &#x27;purple&#x27;, &#x27;lime&#x27;, &#x27;skyblue&#x27;, ] this.color = arr[this.count] this.count++ if (this.count === 8) &#123; this.count = 0 &#125; &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行结果如下图： 是不是感觉要方便许多。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"CSS的一些知识点","slug":"2021-03-12-CSS的一些知识点","date":"2021-03-11T16:00:00.000Z","updated":"2021-03-12T08:32:26.410Z","comments":true,"path":"2021/03/12/2021-03-12-CSS的一些知识点/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/12/2021-03-12-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"今天是三月十二日植树节，记录一些自己写样式的时候，以前不知道的东西。 1、设置padding的时候为了不改变盒子的大小要设置box-sizing:border-box 2、盒子内部阴影在末尾加一个inset比如box-shadow: 0 0 5px 0 red inset 3、设置透明度的时候opacity:0.8这样会让父元素子元素也改变透明度。可以改成rgba(255,255,255,0.8)的这种方式 4、网页字体最小就是12px 5、设置背景图时使用路径时 background-image: url(~@/assets/carMonitor/warn-info.png);写成这种样式。还有加上 background-size: cover; 不想写了，今天很难受，心情很不好。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"node.js+express+mongodb来开发后端","slug":"2021-03-10-node.js+express+mongodb来开发后端","date":"2021-03-10T16:00:00.000Z","updated":"2021-03-11T01:21:12.502Z","comments":true,"path":"2021/03/11/2021-03-10-node.js+express+mongodb来开发后端/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/11/2021-03-10-node.js+express+mongodb%E6%9D%A5%E5%BC%80%E5%8F%91%E5%90%8E%E7%AB%AF/","excerpt":"","text":"node.js+express+mongodb来开发后端大四临近毕业，要开始写毕业设计，但是作为前端的我，对后端一窍不通。然后想到nodejs也可以写后端。用的就是javascript。应该学习成本不是很高。 如今已经写好了毕设。但是对当时怎么用nodejs+express+mongodb写接口有点遗忘了。 今天来记录一下。以便后面来复习和查找。 1、安装expressnpm install express --save 2、新建一个js文件123456789101112131415161718192021222324252627282930313233343536373839//引入express并绑定到app上const express = require(&#x27;express&#x27;)const app = express()// 静态资源路径app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;))// 跨域app.use(require(&#x27;cors&#x27;)())// express 处理jsonapp.use(express.json())// 接口的开发app.use(&#x27;/&#x27;,require(&#x27;./router/user&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/address&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/admin&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/banner&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/cat&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goods&#x27;))// app.use(&#x27;/&#x27;,require(&#x27;./router/hotGoods&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/order&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/shopcart&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/star&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/upload&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goodsBuyCount&#x27;))// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 3、mongoose的使用安装mongoose npm i mongoose --save 新建一个js文件 123456789101112131415161718//引入mongooseconst mongoose = require(&#x27;mongoose&#x27;)// 连接数据库mongoose.connect(&#x27;mongodb://localhost:27017/storedb&#x27;, &#123; useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true&#125;)//创建数据模型，类似于表const CateSchema = new mongoose.Schema(&#123; //字段名称与字段类型 还可以加一些判断。required:true代表必传，unique 代表唯一的 cat_id: &#123; type:Number &#125;, cat_name: &#123; type: String, required: true &#125;&#125;)//绑定到模型const Category = mongoose.model(&#x27;category&#x27;, CateSchema, &#x27;category&#x27;) 4、接口的实现这里直接使用express router 不直接用app.get()或者app.post()这样去使用了。 新建一个js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344//引入expressconst express = require(&#x27;express&#x27;);//引入mongoose数据模型const &#123; Address &#125; = require(&#x27;../storedb&#x27;)//绑定routerlet router = express.Router();// 获取用户地址router.get(&#x27;/getAddress&#x27;, async (req, res) =&gt; &#123; const address = await Address.find(&#123; user_id: req.query.user_id &#125;) res.send(address)&#125;)// 删除地址router.delete(&#x27;/deleteAddress&#x27;, async (req, res) =&gt; &#123; const address = req.query const userId = req.query.user_id await Address.deleteOne(&#123; user_id: userId, add_id: address.add_id &#125;) res.send(&#123; message: &quot;删除地址成功！&quot; &#125;)&#125;)// 修改地址router.post(&#x27;/changeAddress&#x27;, async (req, res) =&gt; &#123; const address = req.body const addId = req.body.add_id await Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) res.send(&#123; message: &quot;修改地址成功！&quot; &#125;)&#125;)//导出module.exports = router 一般查询用get 增加修改用post 删除用delete 说一下mongoose的增删改查 增加 Address代表表名 里面是增加的一个地址， 123456Address.create(&#123; user_id: 1234, add_id: 123, user_name: &quot;zz&quot;, user_phone: 123456789, user_address: &quot;大道&quot; &#125;) 删除 删除user_id中add_id为123的那个地址 Address.deleteOne(&#123; user_id: 1234, add_id: 123 &#125;) 修改 修改第一个参数是修改哪一个，查找条件。add_id为多少的哪一个。 第二个参数为修改后的数据 12345Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) 查询 12345//查询所有的Address.find()//查询user_id为123的所有地址Address.find(&#123;user_id:123&#125;) mongoose的一些常用查询参数 1234567//skip查询的时候跳过多少个//limit限制一次查询几个//sort是排序 1是正序-1是倒序// skip(), limit(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 const goods = await Goods.find().limit(pageSize).skip((pageNum - 1) * pageSize).sort(&#123; goods_id: 1 &#125;) 12//$in 查询goods_id为$in后面的数组const aa = await Goods.find(&#123; goods_id: &#123; $in: [1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125;) 123456789//$or 满足其中一个条件就可以//$regex 匹配查询const data = await Goods.find(&#123; $or: [ &#123; goods_name: &#123; $regex: reg &#125; &#125;, &#123; goods_title: &#123; $regex: reg &#125; &#125;, &#123; goods_subtitle: &#123; $regex: reg &#125; &#125; ] &#125;) 123456789101112131415161718192021222324//aggregate聚合查询//$lookup 两个表关联查询//下面的意思是根据cat_id在goods表中查询，查询到的数据放到goods这个字段下。const index = req.params.categoryId - 1 await Category.aggregate([ &#123; $lookup: &#123; from: &quot;goods&quot;, localField: &quot;cat_id&quot;, foreignField: &quot;cat_id&quot;, as: &quot;goods&quot;, &#125; &#125;,&#123;$sort:&#123;&quot;cat_id&quot;:1&#125;&#125; ] , (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; res.send(data[index]) &#125; )&#125;) 5、上传文件12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require(&#x27;express&#x27;);var formidable = require(&#x27;formidable&#x27;);fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const &#123; Goods &#125; = require(&#x27;../storedb&#x27;)let router = express.Router();router.post(&#x27;/uploadImg&#x27;, (req, res, next) =&gt; &#123; const goods = req.query let form = new formidable.IncomingForm(); form.encoding = &#x27;utf-8&#x27;; // 编码 // 保留扩展名 form.keepExtensions = true; //文件存储路径 最后要注意加 &#x27;/&#x27; 否则会被存在public下 form.uploadDir = path.join(__dirname, &#x27;../public/imgs/accessory/&#x27;) form.parse(req, (err, fields, files) =&gt; &#123; if (err) throw err let oldFilename = files.file.name fs.rename(files.file.path, form.uploadDir + generateFilename(oldFilename), async err =&gt; &#123; if (err) &#123; console.log(&quot;重命名失败&quot;); &#125; else &#123; await Goods.updateOne(&#123; goods_id: goods.goods_id &#125;, &#123; goods_pic: `public/imgs/accessory/$&#123;generateFilename(oldFilename)&#125;`, &#125;) &#125; &#125;) res.send(&#123; message: &quot;保存成功！&quot; &#125;) &#125;) function generateFilename(oldFilename) &#123; //将老的文件名拼上时间戳，这样既不会命名冲突又可以看出文件的上传事件 let d = new Date(); let names = oldFilename.split(&quot;.&quot;); return `$&#123;names[0]&#125;_$&#123;&quot;&quot; + d.getFullYear() + (d.getMonth() + 1) + d.getDate() + &#x27;_&#x27; + d.getHours() + d.getMinutes() + d.getSeconds()&#125;.$&#123;names[1]&#125;`; &#125;&#125;); 6、启动在项目根目录打开终端运行node app.js 12345678//出现 success in port 3002，服务已经跑起来啦 //因为上面是这样写的// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 说明运行成功。 7、调用接口12345678910111213141516171819202122232425262728 // 获取用户地址 async getAddress () &#123; const userId = window.sessionStorage.getItem(&#x27;userId&#x27;) const res = await this.$http.get(&#x27;getAddress&#x27;, &#123; params: &#123; user_id: userId &#125; &#125;) this.address = res.data &#125;,//请求地址Request URL: http://localhost:3002/getAddress?user_id=1255Request Method: GETStatus Code: 200 OKRemote Address: [::1]:3002Referrer Policy: strict-origin-when-cross-origin//返回相应的数据[&#123; &quot;_id&quot;:&quot;602e26a4a8185949dc9ea23e&quot;, &quot;user_id&quot;:&quot;1255&quot;, &quot;add_id&quot;:&quot;157&quot;, &quot;user_name&quot;:&quot;wky&quot;, &quot;user_phone&quot;:&quot;18888888888&quot;, &quot;user_address&quot;:&quot;无锡市滨湖区太湖学院北区&quot;, &quot;__v&quot;:0&#125;] 到这里基本上就完成了大部分的功能。 当然还有登录注册。jwt签名生成token，密码的加密等等。 这个我也忘记的差不多了。 去整理一下，再记录下来。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"}]},{"title":"从数组中取出随机几个数组成新数组（不重复取）","slug":"2021-03-10-从数组中取出随机几个数组成新数组（不重复取）","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-10T09:14:23.203Z","comments":true,"path":"2021/03/10/2021-03-10-从数组中取出随机几个数组成新数组（不重复取）/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/10/2021-03-10-%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E5%87%BA%E9%9A%8F%E6%9C%BA%E5%87%A0%E4%B8%AA%E6%95%B0%E7%BB%84%E6%88%90%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%96%EF%BC%89/","excerpt":"","text":"​ 要给自己的商城，加一个推荐商品的功能。想让他随机从商品表中取出4个数据。 ​ 一开始我用Math.random()*arr.length但是会取出相同的。这样就不太对，哪有推荐两个相同的商品呢。 ​ 然后想到获取当前选择的下标，把选择的那个删除。下一次随机，就随机不到那个数了。 123456789101112131415161718192021//前台传来的当前商品的idconst nowGoodsIndex = req.query.goods_id-1 const goods = await Goods.find() let arr = [] //存入数组的id,因为id就是从1开始往上加。 goods.forEach((element, index) =&gt; &#123; arr.push(index+1) &#125;); //用splice把当前商品的id删除避免重复 arr.splice(nowGoodsIndex, 1); let newArr = [] //随机取出4个，取出来一个就把那个数在数组中删掉。避免重复。 for (let i = 0; i &lt;= 3; i++) &#123; let index = Math.floor(Math.random() * arr.length); newArr.push(arr[index]); //获取后，在数组中删除已经加入的随机数 arr.splice(index, 1); &#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"CSS margin折叠","slug":"2021-03-09-CSS-margin折叠","date":"2021-03-08T16:00:00.000Z","updated":"2021-03-09T09:49:37.080Z","comments":true,"path":"2021/03/09/2021-03-09-CSS-margin折叠/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/09/2021-03-09-CSS-margin%E6%8A%98%E5%8F%A0/","excerpt":"","text":"margin折叠今天在写页面的时候发现，子元素设置了margin-top:101px不生效，父元素却向下移动了。 这就是margin折叠 12345678910111213141516171819202122232425262728 //这里给子元素设置margin-top//父元素却向下移动了101px&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;car-message&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;style&gt; .main &#123; width: 1440px; height: 810px; background-image: url(~@/assets/bg.png); background-size: cover; box-sizing: border-box; padding: 0 19px 0 17px;&#125;.car-message &#123; margin-top: 101px; background-image: url(~@/assets/one.png); background-size: cover; width: 1404px; height: 51px; display: flex; align-items: center;&#125;&lt;/style&gt; 百度了下 外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。 解决办法兄弟间重叠时 底部元素变为行内盒子(display: inline-block); 底部元素的position的值为absolute/fixed 父元素与子元素重叠 父元素加入(overflow: hidden); 父元素添加透明边框(border:1px solid transparent); 子元素变为行内盒子(display: inline-block); 子元素加入浮动属性或定位 这里我给父元素设置了overflow:hidden就解决了。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"react 中使用Swiper轮播图插件","slug":"2021-03-08-react-中使用Swiper轮播图插件","date":"2021-03-07T16:00:00.000Z","updated":"2021-03-09T05:15:36.072Z","comments":true,"path":"2021/03/08/2021-03-08-react-中使用Swiper轮播图插件/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/08/2021-03-08-react-%E4%B8%AD%E4%BD%BF%E7%94%A8Swiper%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6/","excerpt":"","text":"第一步、安装1npm i swiper 第二步、使用12345678910111213141516171819import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/react&#x27;;//根据自己的需要引用样式import &#x27;swiper/swiper.less&#x27;;export default () =&gt; &#123; return ( &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;3&#125; onSlideChange=&#123;() =&gt; console.log(&#x27;slide change&#x27;)&#125; onSwiper=&#123;(swiper) =&gt; console.log(swiper)&#125; &gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;/Swiper&gt; );&#125;; 到这一个轮播图就已经实现了，但是只是轮播图没有别的东西，比如左右的按钮。这些需要我们手动添加。 第三步、添加功能（例：navigation按钮）1234567891011121314//引入所需功能和样式文件import SwiperCore, &#123; Navigation &#125; from &quot;swiper&quot;;import &quot;swiper/components/navigation/navigation.less&quot;;//使用SwiperCore.use([Navigation]);// 组件上添加属性 &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;1&#125; navigation style=&#123;&#123; padding: &quot;24px&quot; &#125;&#125; &gt; 以上就是在react中使用swiper插件。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"}]},{"title":"react hooks学习","slug":"react hooks学习","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-23T07:16:48.075Z","comments":true,"path":"2021/03/05/react hooks学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/05/react%20hooks%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"react hooks学习01、什么是react hooksreact hooks就是react提供的内置函数，这些函数可以让，函数式组件和类组件一样拥有组件状态和副作用。 什么是状态？ React中的放数据的地方。 什么是副作用？ 在 React 组件中执行数据获取、订阅或者手动修改 DOM，我们统一把这些操作称为“副作用” 02、useStateuseState 就类似于类组件中的this.state useState的用法 12345678910111213141516171819202122import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0);return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getEementById(&#x27;root&#x27;)); 03、useEffectuseEffect就相当于生命周期的componentDidMount和componentDidUPdate 使用方法 12345678910111213141516171819202122232425262728293031import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0); // 相当于componentDidMount和componentDidUpdate //要加第二个参数空数组，不然会一直调用 useEffect(() =&gt; &#123; // 打印点击的次数 console.log( `You clicked $&#123;count/2&#125; times`) &#125;,[])return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#x27;root&#x27;));","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"javascript常用数组方法的复习","slug":"2021-03-04-javascript常用数组方法的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T04:00:22.334Z","comments":true,"path":"2021/03/04/2021-03-04-javascript常用数组方法的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-javascript%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"分析项目代码经常会看到一些数组方法，some,slice等等。概念都模糊不清，感觉知道又感觉不知道。还是要到W3C上去查一下用法。 所以这次把一些常用的数组方法整理一下，用来巩固复习 forEach()forEach() 对数组的每一项进行操作 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值undefined 1234567let arr = [1,2,3,4,5,6]let arr1 = []arr.forEach(item=&gt;&#123; arr1.push(item*2) &#125;)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ] filter()filter() 返回一个新数组，包含复合要求的所有元素 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：复合要求的新数组 123let arr = [1,2,3,4,5,6]let arr1 = arr.filter(item=&gt;item&gt;=3)console.log(arr1); //[ 3, 4, 5, 6 ] map()map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：原数组每个元素执行回调函数的结果组成的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.map(item=&gt;item*2)let arr2 = arr.map(item=&gt;item&gt;3)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ]console.log(arr2);//[ false, false, false, true, true, true ] slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 **begin 可选** 提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果省略 begin，则 slice 从索引 0 开始。 如果 begin 超出原数组的索引范围，则会返回空数组。 end 可选 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end） 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 被省略，则 slice 会一直提取到原数组末尾。 如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。 返回值：一个含有被提取元素的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.slice(2,4)let arr2 = arr.slice()console.log(arr1);//[ 3, 4 ]console.log(arr2);//[ 1, 2, 3, 4, 5, 6 ] find()find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [undefined] callback 函数接收3个值，item数组项，index元素下标，arr数组本身 数组中第一个满足所提供测试函数的元素的值，否则返回 [undefined] 123let arr = [1,2,3,4,5,6]let arr1 = arr.find(item=&gt;item&gt;4)console.log(arr1); //5 sort()sort()对数组的元素进行排序，并返回数组 如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 12345678910111213141516171819let arr = [5,4,3,2,1]let arr1 = arr.sort()console.log(arr1); //[ 1, 2, 3, 4, 5 ]let arr = [3,1,4,2,5,8,6,7]let arr3 = [3,1,4,2,5,8,6,7]let arr1 = arr.sort((a, b) =&gt; &#123; return a-b&#125;)console.log(arr1); //[ 1, 2, 3, 4, 5, 6, 7, 8 ]let arr2 = arr3.sort((a, b) =&gt; &#123; return b-a&#125;)console.log(arr2); //[ 8, 7, 6, 5, 4, 3, 2, 1 ] some()some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值： 数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false。 123456let arr = [1, 2, 3, 4, 5, 6]const aa = arr.some(item =&gt; item &gt; 5)const bb = arr.some(item =&gt; item &gt; 7)console.log(aa);//trueconsole.log(bb); //false every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：如果回调函数的每一次返回都为true，返回 true ，否则返回 false。 123456let arr = [2, 5, 6, 7, 8, 9]const aa = arr.every(item =&gt; item &gt; 3)const bb = arr.every(item =&gt; item &gt; 1)console.log(aa); //fasleconsole.log(bb); //true 差不多就是这些常用的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"扩展运算符(...)的复习","slug":"2021-03-04-扩展运算符(...)的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T01:39:59.558Z","comments":true,"path":"2021/03/04/2021-03-04-扩展运算符(...)的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6(...)%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"最近看项目代码，经常看到函数里运用扩展运算符。总是模模糊糊的，看明白又好像没有明白的感觉。 像下面这样 1234567891011121314151617181920212223 setCacheComponents([ ...cacheComponentsClone, &#123; ...currentPane, name: name || obj.item.props.children[1] // 如果调用addtab时传入了name则使用此name &#125; ]);//------------------------------------------------------------------------------------------ return &#123; ...state, tableData: [ ...state.tableData, &#123; params: &#123; ...payload.params, page: payload.page || 1, pageSize: payload.pageSize || 10 &#125;, tableKey: payload.tableKey, loading: true &#125; ] &#125; 就整理了一下扩展运算符的用法。 1234567891011121314151617181920212223242526272829// 浅拷贝const obj = &#123; name: &quot;张三&quot;, age: &quot;20&quot;, sex: &quot;男&quot;, hobby:&#123; play: &quot;ball&quot;, &#125;&#125;const newObj = &#123; ...obj&#125;console.log(newObj);//&#123; name: &#x27;张三&#x27;, age: &#x27;20&#x27;, sex: &#x27;男&#x27;, hobby: &#123; play: &#x27;ball&#x27; &#125; &#125;// 连接数组const arr = [1,2,3]const arr1 = [4,5,6]const newArr = [...arr,...arr1]console.log(newArr); //[ 1, 2, 3, 4, 5, 6 ]// 字符串转换成数组const str = &#x27;abcdefg&#x27; const newStr = [...str]console.log(newStr); //[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;g&#x27;]// 解构赋值 数组对象都可以const aa = [1,2,3]const bb = [...aa,4,5,6]console.log(bb); //[ 1, 2, 3, 4, 5, 6 ] 项目里常用的就是在函数里，用来解构赋值的比较多","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"一些小记录","slug":"小记","date":"2021-03-02T16:00:00.000Z","updated":"2021-03-03T08:17:17.395Z","comments":true,"path":"2021/03/03/小记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/03/%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"开发中写样式less中，最外层取一个不易重的类名，其余子元素类名写在里面 尽量不要写到margin负值 样式遵循设计图 图片名称起相关英文名 flex布局多使用space-around做分割，除非必须用space-between 类名过长用xx-xx这样写 页面起名大驼峰比如ChargeManage","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"}]},{"title":"React项目(UmiJS)中使用高德地图","slug":"2021-03-02-React项目(UmiJS)中使用高德地图","date":"2021-03-01T16:00:00.000Z","updated":"2021-03-02T01:21:36.707Z","comments":true,"path":"2021/03/02/2021-03-02-React项目(UmiJS)中使用高德地图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/02/2021-03-02-React%E9%A1%B9%E7%9B%AE(UmiJS)%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"React AMap这是一个基于 React 封装的高德地图组件. 文档地址 https://uiw.gitee.io/react-amap/#/ 01、安装npm install @uiw/react-amap --save 02、使用在文档左侧找到需要使用的例子。在右侧直接复制对应代码。按需进行修改。 03、例子（贝塞尔曲线的使用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; useState &#125; from &quot;react&quot;;import &#123; Map, APILoader, BezierCurve &#125; from &quot;@uiw/react-amap&quot;;const CarLine = () =&gt; &#123; const [show] = useState(true); const path = [// 每个弧线段有两种描述方式 [116.39, 39.91, 116.37, 39.91],// 起点 // 第一段弧线 [116.380298, 39.907771, 116.38, 39.90],// 控制点，途经点 // 第二段弧线 [116.385298, 39.907771, 116.40, 39.90],// 控制点，途经点// 弧线段有两种描述方式1 // 第三段弧线 [// 弧线段有两种描述方式2 [116.392872, 39.887391],// 控制点 [116.40772, 39.909252],// 控制点 [116.41, 39.89]// 途经点 ], // 第四段弧线 [116.423857, 39.889498, 116.422312, 39.899639, 116.425273, 39.902273] // 控制点，控制点，途经点，每段最多两个控制点 ]; const handleParams = (values) =&gt; &#123; return values &#125; return ( &lt;&gt; &lt;APILoader akay=&quot;a7a90e05a37d3f6bf76d4a9032fc9129&quot;&gt; &lt;div style=&#123;&#123; width: &quot;100%&quot;, height: &quot;600px&quot; &#125;&#125; &gt; &lt;Map zoom=&#123;14&#125; center=&#123;[116.397637, 39.900001]&#125;&gt; &lt;BezierCurve visiable=&#123;show&#125; path=&#123;path&#125; isOutline=&#123;true&#125; outlineColor=&quot;&quot; borderWeight=&#123;3&#125; strokeColor=&quot;red&quot; strokeOpacity=&#123;1&#125; strokeWeight=&#123;6&#125; // 线样式还支持 &#x27;dashed&#x27; strokeStyle=&quot;solid&quot; // strokeStyle是dashed时有效 strokeDasharray=&#123;[10, 10]&#125; lineJoin=&quot;round&quot; lineCap=&quot;round&quot; zIndex=&#123;50&#125; /&gt; &lt;/Map&gt; &lt;/div&gt; &lt;/APILoader&gt; &lt;/&gt; );&#125;export default CarLine","categories":[],"tags":[{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"}]},{"title":"对Ant-Design Table组件进行封装","slug":"2021-02-26-对Ant-Design-Table组件进行封装","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-09T05:15:22.392Z","comments":true,"path":"2021/02/26/2021-02-26-对Ant-Design-Table组件进行封装/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/2021-02-26-%E5%AF%B9Ant-Design-Table%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85/","excerpt":"","text":"Table组件封装页面, dataSource通过Modal中的获取的数据传过来，主要对columns进行封装。把一些常用的属性给暴露出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import &#123; connect &#125; from &quot;umi&quot;;import &#123; Spin, Table, Space, Popconfirm, Tooltip &#125; from &quot;antd&quot;;import CommonPagination from &quot;@/components/CommonPagination&quot;;import moment from &quot;moment&quot;;import &#123; formatNum &#125; from &quot;@/utils/utils&quot;const SearchForm = (&#123; tableConfig, tableData &#125;) =&gt; &#123; const tableItem = tableData.find((item) =&gt; item.tableKey === tableConfig.tableKey) || &#123;&#125;; const &#123; loading &#125; = tableItem; // 根据tablekey取到对应请求的loading状态 const dataSource = tableItem.data || []; const columns = tableConfig.columns.map(item =&gt; &#123; if (item.actionMap) &#123; item = &#123; ...item, render(res) &#123; // 生成action列表 const actionList = (item.actionMap || []).map((action, index) =&gt; &#123; switch (action.type) &#123; case &quot;href&quot;: if (action.render) &#123; return &lt;div key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.render(res)&#125;&lt;/div&gt; &#125; return &lt;a key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.text&#125;&lt;/a&gt; case &quot;confirm&quot;: return &lt;Popconfirm key=&#123;index&#125; title=&#123;&lt;div&gt;确认要执行&#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125;操作吗？&lt;/div&gt;&#125; onConfirm=&#123;() =&gt; &#123; if (action.onConfirm) &#123; action.onConfirm(res) &#125; &#125;&#125; onCancel=&#123;() =&gt; &#123; if (action.onCancel) &#123; action.onCancel(res) &#125; &#125;&#125; okText=&quot;确认&quot; cancelText=&quot;取消&quot; &gt; &#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125; &lt;/Popconfirm&gt; default: return &lt;span key=&#123;index&#125;&gt;未知类型，请检查&lt;/span&gt; &#125; &#125;); return &lt;Space size=&quot;middle&quot;&gt; &#123; actionList.map(action =&gt; action) &#125; &lt;/Space&gt; &#125; &#125; &#125; else if (item.numFormat) &#123; item = &#123; ...item, render(res) &#123; return formatNum(res, ...item.numFormat); &#125; &#125; &#125; else if (item.timeFormat) &#123; item = &#123; ...item, render(res) &#123; return res ? moment(res).format(item.timeFormat) : &quot;--&quot; &#125; &#125; &#125; else if (item.tipCol) &#123; const render = item.render; item = &#123; ...item, ellipsis: &#123; show: false &#125;, render(res) &#123; if (item.tipCol === false) &#123; return res &#125; if (item.tipCol === true) &#123; return ( &lt;Tooltip placement=&quot;topLeft&quot; title=&#123;render ? render(res) : res&#125;&gt; &lt;span&gt;&#123;render ? render(res) : res&#125;&lt;/span&gt; &lt;/Tooltip&gt; ) &#125; &#125; &#125; &#125; return item; &#125;) return ( &lt;Spin spinning=&#123;loading === true&#125;&gt; &lt;div style=&#123;&#123; marginTop: 24, padding: 24, background: &quot;#fff&quot; &#125;&#125;&gt; &lt;Table pagination=&#123;false&#125; columns=&#123;columns&#125; dataSource=&#123;dataSource || []&#125; scroll=&#123;&#123; x: &quot;max-content&quot; &#125;&#125; bordered /&gt; &lt;CommonPagination tableKey=&#123;tableConfig.tableKey&#125; /&gt; &lt;/div&gt; &lt;/Spin&gt; );&#125;;export default connect((&#123; global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(SearchForm); 分页封装页面 根据modal传过来的数据进行前台分页。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; connect &#125; from &quot;umi&quot;;import &#123; Pagination &#125; from &quot;antd&quot;;const styles = &#123; display: &quot;flex&quot;, justifyContent: &quot;flex-end&quot;, alignItems: &quot;center&quot;, backgroundColor: &quot;#fff&quot;, height: &quot;60px&quot;&#125;const CommonPagination = (props) =&gt; &#123; const &#123; dispatch, tableData, tableKey &#125; = props; const &#123; page: pageData, params &#125; = tableData.find(item =&gt; item.tableKey === tableKey) || &#123;&#125;; // 分页变化 const pageChange = (page) =&gt; &#123; dispatch(&#123; type: &quot;global/getTableData&quot;, payload: &#123; tableKey, params: &#123; page, &#125; &#125;, &#125;); &#125;; return ( &lt;div style=&#123;styles&#125;&gt; &#123;pageData &amp;&amp; ( &lt;Pagination total=&#123;pageData.total&#125; showTotal=&#123;() =&gt; `共计 $&#123;pageData.total&#125; 个`&#125; defaultCurrent=&#123;1&#125; showSizeChanger=&#123;false&#125; onChange=&#123;pageChange&#125; current=&#123;params.page&#125; /&gt; )&#125; &lt;/div&gt; );&#125;;export default connect((&#123;global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(CommonPagination); 使用 ### CommonTable（通用表格） 必传参数tableConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495tableConfig=&#123; tableKey:&#x27;tableKey&#x27;, // 必传 columns:[ // 必传 &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;, &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;, &#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ], &#125; ], config:&#123;&#125; // table的配置，与官方文档一致&#125;&lt;CommonTable tableConfig=&#123;tableConfig&#125; /&gt; 其中columns与官方文档配置一致，当有如下参数时会进行特殊处理： tipCol (文字过长省略,Tooltip上方提示) 12345678910111213141516171819columns: [ &#123; title: &quot;Address&quot;, dataIndex: &quot;address&quot;, width: 150, key: &quot;address&quot;, tipCol: true, &#125;,] true时开启false关闭 numFormat（时间格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;] numFormat[保留几位小数，是否进行千分位格式化]，numFormat[2,true]效果1234.567=&gt;1,234.57 timeFormat（日期格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;,] timeFormat:时间戳格式，格式化为指定格式 actionMap（操作栏） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ],&#125; actionMap的type用于决定操作类型，具体如下： href，text和render至少有一个，render优先级高于text。当只有text参数时，生成结果为&lt;a&gt;&#123;text&#125;&lt;/a&gt;。当有render时，生成结果为render的返回值。 confirm，用于操作前的确认。render与text的关系与href一致。","categories":[],"tags":[{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Vue3.0初探","slug":"vue3笔记","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-16T02:54:39.632Z","comments":true,"path":"2021/02/26/vue3笔记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/vue3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"✨ 官网地址官网文档：https://v3.cn.vuejs.org/ 一、vue3安装与项目创建【掌握】参考地址：https://www.vue3js.cn/docs/zh/guide/installation.html 准备工作：升级脚手架对于 Vue 3，你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli@next。要升级，你应该需要全局重新安装最新版本的 @vue/cli： 123yarn global add @vue/cli@next# ORnpm install -g @vue/cli@next 然后在 Vue 项目运行： 1vue upgrade --next 方式1：以原有vueCli脚手架创建创建项目： 1vue create demo 直接选择 Vue 3 Preview ，并回车，不考虑eslint问题。 然后执行： 123456# 进入目录cd demo# 用vscode打开当前目录code .# 运行项目yarn serve 方式2：vite创建12345678910111213npm init vite-app demo# 相当于npx create-vite-app demo# 安装后执行npm install# oryarn# 运行项目npm run dev# oryarn dev 创建项目并运行，会发现我们 npm run dev 后是秒开项目的，运行速度极快。 二、Composition API（组合式API）【掌握】 相当于 React Hooks 我们先使用以前vue2的方式实现一个累加： 12345678910111213141516171819&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; btnClick()&#123; this.count++; &#125; &#125;&#125;&lt;&#x2F;script&gt; 这套代码可以实现一个累加的效果，但如果以后我们想把这个组件中的 count 字段与 btnClick 单独拎出来管理，那就比较麻烦了，因为 count 和 btnClick 不在同一个方法内，很难抽离。 1、setupsetup有以下特性： 1、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的 2、setup函数是 Composition API（组合API）的入口 3、在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用 4、由于我们不能在 setup函数中使用 data 和 methods，所以Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined 5、setup函数只能是同步的不能是异步的 2、API - ref我们先来体验一下vue3怎么处理这个累加效果： 123456789101112131415161718192021&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;vue&#39;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, setup()&#123; const count &#x3D; ref(1); &#x2F;&#x2F; 此时我们使用ref指定count的默认值为1，因此上面data中的count会失效 let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#x2F;&#x2F; 修改ref中的值要用xxx.value &#125; return &#123;count, btnClick&#125; &#125;&#125; 此时如果我想单独管理这个累加效果，我就可以这么操作： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;btnClick&quot;&gt;累加&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; data()&#123; return &#123; // count: 0 // 一旦把setup中的代码抽离，return中对应的值要去掉，否则ref无效 &#125; &#125;, setup()&#123; // 函数调用后就会返回一个对象，因此我们直接return return clickCountFn() // 如果后期还想同时返回其他数据，可以将clickCountFn()的返回结果展开 // return &#123;...clickCountFn(), 其他数据&#125; &#125;&#125;// 封装一个函数，这样这块功能我们就能单独管理了function clickCountFn()&#123; const count = ref(1); let btnClick = () =&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;/script&gt; 3、API - reactive再来了解另一个API ： reactive函数和ref作用非常接近，但是它的参数是一个对象，我们可以在对象中定义其方法，而通过这个形式，就不需要再对其进行进行 .value 调用了。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;p&gt;姓名：&#123;&#123;obj.username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref, reactive&#125; from &#39;vue&#39;export default &#123; setup()&#123; &#x2F;&#x2F; 使用reactive let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; return &#123;...clickCountFn(), obj, btnClick1&#125; &#125;&#125;function clickCountFn()&#123; const count &#x3D; ref(1); let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;&#x2F;script&gt; 使用 reactive 生成的对象与 ref 生成的值都是响应式的。 这里可以看到我们在 html 中调用数据时，使用的是 obj.username ，那我们是否可以直接写 username 呢？答案是可以的，但这里需要注意： 由于reactive返回的对象本质上已经是一个Proxy对象，所以通过…扩展符号展开的属性，是无法进行响应式的 也就是说，如果这么写： 1return &#123;...clickCountFn(), ...obj, btnClick1&#125; 那么是无法实现的。 4、API - toRefs正确的写法应该是： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;!-- 无需obj.username，直接username即可 --&gt; &lt;p&gt;姓名：&#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 新增toRefs方法import &#123;ref, reactive, toRefs&#125; from &#39;vue&#39;export default &#123; setup()&#123; let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; &#x2F;&#x2F; 通过toRefs方法 let refObj &#x3D; toRefs(obj); &#x2F;&#x2F; 通过...refObj将数据扩展 return &#123;...clickCountFn(), ...refObj, btnClick1&#125; &#125;&#125;&#x2F;&#x2F; 其他代码...&lt;&#x2F;script&gt; 三、Provide与Inject（提供/注入）【掌握】1、Vue2写法以往我们的父传子是通过props传的： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child :num&#x3D;&quot;num&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; data()&#123; return &#123; num: 123 &#125; &#125;, components: &#123; Child &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 这个时候限制死了数据必须来自父组件，我们其实还有 Provide 和 Inject ： 123456789101112131415161718192021222324252627&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, provide: &#123; num: 456 &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; Provide/Inject 相比于 props 的好处在于： 如果组件嵌套较多，那么 props 需要一级一级往下传递，后期很难维护。Provide+Inject 相当于是跨级组件传值，比如孙子组件也想用上面这个 num 的值，就不用一级一级往下传，直接在孙子组件使用即可： 1234567891011&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;num&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; &#x2F;&#x2F; 将Sun组件在Child组件中引入，即可实现跨级组件传值 inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 2、Vue3写法vue3中的 provide/inject。两者都只能在当前活动实例的 setup() 期间调用。 格式为： 123456789101112131415161718// provideimport &#123;provide&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup() &#123; // 此处name必须是String类型，value则不限制 provide(name, value) &#125;&#125;// injectimport &#123;inject&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup()&#123; // name即为传过来的字段，第二个参数可选，可填写默认值 const val = inject(name, defaultValue); return &#123;val&#125; &#125;&#125; 我们修改以上案例的代码： 1234567891011121314151617181920212223242526272829303132&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; provide(&#39;num&#39;, 789) &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;mynum&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;inject&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入export default &#123; setup()&#123; const mynum &#x3D; inject(&#39;num&#39;); return &#123;mynum&#125; &#125;&#125;&lt;&#x2F;script&gt; 3、响应性所谓的 Provide/Inject 响应性，其实就是把传递的值结合上文提及的 ref 或 reactive 一起使用： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt; &lt;button @click&#x3D;&quot;changeNumFn&quot;&gt;修改num&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide, ref&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; &#x2F;&#x2F; 使用ref来定义num的值 const num &#x3D; ref(123); &#x2F;&#x2F; 声明一个函数，专门用于修改num let changeNumFn &#x3D; () &#x3D;&gt; &#123; num.value &#x3D; 456; &#125; provide(&#39;num&#39;, num) &#x2F;&#x2F; 返回这个函数 return &#123;changeNumFn&#125; &#125;&#125;&lt;&#x2F;script&gt; 此时，当你点击按钮时，孙子组件接收到的 num 就会被修改了。 四、Teleport（传送门）【掌握】在vue2中，想要将子节点渲染到存在于父组件以外的 DOM 节点时，需要通过第三方库 portal-vue 去实现。而vue3中，Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术。 官方文档：《teleport》 举个最简单的例子： 我们在 index.html 中 #app 同级的地方新增一个 #test 元素： 12&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; 由于vue的 main.js 中规定了打包出来的代码都放入 #app 中： 1createApp(App).mount(&#x27;#app&#x27;) 因此，你现在没有办法将代码放入 #test 中。此时，我们可以使用传送门： App.vue 中： 12345678910111213&lt;template&gt; &lt;Home &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;export default &#123; name: &#39;App&#39;, components: &#123; Home &#125;&#125;&lt;&#x2F;script&gt; Home.vue 中： 123456789&lt;template&gt; &lt;p&gt;这段话是渲染在#app中的&lt;&#x2F;p&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--1&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--2&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt;&lt;&#x2F;template&gt; 此时，你打开浏览器控制台，就可以看到第2、3个p标签已经被渲染到 #test 中。 备注： 1、标签身上都to属性，填写的是css选择器。 2、多个传送门书写时，会按照自上而下的顺序传送至另一个DOM元素。 五、Suspense（等待）【掌握】Suspense组件用于在等待某个异步组件解析时显示后备内容。 那我们什么时候需要使用异步组件呢？多了去了，比如： 在页面加载之前显示加载动画 显示占位符内容 处理延迟加载的图像 那么，让我们看看 Suspense 怎么使用，我们先来提一个需求： 在等待组件获取数据并解析时显示“玩命加载中…”之类的内容 OK，我们来写一个 Article.vue 组件： 12345678910111213141516171819&lt;template&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;export default&#123; async setup() &#123; let content &#x3D; ref(&#39;内容&#39;) content.value &#x3D; await new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 3秒后修改content resolve(&quot;你好世界&quot;); &#125;, 3000); &#125;) return &#123;content&#125; &#125;,&#125;&lt;&#x2F;script&gt; 用个 Home.vue 组件来调用它： 12345678910111213141516171819&lt;template &lt;Suspense&gt; &lt;template #default&gt; &lt;Article&gt;&lt;&#x2F;Article&gt; &lt;&#x2F;template&gt; &lt;template #fallback&gt; &lt;p&gt;玩命加载中...&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Suspense&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Article from &#39;.&#x2F;Article.vue&#39;export default &#123; components:&#123; Article &#125;&#125;&lt;&#x2F;script&gt; 可以看出，&lt;Suspense&gt; 中，包含了两个template标签，#default 定义了我们要写入的内容， #fallback 定义了我们要预显示的内容。 ⚠️ 注意： 作为template中的内容（即插槽），必须要有根元素。 六、Fragment（碎片）【了解】vue2中，如果你创建一个Vue组件，那么它只能有一个根节点。这意味着不能创建这样的组件： 1234&lt;template&gt; &lt;div&gt;你好&lt;&#x2F;div&gt; &lt;div&gt;世界&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 原因是代表任何Vue组件的Vue实例需要绑定到一个单一的DOM元素中。唯一可以创建一个具有多个DOM节点的组件的方法就是创建一个没有底层Vue实例的功能组件。 这情况同样存在于react，但react可以使用空标签 &lt;&gt;&lt;/&gt; 来包裹，或者是使用一个名为Fragment的虚拟元素： 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;你好&lt;/td&gt; &lt;td&gt;世界&lt;/td&gt; &lt;/React.Fragment&gt; ) &#125;&#125; 尽管Fragment看起来像一个普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。目前你可以在Vue 2中使用vue-fragments库来使用Fragments，而在Vue 3中，你直接使用就行了，无需引入任何库。 七、TreeShaking（消除未使用代码）【了解】TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。 文档参考：https://vue3js.cn/docs/zh/guide/migration/global-api-treeshaking.html#_2-x-%E8%AF%AD%E6%B3%95 举个例子： vue2中我们常使用 Vue.nextTick(()=&gt;&#123;&#125;) 来预操作DOM，但有时候我们不用这个 nextTick ，比如改用别的方式来代替（如setTimeout），那么项目打包时，vue 全局的 nextTick 就成为一个多余的代码，从而使你的项目打包体积变大。 在vue3中，官方团队重构了所有全局 API 的组织方式，让所有的 API 都支持了 TreeShaking。所以vue3中如果还想使用全局的 nextTick ，就需要引入： 12345import &#123; nextTick &#125; from &#x27;vue&#x27;; nextTick(() =&gt; &#123; // 和 DOM 有关的一些操作&#125;); 如果你在 Vue 3 中不引入而直接调用 Vue.nextTick() ，就会得到一个报错：undefined is not a function。 官方也给出了Vue 2.x 中的受此更改影响的全局 API： Vue.nextTick Vue.observable (用 Vue.reactive 替换) Vue.version Vue.compile (仅全构建) Vue.set (仅兼容构建) Vue.delete (仅兼容构建) 八、Performance（性能）【了解】vue3.0相对于vue2.0来说性能快1.2到1.5倍，主要原因如下： 1、diff方法优化 \u001dVue2 中的虚拟dom是进行全量的对比 Vue3 新增了静态标记（PatchFlag），只比对带有 PF 的节点，并且通过 Flag 的信息得知 当前节点要比对的具体内容。 2、静态提升 Vue2中无论元素是否参与更新, 每次都会重新创建, 然后再渲染 Vue3中对于不参与更新的元素, 会做静态提升, 只会被创建一次, 在渲染时直接复用即可 3、cacheHandlers 事件侦听器缓存 默认情况下onClick会被视为动态绑定, 所以每次都会去追踪它的变化 但是因为是同一个函数，所以没有追踪变化, 直接缓存起来复用即可 4、ssr渲染 当有大量静态的内容时候，这些内容会被当做纯字符串推进一个buffer里面， 即使存在动态的绑定，会通过模板插值嵌入进去。这样会比通过虚拟dmo来渲染的快上很多很多。 当静态内容大到一定量级时候，会用_createStaticVNode方法在客户端去生成一个static node， 这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。 九、Setup的生命周期【了解】组合式API需要在setup中使用，setup中含有的生命钩子与vue的大体一致： 具体参考：《setup生命周期钩子》 十、TypeScript支持【了解】vue3新增了对TS语法的支持。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"davJs学习02","slug":"umi中，davjs学习02","date":"2021-02-23T16:00:00.000Z","updated":"2021-02-24T07:30:24.443Z","comments":true,"path":"2021/02/24/umi中，davjs学习02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/24/umi%E4%B8%AD%EF%BC%8Cdavjs%E5%AD%A6%E4%B9%A002/","excerpt":"","text":"最近公司新项目用的UmiJs3.x，整个项目的数据，通过内置的Davjs来控制。 昨天自己分析了一下Davjs。但是脑海中的概念还是很模糊。今天再梳理一下。 第一步首先是在Models文件夹下创建一个JS文件 123456789101112131415161718192021222324252627282930313233const GlobalModel = &#123; //model的名称 namespace: &quot;global&quot;, state: &#123; //放数据的地方 user:&#123;&#125; &#125;, effects: &#123; // 异步获取数据，不能直接修改数据，需要通过put调用reducers的方法。 `其中call和普通是dva 提供的effect 函数内部的处理函数 call：执行异步函数， put：发出一个 Action，类似于 dispatch select获取数据，` *getTableData(&#123; payload &#125;, &#123; put, select, call &#125;) &#123; const tableList = yield select((state) =&gt; state.global.tableData); yield put(&#123; type: &quot;setTableParams&quot;, payload, &#125;); &#125;, reducers: &#123; //同步获取数据 setTableParams(state) &#123; return &#123; ...state &#125; &#125; &#125;,&#125;;export default GlobalModel; 第二步对应页面中 12345678910111213141516171819202122232425262728import React from &quot;react&quot;;import &#123; connect &#125; from &quot;umi&quot;;const TableDemo = (props) =&gt; &#123; //能直接获取到users const &#123;dispatch, users&#125; = props dispatch(&#123; //global这个model中，getTableData这个异步操作函数 type: &quot;global/getTableData&quot;, payload: &#123; &#125;, &#125;); return ( &lt;div&gt; &#123;users.name&#125; &lt;/div&gt; )&#125;//把global中state中的数据绑定到页面的props上export default connect((&#123; global &#125;) =&gt; (&#123; users: global.users&#125;))(TableDemo); 还可以调用Service文件夹里的接口，获取数据","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"}]},{"title":"Dav结构的分析","slug":"davjs学习","date":"2021-02-23T10:34:00.000Z","updated":"2021-03-06T01:55:47.053Z","comments":true,"path":"2021/02/23/davjs学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/23/davjs%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"下面是davjs models的一个基本结构 1234567891011121314151617181920212223242526272829303132333435export default &#123; //dav model的名字namespace: &#x27;example&#x27;,//数据state: &#123;num:1&#125;, //表示当前的example中的state状态，这里可以给初始值，这里num初始为1 //这里是做异步处理的相当于VueX的actioneffects: &#123; //payload是参数 put触发action ，select获取数据， call异步操作 *addByONe(&#123; payload&#125;, &#123; call, put,select &#125;) &#123; //这里使用selectconst num = yield select(state =&gt; state.num) //这里就获取到了当前state中的数据numlet param1; param1 = num + payload; 这里就可以使用num进行操作了yield put(&#123;type: &#x27;save&#x27;,num:param1&#125;);&#125;&#125;, //用来保存更新state值 上面的put方法调用这里的方法,reducers: &#123;save(state, action) &#123; //这里的state是当前总的state，这里的action包含了上面传递的参数和type return &#123; ...state, ...action.num &#125;; //这里用ES6语法来更新当前state中num的值&#125;&#125;, &#125;;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"}]},{"title":"关于我","slug":"关于我","date":"2021-02-11T16:00:00.000Z","updated":"2021-04-12T08:26:57.639Z","comments":true,"path":"2021/02/12/关于我/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/12/%E5%85%B3%E4%BA%8E%E6%88%91/","excerpt":"","text":"一个正在慢慢成长的前端程序员。","categories":[],"tags":[{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]},{"title":"新年快乐","slug":"hello-world","date":"2021-02-10T16:00:00.000Z","updated":"2021-02-23T05:25:35.342Z","comments":true,"path":"2021/02/11/hello-world/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/11/hello-world/","excerpt":"","text":"大家新年快乐","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"},{"name":"pinia","slug":"pinia","permalink":"https://gitee.com/shimmer612/myBlog/tags/pinia/"},{"name":"react-hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"},{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://gitee.com/shimmer612/myBlog/tags/JavaScript/"},{"name":"正则","slug":"正则","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%AD%A3%E5%88%99/"},{"name":"antd","slug":"antd","permalink":"https://gitee.com/shimmer612/myBlog/tags/antd/"},{"name":"react","slug":"react","permalink":"https://gitee.com/shimmer612/myBlog/tags/react/"},{"name":"观后感","slug":"观后感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"},{"name":"随感","slug":"随感","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E6%84%9F/"},{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"-javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E6%8E%92%E5%BA%8F/"},{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"webSocket","slug":"webSocket","permalink":"https://gitee.com/shimmer612/myBlog/tags/webSocket/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://gitee.com/shimmer612/myBlog/tags/react-hooks/"},{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"},{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"},{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"},{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"},{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"},{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]}