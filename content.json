{"meta":{"title":"Shimmer","subtitle":"黑暗中寻光的人","description":"","author":"Shimmer","url":"https://gitee.com/shimmer612/myBlog","root":"/myBlog/"},"pages":[{"title":"tags","date":"2021-02-23T09:07:02.000Z","updated":"2021-02-23T09:08:25.950Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/shimmer612/myBlog/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-03-17T01:52:41.653Z","updated":"2021-03-17T01:52:41.653Z","comments":true,"path":"message/index.html","permalink":"https://gitee.com/shimmer612/myBlog/message/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-03-22T00:44:45.304Z","updated":"2021-03-22T00:44:45.304Z","comments":true,"path":"photos/index.html","permalink":"https://gitee.com/shimmer612/myBlog/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"杂记02","slug":"2021-03-22-杂记02","date":"2021-03-21T16:00:00.000Z","updated":"2021-03-22T08:18:42.194Z","comments":true,"path":"2021/03/22/2021-03-22-杂记02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/22/2021-03-22-%E6%9D%82%E8%AE%B002/","excerpt":"","text":"今天也没学什么新东西，但是博客总要点新的东西吧。就随便写一点吧。 今天想给自己的在线购物商城加一个客服聊天功能。百度了下用socket.io可以实现，但是自己折腾了半天也没有成功，就放弃了。 不过给订单页面加了一个快递查询的功能，用的假数据，点击直接返回一串快递信息，是我自己淘宝买东西的物流信息。用element-ui的TimeLine实现的。 其实想了很多功能，却不知道怎么实现，比如点击付款按钮，跳出来一个二维码，扫描二维码，跳转到订单页面，没有找到什么插件可以监听二维码的扫描事件。用的qrimage只能生成二维码，扫描跳转到设置特定的页面。 痛点很多，要学习的东西也很多。 总感觉自己不是一个合格的前端。 不务正业去学了后台。写了几个接口学了mongo,也满足自己平时写写小项目自己写后台了。也挺不错的。express真的挺香的。 昨天去滆湖公园放了风筝，很开心。和高中同学聊聊天散散步真的很愉快。 还是没事多出去走一走，呼吸呼吸新鲜的空气。 整个人的精神会好很多。 看着漫天的飞翔的风筝，抽芽的柳树，盛开的油菜花和家乡的Sakura。 那时候之前所有的烦闷与苦痛全部抛在脑后。 真好！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"创建一个vue3.0+element-plus项目","slug":"2021-03-20-创建一个vue3.0+element-plus项目","date":"2021-03-19T16:00:00.000Z","updated":"2021-03-20T06:15:27.903Z","comments":true,"path":"2021/03/20/2021-03-20-创建一个vue3.0+element-plus项目/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/20/2021-03-20-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAvue3.0+element-plus%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"创建一个vue3.0+element-plus项目首先要确认自己电脑中的@vue/cli&gt;4.5 可以用vue -V查看 没有的话可以用npm i -g @vue/cli升级 升级成功后 **vue create my-pro**这里选择Vue 3的项目。 创建成功后。 执行下面的命令。 12cd my-provue add element-plus 全局加载和按需加载自己选择。 安装成功后。 npm run serve 发现项目跑起来了。 按需加载的话，需要在src/plugins/element.js文件里，引入自己所需要的组件就可以了。 1234567import &#123; ElButton,ElTimeline &#125; from &#x27;element-plus&#x27;export default (app) =&gt; &#123; app.use(ElButton) app.use(ElTimeline)&#125;","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"}]},{"title":"杂记","slug":"2021-03-19-杂记","date":"2021-03-18T16:00:00.000Z","updated":"2021-03-20T06:22:46.821Z","comments":true,"path":"2021/03/19/2021-03-19-杂记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/19/2021-03-19-%E6%9D%82%E8%AE%B0/","excerpt":"","text":"年初七到常州实习，租的短租房，和软件班的一个同事合住，六十一天。当晚凌晨两点多，接到了她的电话。她问我，人在哪，明天上不上班。我说我在常州明天上班。那我就舒服多了她说。 认识这么久好像除了当初追她的时候，也是凌晨两点多，接过她一次电话。她说你害怕那种夜里无助的感觉，不想再把自己全身心托付给另一个人了。 第二个电话就是分手这次。 还在一起的时候，她希望夜里打电话，我要接到。我当时无法理解，她说的那种夜里无助，害怕的感觉，打我的电话却打不通的那种绝望，有多难受。 我不理解夜里有什么好奔溃的，早点睡觉不行吗？我也没想到追她的时候她和我说的话。完全的抛在了脑后。 后来我才慢慢的明白，她说的那种感觉。 人和人是不一样的，我这么多年一直没有理解这个道理。直到最近才深有体会。 我总觉得，我可以做到的事，我不以为意地事情，我觉得可以的OK的事情，别人也应该可以。 原来，人的性格各有不同，要尊重不同的性格，不同的人生。 可是都是亡羊补牢，为时已晚。 她就这样又一次的闯进了我的生活，打乱了我生活的节奏，扰乱了我的心绪，然后挥挥衣袖，没有一丝的拖泥带水，消失在丛林深处。 煎熬了两周，我重新开始了我的生活节奏，上班下班，锻炼，减肥。我内心深处，自然而然地认为，或许我变得更好，她就会回来。 真的很感谢她，没有她，可能我现在还是一个在学校宿舍混吃等死，找不到工作的应届生吧。为了她努力学习找工作，让我现在坐在办公室里，成为了班级里少数优秀的人。 别人向往投来羡慕的目光，我知道这一切都是因为她，但是现在她不在了。 我曾急切地想把她找回来。急切地想得到她热烈地回应。 想到高中时候地一篇作文题目。 你若盛开，蝴蝶自来。 我不知道最后，来的是不是她这只蝴蝶，我只知道只要我盛开了，才会有蝴蝶。 谁回去叮一朵没有盛开地花呢？","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Vue3中路由的相关配置","slug":"Vue3中路由的相关配置","date":"2021-03-15T16:00:00.000Z","updated":"2021-03-17T01:25:00.647Z","comments":true,"path":"2021/03/16/Vue3中路由的相关配置/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/16/Vue3%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Vue3中路由的相关配置1、路由的配置在src路径下新建router文件夹，然后在该文件夹新建index.js文件 安装vue-router 1cnpm i vue-router@next --save index.js文件配置如下。 12345678910111213141516171819202122232425262728import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const addCount = () =&gt; import(&#x27;../components/addCount.vue&#x27;)const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/add&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, &#125;, &#123; path: &quot;/add&quot;, component: addCount &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router 然后配置main.js 引入router 1234567891011121314151617import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./index.css&#x27;//使用router//引入elementPlusimport ElementPlus from &#x27;element-plus&#x27;;import &#x27;element-plus/lib/theme-chalk/index.css&#x27;;//引入routerimport router from &#x27;./router/index&#x27;const app = createApp(App)//使用ElementPlusapp.use(ElementPlus)//使用routerapp.use(router)app.mount(&#x27;#app&#x27;) 2、路由的跳转方式一 引入useRouter 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter&#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const changeRouter = () =&gt; &#123; router.push(&#x27;/father&#x27;) &#125; return &#123; changeRouter &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 方式二router-link 1&lt;router-link to=&quot;/child&quot;&gt;子页面&lt;/router-link&gt; 方式三 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;toAdd&quot;&gt;下一页&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from &#x27;../router/index.js&#x27;export default &#123; methods: &#123; toAdd() &#123; router.push(&#x27;/add&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3、路由的传参引入useRoute 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;changeRouter&quot;&gt; 跳转路由 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const route = useRoute() const changeRouter = () =&gt; &#123; router.push(&#123; path: &#x27;/father&#x27;, query: &#123; name: &#x27;zz&#x27;, &#125;, &#125;) &#125; return &#123; changeRouter &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 如下图：在father页面就可以通过route.query.name获取到”zz” 4、路由的嵌套通过router-view和子路由的方式嵌套 router/index.js 123456789101112131415161718192021222324252627282930import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const Father = () =&gt; import(&#x27;../components/father.vue&#x27;)const children = () =&gt; import(&#x27;../components/child.vue&#x27;)const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/father&#x27; &#125;, &#123; path: &quot;/father&quot;, component: Father, children: [ &#123; path: &#x27;/child&#x27;, component: children &#125; ] &#125;,]const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;)export default router father.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h&quot;&gt;我是爷爷&lt;/h1&gt; &lt;br /&gt; &lt;router-link to=&quot;/child&quot;&gt;下一页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; child.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;hr&gt; &lt;h1&gt;我是儿子&lt;/h1&gt; &lt;/div&gt; &lt;Sunzi /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sunzi from &#x27;./sunzi.vue&#x27;export default &#123; components: &#123; Sunzi, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行如下图所示：","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"如何在vue的css中使用data中的变量","slug":"如何在vue的css中使用data中的变量","date":"2021-03-14T16:00:00.000Z","updated":"2021-03-16T02:54:26.599Z","comments":true,"path":"2021/03/15/如何在vue的css中使用data中的变量/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/15/%E5%A6%82%E4%BD%95%E5%9C%A8vue%E7%9A%84css%E4%B8%AD%E4%BD%BF%E7%94%A8data%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/","excerpt":"","text":"如何在vue的css中使用data中的变量。 很简单用v-bind 一个简单的例子 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; &gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; color: &#x27;red&#x27;, &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行如下图所示：成功设置了文字的颜色。 这样就可以做一个文字颜色不断变化的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;h1&quot; @click=&quot;changeColor&quot;&gt;我是&#123;&#123; color &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeColor&quot;&gt;变色&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; Child, &#125;, data() &#123; return &#123; color: &#x27;red&#x27;, count: 1, &#125; &#125;, created () &#123; setInterval(()=&gt;&#123; this.changeColor() &#125;,500) &#125;, methods: &#123; changeColor() &#123; const arr = [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;black&#x27;, &#x27;hotpink&#x27;, &#x27;purple&#x27;, &#x27;lime&#x27;, &#x27;skyblue&#x27;, ] this.color = arr[this.count] this.count++ if (this.count === 8) &#123; this.count = 0 &#125; &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.h1 &#123; color: v-bind(color);&#125;&lt;/style&gt; 运行结果如下图： 是不是感觉要方便许多。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"CSS的一些知识点","slug":"2021-03-12-CSS的一些知识点","date":"2021-03-11T16:00:00.000Z","updated":"2021-03-12T08:32:26.410Z","comments":true,"path":"2021/03/12/2021-03-12-CSS的一些知识点/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/12/2021-03-12-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"今天是三月十二日植树节，记录一些自己写样式的时候，以前不知道的东西。 1、设置padding的时候为了不改变盒子的大小要设置box-sizing:border-box 2、盒子内部阴影在末尾加一个inset比如box-shadow: 0 0 5px 0 red inset 3、设置透明度的时候opacity:0.8这样会让父元素子元素也改变透明度。可以改成rgba(255,255,255,0.8)的这种方式 4、网页字体最小就是12px 5、设置背景图时使用路径时 background-image: url(~@/assets/carMonitor/warn-info.png);写成这种样式。还有加上 background-size: cover; 不想写了，今天很难受，心情很不好。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"node.js+express+mongodb来开发后端","slug":"2021-03-10-node.js+express+mongodb来开发后端","date":"2021-03-10T16:00:00.000Z","updated":"2021-03-11T01:21:12.502Z","comments":true,"path":"2021/03/11/2021-03-10-node.js+express+mongodb来开发后端/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/11/2021-03-10-node.js+express+mongodb%E6%9D%A5%E5%BC%80%E5%8F%91%E5%90%8E%E7%AB%AF/","excerpt":"","text":"node.js+express+mongodb来开发后端大四临近毕业，要开始写毕业设计，但是作为前端的我，对后端一窍不通。然后想到nodejs也可以写后端。用的就是javascript。应该学习成本不是很高。 如今已经写好了毕设。但是对当时怎么用nodejs+express+mongodb写接口有点遗忘了。 今天来记录一下。以便后面来复习和查找。 1、安装expressnpm install express --save 2、新建一个js文件123456789101112131415161718192021222324252627282930313233343536373839//引入express并绑定到app上const express = require(&#x27;express&#x27;)const app = express()// 静态资源路径app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;))// 跨域app.use(require(&#x27;cors&#x27;)())// express 处理jsonapp.use(express.json())// 接口的开发app.use(&#x27;/&#x27;,require(&#x27;./router/user&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/address&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/admin&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/banner&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/cat&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goods&#x27;))// app.use(&#x27;/&#x27;,require(&#x27;./router/hotGoods&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/order&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/shopcart&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/star&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/upload&#x27;))app.use(&#x27;/&#x27;,require(&#x27;./router/goodsBuyCount&#x27;))// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 3、mongoose的使用安装mongoose npm i mongoose --save 新建一个js文件 123456789101112131415161718//引入mongooseconst mongoose = require(&#x27;mongoose&#x27;)// 连接数据库mongoose.connect(&#x27;mongodb://localhost:27017/storedb&#x27;, &#123; useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true&#125;)//创建数据模型，类似于表const CateSchema = new mongoose.Schema(&#123; //字段名称与字段类型 还可以加一些判断。required:true代表必传，unique 代表唯一的 cat_id: &#123; type:Number &#125;, cat_name: &#123; type: String, required: true &#125;&#125;)//绑定到模型const Category = mongoose.model(&#x27;category&#x27;, CateSchema, &#x27;category&#x27;) 4、接口的实现这里直接使用express router 不直接用app.get()或者app.post()这样去使用了。 新建一个js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344//引入expressconst express = require(&#x27;express&#x27;);//引入mongoose数据模型const &#123; Address &#125; = require(&#x27;../storedb&#x27;)//绑定routerlet router = express.Router();// 获取用户地址router.get(&#x27;/getAddress&#x27;, async (req, res) =&gt; &#123; const address = await Address.find(&#123; user_id: req.query.user_id &#125;) res.send(address)&#125;)// 删除地址router.delete(&#x27;/deleteAddress&#x27;, async (req, res) =&gt; &#123; const address = req.query const userId = req.query.user_id await Address.deleteOne(&#123; user_id: userId, add_id: address.add_id &#125;) res.send(&#123; message: &quot;删除地址成功！&quot; &#125;)&#125;)// 修改地址router.post(&#x27;/changeAddress&#x27;, async (req, res) =&gt; &#123; const address = req.body const addId = req.body.add_id await Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) res.send(&#123; message: &quot;修改地址成功！&quot; &#125;)&#125;)//导出module.exports = router 一般查询用get 增加修改用post 删除用delete 说一下mongoose的增删改查 增加 Address代表表名 里面是增加的一个地址， 123456Address.create(&#123; user_id: 1234, add_id: 123, user_name: &quot;zz&quot;, user_phone: 123456789, user_address: &quot;大道&quot; &#125;) 删除 删除user_id中add_id为123的那个地址 Address.deleteOne(&#123; user_id: 1234, add_id: 123 &#125;) 修改 修改第一个参数是修改哪一个，查找条件。add_id为多少的哪一个。 第二个参数为修改后的数据 12345Address.updateOne(&#123; add_id: addId &#125;, &#123; user_name: address.user_name, user_phone: address.user_phone, user_address: address.user_address &#125;) 查询 12345//查询所有的Address.find()//查询user_id为123的所有地址Address.find(&#123;user_id:123&#125;) mongoose的一些常用查询参数 1234567//skip查询的时候跳过多少个//limit限制一次查询几个//sort是排序 1是正序-1是倒序// skip(), limit(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 const goods = await Goods.find().limit(pageSize).skip((pageNum - 1) * pageSize).sort(&#123; goods_id: 1 &#125;) 12//$in 查询goods_id为$in后面的数组const aa = await Goods.find(&#123; goods_id: &#123; $in: [1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125;) 123456789//$or 满足其中一个条件就可以//$regex 匹配查询const data = await Goods.find(&#123; $or: [ &#123; goods_name: &#123; $regex: reg &#125; &#125;, &#123; goods_title: &#123; $regex: reg &#125; &#125;, &#123; goods_subtitle: &#123; $regex: reg &#125; &#125; ] &#125;) 123456789101112131415161718192021222324//aggregate聚合查询//$lookup 两个表关联查询//下面的意思是根据cat_id在goods表中查询，查询到的数据放到goods这个字段下。const index = req.params.categoryId - 1 await Category.aggregate([ &#123; $lookup: &#123; from: &quot;goods&quot;, localField: &quot;cat_id&quot;, foreignField: &quot;cat_id&quot;, as: &quot;goods&quot;, &#125; &#125;,&#123;$sort:&#123;&quot;cat_id&quot;:1&#125;&#125; ] , (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; res.send(data[index]) &#125; )&#125;) 5、上传文件12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require(&#x27;express&#x27;);var formidable = require(&#x27;formidable&#x27;);fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const &#123; Goods &#125; = require(&#x27;../storedb&#x27;)let router = express.Router();router.post(&#x27;/uploadImg&#x27;, (req, res, next) =&gt; &#123; const goods = req.query let form = new formidable.IncomingForm(); form.encoding = &#x27;utf-8&#x27;; // 编码 // 保留扩展名 form.keepExtensions = true; //文件存储路径 最后要注意加 &#x27;/&#x27; 否则会被存在public下 form.uploadDir = path.join(__dirname, &#x27;../public/imgs/accessory/&#x27;) form.parse(req, (err, fields, files) =&gt; &#123; if (err) throw err let oldFilename = files.file.name fs.rename(files.file.path, form.uploadDir + generateFilename(oldFilename), async err =&gt; &#123; if (err) &#123; console.log(&quot;重命名失败&quot;); &#125; else &#123; await Goods.updateOne(&#123; goods_id: goods.goods_id &#125;, &#123; goods_pic: `public/imgs/accessory/$&#123;generateFilename(oldFilename)&#125;`, &#125;) &#125; &#125;) res.send(&#123; message: &quot;保存成功！&quot; &#125;) &#125;) function generateFilename(oldFilename) &#123; //将老的文件名拼上时间戳，这样既不会命名冲突又可以看出文件的上传事件 let d = new Date(); let names = oldFilename.split(&quot;.&quot;); return `$&#123;names[0]&#125;_$&#123;&quot;&quot; + d.getFullYear() + (d.getMonth() + 1) + d.getDate() + &#x27;_&#x27; + d.getHours() + d.getMinutes() + d.getSeconds()&#125;.$&#123;names[1]&#125;`; &#125;&#125;); 6、启动在项目根目录打开终端运行node app.js 12345678//出现 success in port 3002，服务已经跑起来啦 //因为上面是这样写的// 运行端口，服务跑在本地的3002端口上app.listen(3002, () =&gt; &#123; console.log(&#x27;success in port 3002，服务已经跑起来啦&#x27;);&#125;) 说明运行成功。 7、调用接口12345678910111213141516171819202122232425262728 // 获取用户地址 async getAddress () &#123; const userId = window.sessionStorage.getItem(&#x27;userId&#x27;) const res = await this.$http.get(&#x27;getAddress&#x27;, &#123; params: &#123; user_id: userId &#125; &#125;) this.address = res.data &#125;,//请求地址Request URL: http://localhost:3002/getAddress?user_id=1255Request Method: GETStatus Code: 200 OKRemote Address: [::1]:3002Referrer Policy: strict-origin-when-cross-origin//返回相应的数据[&#123; &quot;_id&quot;:&quot;602e26a4a8185949dc9ea23e&quot;, &quot;user_id&quot;:&quot;1255&quot;, &quot;add_id&quot;:&quot;157&quot;, &quot;user_name&quot;:&quot;wky&quot;, &quot;user_phone&quot;:&quot;18888888888&quot;, &quot;user_address&quot;:&quot;无锡市滨湖区太湖学院北区&quot;, &quot;__v&quot;:0&#125;] 到这里基本上就完成了大部分的功能。 当然还有登录注册。jwt签名生成token，密码的加密等等。 这个我也忘记的差不多了。 去整理一下，再记录下来。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"}]},{"title":"从数组中取出随机几个数组成新数组（不重复取）","slug":"2021-03-10-从数组中取出随机几个数组成新数组（不重复取）","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-10T09:14:23.203Z","comments":true,"path":"2021/03/10/2021-03-10-从数组中取出随机几个数组成新数组（不重复取）/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/10/2021-03-10-%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E5%87%BA%E9%9A%8F%E6%9C%BA%E5%87%A0%E4%B8%AA%E6%95%B0%E7%BB%84%E6%88%90%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%96%EF%BC%89/","excerpt":"","text":"​ 要给自己的商城，加一个推荐商品的功能。想让他随机从商品表中取出4个数据。 ​ 一开始我用Math.random()*arr.length但是会取出相同的。这样就不太对，哪有推荐两个相同的商品呢。 ​ 然后想到获取当前选择的下标，把选择的那个删除。下一次随机，就随机不到那个数了。 123456789101112131415161718192021//前台传来的当前商品的idconst nowGoodsIndex = req.query.goods_id-1 const goods = await Goods.find() let arr = [] //存入数组的id,因为id就是从1开始往上加。 goods.forEach((element, index) =&gt; &#123; arr.push(index+1) &#125;); //用splice把当前商品的id删除避免重复 arr.splice(nowGoodsIndex, 1); let newArr = [] //随机取出4个，取出来一个就把那个数在数组中删掉。避免重复。 for (let i = 0; i &lt;= 3; i++) &#123; let index = Math.floor(Math.random() * arr.length); newArr.push(arr[index]); //获取后，在数组中删除已经加入的随机数 arr.splice(index, 1); &#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"CSS margin折叠","slug":"2021-03-09-CSS-margin折叠","date":"2021-03-08T16:00:00.000Z","updated":"2021-03-09T09:49:37.080Z","comments":true,"path":"2021/03/09/2021-03-09-CSS-margin折叠/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/09/2021-03-09-CSS-margin%E6%8A%98%E5%8F%A0/","excerpt":"","text":"margin折叠今天在写页面的时候发现，子元素设置了margin-top:101px不生效，父元素却向下移动了。 这就是margin折叠 12345678910111213141516171819202122232425262728 //这里给子元素设置margin-top//父元素却向下移动了101px&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;car-message&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;style&gt; .main &#123; width: 1440px; height: 810px; background-image: url(~@/assets/bg.png); background-size: cover; box-sizing: border-box; padding: 0 19px 0 17px;&#125;.car-message &#123; margin-top: 101px; background-image: url(~@/assets/one.png); background-size: cover; width: 1404px; height: 51px; display: flex; align-items: center;&#125;&lt;/style&gt; 百度了下 外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。 解决办法兄弟间重叠时 底部元素变为行内盒子(display: inline-block); 底部元素的position的值为absolute/fixed 父元素与子元素重叠 父元素加入(overflow: hidden); 父元素添加透明边框(border:1px solid transparent); 子元素变为行内盒子(display: inline-block); 子元素加入浮动属性或定位 这里我给父元素设置了overflow:hidden就解决了。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"}]},{"title":"react 中使用Swiper轮播图插件","slug":"2021-03-08-react-中使用Swiper轮播图插件","date":"2021-03-07T16:00:00.000Z","updated":"2021-03-09T05:15:36.072Z","comments":true,"path":"2021/03/08/2021-03-08-react-中使用Swiper轮播图插件/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/08/2021-03-08-react-%E4%B8%AD%E4%BD%BF%E7%94%A8Swiper%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6/","excerpt":"","text":"第一步、安装1npm i swiper 第二步、使用12345678910111213141516171819import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/react&#x27;;//根据自己的需要引用样式import &#x27;swiper/swiper.less&#x27;;export default () =&gt; &#123; return ( &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;3&#125; onSlideChange=&#123;() =&gt; console.log(&#x27;slide change&#x27;)&#125; onSwiper=&#123;(swiper) =&gt; console.log(swiper)&#125; &gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;/Swiper&gt; );&#125;; 到这一个轮播图就已经实现了，但是只是轮播图没有别的东西，比如左右的按钮。这些需要我们手动添加。 第三步、添加功能（例：navigation按钮）1234567891011121314//引入所需功能和样式文件import SwiperCore, &#123; Navigation &#125; from &quot;swiper&quot;;import &quot;swiper/components/navigation/navigation.less&quot;;//使用SwiperCore.use([Navigation]);// 组件上添加属性 &lt;Swiper spaceBetween=&#123;50&#125; slidesPerView=&#123;1&#125; navigation style=&#123;&#123; padding: &quot;24px&quot; &#125;&#125; &gt; 以上就是在react中使用swiper插件。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"}]},{"title":"react hooks学习","slug":"react hooks学习","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-09T05:15:48.598Z","comments":true,"path":"2021/03/05/react hooks学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/05/react%20hooks%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"react hooks学习01、什么是react hooksreact hooks就是react提供的内置函数，这些函数可以让，函数式组件和类组件一样拥有组件状态和副作用。 什么是状态？ React中的放数据的地方。 什么是副作用？ 在 React 组件中执行数据获取、订阅或者手动修改 DOM，我们统一把这些操作称为“副作用” 02、useStateuseState 就类似于类组件中的this.state useState的用法 12345678910111213141516171819202122import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0);return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getEementById(&#x27;root&#x27;)); 03、useEffectuseEffect就相当于生命周期的componentDidMount和componentDidUPdate 使用方法 123456789101112131415161718192021222324252627282930import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123;useState , useEffect&#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;;const Main =function() &#123; const [count, setCount] = useState(0); // 相当于componentDidMount和componentDidUpdate useEffect(() =&gt; &#123; // 打印点击的次数 console.log( `You clicked $&#123;count/2&#125; times`) &#125;)return( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;&#123;setCount(count+2)&#125;&#125;&gt;当前的数为：&#123;count&#125;&lt;/h1&gt; &lt;/div&gt;)&#125;ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#x27;root&#x27;));","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"javascript常用数组方法的复习","slug":"2021-03-04-javascript常用数组方法的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T04:00:22.334Z","comments":true,"path":"2021/03/04/2021-03-04-javascript常用数组方法的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-javascript%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"分析项目代码经常会看到一些数组方法，some,slice等等。概念都模糊不清，感觉知道又感觉不知道。还是要到W3C上去查一下用法。 所以这次把一些常用的数组方法整理一下，用来巩固复习 forEach()forEach() 对数组的每一项进行操作 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值undefined 1234567let arr = [1,2,3,4,5,6]let arr1 = []arr.forEach(item=&gt;&#123; arr1.push(item*2) &#125;)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ] filter()filter() 返回一个新数组，包含复合要求的所有元素 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：复合要求的新数组 123let arr = [1,2,3,4,5,6]let arr1 = arr.filter(item=&gt;item&gt;=3)console.log(arr1); //[ 3, 4, 5, 6 ] map()map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：原数组每个元素执行回调函数的结果组成的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.map(item=&gt;item*2)let arr2 = arr.map(item=&gt;item&gt;3)console.log(arr1); //[ 2, 4, 6, 8, 10, 12 ]console.log(arr2);//[ false, false, false, true, true, true ] slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 **begin 可选** 提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果省略 begin，则 slice 从索引 0 开始。 如果 begin 超出原数组的索引范围，则会返回空数组。 end 可选 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end） 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 被省略，则 slice 会一直提取到原数组末尾。 如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。 返回值：一个含有被提取元素的新数组。 12345let arr = [1,2,3,4,5,6]let arr1 = arr.slice(2,4)let arr2 = arr.slice()console.log(arr1);//[ 3, 4 ]console.log(arr2);//[ 1, 2, 3, 4, 5, 6 ] find()find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [undefined] callback 函数接收3个值，item数组项，index元素下标，arr数组本身 数组中第一个满足所提供测试函数的元素的值，否则返回 [undefined] 123let arr = [1,2,3,4,5,6]let arr1 = arr.find(item=&gt;item&gt;4)console.log(arr1); //5 sort()sort()对数组的元素进行排序，并返回数组 如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 12345678910111213141516171819let arr = [5,4,3,2,1]let arr1 = arr.sort()console.log(arr1); //[ 1, 2, 3, 4, 5 ]let arr = [3,1,4,2,5,8,6,7]let arr3 = [3,1,4,2,5,8,6,7]let arr1 = arr.sort((a, b) =&gt; &#123; return a-b&#125;)console.log(arr1); //[ 1, 2, 3, 4, 5, 6, 7, 8 ]let arr2 = arr3.sort((a, b) =&gt; &#123; return b-a&#125;)console.log(arr2); //[ 8, 7, 6, 5, 4, 3, 2, 1 ] some()some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值： 数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false。 123456let arr = [1, 2, 3, 4, 5, 6]const aa = arr.some(item =&gt; item &gt; 5)const bb = arr.some(item =&gt; item &gt; 7)console.log(aa);//trueconsole.log(bb); //false every()every()方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 注意：若收到一个空数组，此方法在一切情况下都会返回 true。 callback 函数接收3个值，item数组项，index元素下标，arr数组本身 返回值：如果回调函数的每一次返回都为true，返回 true ，否则返回 false。 123456let arr = [2, 5, 6, 7, 8, 9]const aa = arr.every(item =&gt; item &gt; 3)const bb = arr.every(item =&gt; item &gt; 1)console.log(aa); //fasleconsole.log(bb); //true 差不多就是这些常用的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"扩展运算符(...)的复习","slug":"2021-03-04-扩展运算符(...)的复习","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T01:39:59.558Z","comments":true,"path":"2021/03/04/2021-03-04-扩展运算符(...)的复习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/04/2021-03-04-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6(...)%E7%9A%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"最近看项目代码，经常看到函数里运用扩展运算符。总是模模糊糊的，看明白又好像没有明白的感觉。 像下面这样 1234567891011121314151617181920212223 setCacheComponents([ ...cacheComponentsClone, &#123; ...currentPane, name: name || obj.item.props.children[1] // 如果调用addtab时传入了name则使用此name &#125; ]);//------------------------------------------------------------------------------------------ return &#123; ...state, tableData: [ ...state.tableData, &#123; params: &#123; ...payload.params, page: payload.page || 1, pageSize: payload.pageSize || 10 &#125;, tableKey: payload.tableKey, loading: true &#125; ] &#125; 就整理了一下扩展运算符的用法。 1234567891011121314151617181920212223242526272829// 浅拷贝const obj = &#123; name: &quot;张三&quot;, age: &quot;20&quot;, sex: &quot;男&quot;, hobby:&#123; play: &quot;ball&quot;, &#125;&#125;const newObj = &#123; ...obj&#125;console.log(newObj);//&#123; name: &#x27;张三&#x27;, age: &#x27;20&#x27;, sex: &#x27;男&#x27;, hobby: &#123; play: &#x27;ball&#x27; &#125; &#125;// 连接数组const arr = [1,2,3]const arr1 = [4,5,6]const newArr = [...arr,...arr1]console.log(newArr); //[ 1, 2, 3, 4, 5, 6 ]// 字符串转换成数组const str = &#x27;abcdefg&#x27; const newStr = [...str]console.log(newStr); //[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;g&#x27;]// 解构赋值 数组对象都可以const aa = [1,2,3]const bb = [...aa,4,5,6]console.log(bb); //[ 1, 2, 3, 4, 5, 6 ] 项目里常用的就是在函数里，用来解构赋值的比较多","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"}]},{"title":"一些小记录","slug":"小记","date":"2021-03-02T16:00:00.000Z","updated":"2021-03-03T08:17:17.395Z","comments":true,"path":"2021/03/03/小记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/03/%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"开发中写样式less中，最外层取一个不易重的类名，其余子元素类名写在里面 尽量不要写到margin负值 样式遵循设计图 图片名称起相关英文名 flex布局多使用space-around做分割，除非必须用space-between 类名过长用xx-xx这样写 页面起名大驼峰比如ChargeManage","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"}]},{"title":"React项目(UmiJS)中使用高德地图","slug":"2021-03-02-React项目(UmiJS)中使用高德地图","date":"2021-03-01T16:00:00.000Z","updated":"2021-03-02T01:21:36.707Z","comments":true,"path":"2021/03/02/2021-03-02-React项目(UmiJS)中使用高德地图/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/03/02/2021-03-02-React%E9%A1%B9%E7%9B%AE(UmiJS)%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"React AMap这是一个基于 React 封装的高德地图组件. 文档地址 https://uiw.gitee.io/react-amap/#/ 01、安装npm install @uiw/react-amap --save 02、使用在文档左侧找到需要使用的例子。在右侧直接复制对应代码。按需进行修改。 03、例子（贝塞尔曲线的使用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; useState &#125; from &quot;react&quot;;import &#123; Map, APILoader, BezierCurve &#125; from &quot;@uiw/react-amap&quot;;const CarLine = () =&gt; &#123; const [show] = useState(true); const path = [// 每个弧线段有两种描述方式 [116.39, 39.91, 116.37, 39.91],// 起点 // 第一段弧线 [116.380298, 39.907771, 116.38, 39.90],// 控制点，途经点 // 第二段弧线 [116.385298, 39.907771, 116.40, 39.90],// 控制点，途经点// 弧线段有两种描述方式1 // 第三段弧线 [// 弧线段有两种描述方式2 [116.392872, 39.887391],// 控制点 [116.40772, 39.909252],// 控制点 [116.41, 39.89]// 途经点 ], // 第四段弧线 [116.423857, 39.889498, 116.422312, 39.899639, 116.425273, 39.902273] // 控制点，控制点，途经点，每段最多两个控制点 ]; const handleParams = (values) =&gt; &#123; return values &#125; return ( &lt;&gt; &lt;APILoader akay=&quot;a7a90e05a37d3f6bf76d4a9032fc9129&quot;&gt; &lt;div style=&#123;&#123; width: &quot;100%&quot;, height: &quot;600px&quot; &#125;&#125; &gt; &lt;Map zoom=&#123;14&#125; center=&#123;[116.397637, 39.900001]&#125;&gt; &lt;BezierCurve visiable=&#123;show&#125; path=&#123;path&#125; isOutline=&#123;true&#125; outlineColor=&quot;&quot; borderWeight=&#123;3&#125; strokeColor=&quot;red&quot; strokeOpacity=&#123;1&#125; strokeWeight=&#123;6&#125; // 线样式还支持 &#x27;dashed&#x27; strokeStyle=&quot;solid&quot; // strokeStyle是dashed时有效 strokeDasharray=&#123;[10, 10]&#125; lineJoin=&quot;round&quot; lineCap=&quot;round&quot; zIndex=&#123;50&#125; /&gt; &lt;/Map&gt; &lt;/div&gt; &lt;/APILoader&gt; &lt;/&gt; );&#125;export default CarLine","categories":[],"tags":[{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"}]},{"title":"对Ant-Design Table组件进行封装","slug":"2021-02-26-对Ant-Design-Table组件进行封装","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-09T05:15:22.392Z","comments":true,"path":"2021/02/26/2021-02-26-对Ant-Design-Table组件进行封装/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/2021-02-26-%E5%AF%B9Ant-Design-Table%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85/","excerpt":"","text":"Table组件封装页面, dataSource通过Modal中的获取的数据传过来，主要对columns进行封装。把一些常用的属性给暴露出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import &#123; connect &#125; from &quot;umi&quot;;import &#123; Spin, Table, Space, Popconfirm, Tooltip &#125; from &quot;antd&quot;;import CommonPagination from &quot;@/components/CommonPagination&quot;;import moment from &quot;moment&quot;;import &#123; formatNum &#125; from &quot;@/utils/utils&quot;const SearchForm = (&#123; tableConfig, tableData &#125;) =&gt; &#123; const tableItem = tableData.find((item) =&gt; item.tableKey === tableConfig.tableKey) || &#123;&#125;; const &#123; loading &#125; = tableItem; // 根据tablekey取到对应请求的loading状态 const dataSource = tableItem.data || []; const columns = tableConfig.columns.map(item =&gt; &#123; if (item.actionMap) &#123; item = &#123; ...item, render(res) &#123; // 生成action列表 const actionList = (item.actionMap || []).map((action, index) =&gt; &#123; switch (action.type) &#123; case &quot;href&quot;: if (action.render) &#123; return &lt;div key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.render(res)&#125;&lt;/div&gt; &#125; return &lt;a key=&#123;index&#125; onClick=&#123;() =&gt; &#123; if (action.onClick) &#123; action.onClick(res) &#125; &#125;&#125;&gt;&#123;action.text&#125;&lt;/a&gt; case &quot;confirm&quot;: return &lt;Popconfirm key=&#123;index&#125; title=&#123;&lt;div&gt;确认要执行&#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125;操作吗？&lt;/div&gt;&#125; onConfirm=&#123;() =&gt; &#123; if (action.onConfirm) &#123; action.onConfirm(res) &#125; &#125;&#125; onCancel=&#123;() =&gt; &#123; if (action.onCancel) &#123; action.onCancel(res) &#125; &#125;&#125; okText=&quot;确认&quot; cancelText=&quot;取消&quot; &gt; &#123;action.text ? &lt;a href=&quot;#&quot;&gt;&#123;action.text&#125;&lt;/a&gt; : action.render(res)&#125; &lt;/Popconfirm&gt; default: return &lt;span key=&#123;index&#125;&gt;未知类型，请检查&lt;/span&gt; &#125; &#125;); return &lt;Space size=&quot;middle&quot;&gt; &#123; actionList.map(action =&gt; action) &#125; &lt;/Space&gt; &#125; &#125; &#125; else if (item.numFormat) &#123; item = &#123; ...item, render(res) &#123; return formatNum(res, ...item.numFormat); &#125; &#125; &#125; else if (item.timeFormat) &#123; item = &#123; ...item, render(res) &#123; return res ? moment(res).format(item.timeFormat) : &quot;--&quot; &#125; &#125; &#125; else if (item.tipCol) &#123; const render = item.render; item = &#123; ...item, ellipsis: &#123; show: false &#125;, render(res) &#123; if (item.tipCol === false) &#123; return res &#125; if (item.tipCol === true) &#123; return ( &lt;Tooltip placement=&quot;topLeft&quot; title=&#123;render ? render(res) : res&#125;&gt; &lt;span&gt;&#123;render ? render(res) : res&#125;&lt;/span&gt; &lt;/Tooltip&gt; ) &#125; &#125; &#125; &#125; return item; &#125;) return ( &lt;Spin spinning=&#123;loading === true&#125;&gt; &lt;div style=&#123;&#123; marginTop: 24, padding: 24, background: &quot;#fff&quot; &#125;&#125;&gt; &lt;Table pagination=&#123;false&#125; columns=&#123;columns&#125; dataSource=&#123;dataSource || []&#125; scroll=&#123;&#123; x: &quot;max-content&quot; &#125;&#125; bordered /&gt; &lt;CommonPagination tableKey=&#123;tableConfig.tableKey&#125; /&gt; &lt;/div&gt; &lt;/Spin&gt; );&#125;;export default connect((&#123; global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(SearchForm); 分页封装页面 根据modal传过来的数据进行前台分页。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; connect &#125; from &quot;umi&quot;;import &#123; Pagination &#125; from &quot;antd&quot;;const styles = &#123; display: &quot;flex&quot;, justifyContent: &quot;flex-end&quot;, alignItems: &quot;center&quot;, backgroundColor: &quot;#fff&quot;, height: &quot;60px&quot;&#125;const CommonPagination = (props) =&gt; &#123; const &#123; dispatch, tableData, tableKey &#125; = props; const &#123; page: pageData, params &#125; = tableData.find(item =&gt; item.tableKey === tableKey) || &#123;&#125;; // 分页变化 const pageChange = (page) =&gt; &#123; dispatch(&#123; type: &quot;global/getTableData&quot;, payload: &#123; tableKey, params: &#123; page, &#125; &#125;, &#125;); &#125;; return ( &lt;div style=&#123;styles&#125;&gt; &#123;pageData &amp;&amp; ( &lt;Pagination total=&#123;pageData.total&#125; showTotal=&#123;() =&gt; `共计 $&#123;pageData.total&#125; 个`&#125; defaultCurrent=&#123;1&#125; showSizeChanger=&#123;false&#125; onChange=&#123;pageChange&#125; current=&#123;params.page&#125; /&gt; )&#125; &lt;/div&gt; );&#125;;export default connect((&#123;global &#125;) =&gt; (&#123; tableData: global.tableData || [],&#125;))(CommonPagination); 使用 ### CommonTable（通用表格） 必传参数tableConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495tableConfig=&#123; tableKey:&#x27;tableKey&#x27;, // 必传 columns:[ // 必传 &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;, &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;, &#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ], &#125; ], config:&#123;&#125; // table的配置，与官方文档一致&#125;&lt;CommonTable tableConfig=&#123;tableConfig&#125; /&gt; 其中columns与官方文档配置一致，当有如下参数时会进行特殊处理： tipCol (文字过长省略,Tooltip上方提示) 12345678910111213141516171819columns: [ &#123; title: &quot;Address&quot;, dataIndex: &quot;address&quot;, width: 150, key: &quot;address&quot;, tipCol: true, &#125;,] true时开启false关闭 numFormat（时间格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Age&quot;, key: &quot;age&quot;, width: 100, numFormat:[1,true] &#125;] numFormat[保留几位小数，是否进行千分位格式化]，numFormat[2,true]效果1234.567=&gt;1,234.57 timeFormat（日期格式化） 1234567891011121314151617columns: [ &#123; title: &quot;Time&quot;, width: 150, key: &quot;time&quot;, timeFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;,] timeFormat:时间戳格式，格式化为指定格式 actionMap（操作栏） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; title: &quot;Action&quot;, width: 200, actionMap:[ &#123; type: &quot;href&quot;, text: &quot;123&quot;, onClick(res) &#123; console.log(&quot;123&quot;,res); &#125;, render(res)&#123; return &lt;span&gt;&#123;res.name&#125;&lt;/span&gt; &#125; &#125;, &#123; type: &quot;confirm&quot;, onConfirm() &#123; console.log(&quot;onOk&quot;); &#125;, onCancel() &#123; console.log(&quot;onCancel&quot;); &#125;, text: &quot;删除&quot;, render(res)&#123; return &lt;a&gt;&#123;res.name&#125;&lt;/a&gt; &#125; &#125;, ],&#125; actionMap的type用于决定操作类型，具体如下： href，text和render至少有一个，render优先级高于text。当只有text参数时，生成结果为&lt;a&gt;&#123;text&#125;&lt;/a&gt;。当有render时，生成结果为render的返回值。 confirm，用于操作前的确认。render与text的关系与href一致。","categories":[],"tags":[{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"}]},{"title":"Vue3.0初探","slug":"vue3笔记","date":"2021-02-25T16:00:00.000Z","updated":"2021-03-16T02:54:39.632Z","comments":true,"path":"2021/02/26/vue3笔记/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/26/vue3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"✨ 官网地址官网文档：https://v3.cn.vuejs.org/ 一、vue3安装与项目创建【掌握】参考地址：https://www.vue3js.cn/docs/zh/guide/installation.html 准备工作：升级脚手架对于 Vue 3，你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli@next。要升级，你应该需要全局重新安装最新版本的 @vue/cli： 123yarn global add @vue/cli@next# ORnpm install -g @vue/cli@next 然后在 Vue 项目运行： 1vue upgrade --next 方式1：以原有vueCli脚手架创建创建项目： 1vue create demo 直接选择 Vue 3 Preview ，并回车，不考虑eslint问题。 然后执行： 123456# 进入目录cd demo# 用vscode打开当前目录code .# 运行项目yarn serve 方式2：vite创建12345678910111213npm init vite-app demo# 相当于npx create-vite-app demo# 安装后执行npm install# oryarn# 运行项目npm run dev# oryarn dev 创建项目并运行，会发现我们 npm run dev 后是秒开项目的，运行速度极快。 二、Composition API（组合式API）【掌握】 相当于 React Hooks 我们先使用以前vue2的方式实现一个累加： 12345678910111213141516171819&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; btnClick()&#123; this.count++; &#125; &#125;&#125;&lt;&#x2F;script&gt; 这套代码可以实现一个累加的效果，但如果以后我们想把这个组件中的 count 字段与 btnClick 单独拎出来管理，那就比较麻烦了，因为 count 和 btnClick 不在同一个方法内，很难抽离。 1、setupsetup有以下特性： 1、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的 2、setup函数是 Composition API（组合API）的入口 3、在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用 4、由于我们不能在 setup函数中使用 data 和 methods，所以Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined 5、setup函数只能是同步的不能是异步的 2、API - ref我们先来体验一下vue3怎么处理这个累加效果： 123456789101112131415161718192021&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;vue&#39;export default &#123; data()&#123; return &#123; count: 0 &#125; &#125;, setup()&#123; const count &#x3D; ref(1); &#x2F;&#x2F; 此时我们使用ref指定count的默认值为1，因此上面data中的count会失效 let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#x2F;&#x2F; 修改ref中的值要用xxx.value &#125; return &#123;count, btnClick&#125; &#125;&#125; 此时如果我想单独管理这个累加效果，我就可以这么操作： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;btnClick&quot;&gt;累加&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; data()&#123; return &#123; // count: 0 // 一旦把setup中的代码抽离，return中对应的值要去掉，否则ref无效 &#125; &#125;, setup()&#123; // 函数调用后就会返回一个对象，因此我们直接return return clickCountFn() // 如果后期还想同时返回其他数据，可以将clickCountFn()的返回结果展开 // return &#123;...clickCountFn(), 其他数据&#125; &#125;&#125;// 封装一个函数，这样这块功能我们就能单独管理了function clickCountFn()&#123; const count = ref(1); let btnClick = () =&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;/script&gt; 3、API - reactive再来了解另一个API ： reactive函数和ref作用非常接近，但是它的参数是一个对象，我们可以在对象中定义其方法，而通过这个形式，就不需要再对其进行进行 .value 调用了。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;p&gt;姓名：&#123;&#123;obj.username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref, reactive&#125; from &#39;vue&#39;export default &#123; setup()&#123; &#x2F;&#x2F; 使用reactive let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; return &#123;...clickCountFn(), obj, btnClick1&#125; &#125;&#125;function clickCountFn()&#123; const count &#x3D; ref(1); let btnClick &#x3D; () &#x3D;&gt; &#123; count.value++; &#125; return &#123;count, btnClick&#125;&#125;&lt;&#x2F;script&gt; 使用 reactive 生成的对象与 ref 生成的值都是响应式的。 这里可以看到我们在 html 中调用数据时，使用的是 obj.username ，那我们是否可以直接写 username 呢？答案是可以的，但这里需要注意： 由于reactive返回的对象本质上已经是一个Proxy对象，所以通过…扩展符号展开的属性，是无法进行响应式的 也就是说，如果这么写： 1return &#123;...clickCountFn(), ...obj, btnClick1&#125; 那么是无法实现的。 4、API - toRefs正确的写法应该是： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;btnClick&quot;&gt;累加&lt;&#x2F;button&gt; &lt;!-- 无需obj.username，直接username即可 --&gt; &lt;p&gt;姓名：&#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;btnClick1&quot;&gt;修改姓名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 新增toRefs方法import &#123;ref, reactive, toRefs&#125; from &#39;vue&#39;export default &#123; setup()&#123; let obj &#x3D; reactive(&#123; username: &quot;Jack&quot; &#125;) let btnClick1 &#x3D; () &#x3D;&gt; &#123; obj.username &#x3D; &quot;Mary&quot; &#125; &#x2F;&#x2F; 通过toRefs方法 let refObj &#x3D; toRefs(obj); &#x2F;&#x2F; 通过...refObj将数据扩展 return &#123;...clickCountFn(), ...refObj, btnClick1&#125; &#125;&#125;&#x2F;&#x2F; 其他代码...&lt;&#x2F;script&gt; 三、Provide与Inject（提供/注入）【掌握】1、Vue2写法以往我们的父传子是通过props传的： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child :num&#x3D;&quot;num&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; data()&#123; return &#123; num: 123 &#125; &#125;, components: &#123; Child &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 这个时候限制死了数据必须来自父组件，我们其实还有 Provide 和 Inject ： 123456789101112131415161718192021222324252627&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, provide: &#123; num: 456 &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Child.vue子组件 --&gt;&lt;template&gt; &lt;h2&gt;父组件传过来的值：&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; Provide/Inject 相比于 props 的好处在于： 如果组件嵌套较多，那么 props 需要一级一级往下传递，后期很难维护。Provide+Inject 相当于是跨级组件传值，比如孙子组件也想用上面这个 num 的值，就不用一级一级往下传，直接在孙子组件使用即可： 1234567891011&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;num&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; &#x2F;&#x2F; 将Sun组件在Child组件中引入，即可实现跨级组件传值 inject: [&#39;num&#39;]&#125;&lt;&#x2F;script&gt; 2、Vue3写法vue3中的 provide/inject。两者都只能在当前活动实例的 setup() 期间调用。 格式为： 123456789101112131415161718// provideimport &#123;provide&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup() &#123; // 此处name必须是String类型，value则不限制 provide(name, value) &#125;&#125;// injectimport &#123;inject&#125; from &#x27;vue&#x27; // 显式导入export default &#123; setup()&#123; // name即为传过来的字段，第二个参数可选，可填写默认值 const val = inject(name, defaultValue); return &#123;val&#125; &#125;&#125; 我们修改以上案例的代码： 1234567891011121314151617181920212223242526272829303132&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; provide(&#39;num&#39;, 789) &#125;&#125;&lt;&#x2F;script&gt;&lt;!-- Sun.vue孙子组件 --&gt;&lt;template&gt; &lt;h4&gt;孙子组件：&#123;&#123;mynum&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;inject&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入export default &#123; setup()&#123; const mynum &#x3D; inject(&#39;num&#39;); return &#123;mynum&#125; &#125;&#125;&lt;&#x2F;script&gt; 3、响应性所谓的 Provide/Inject 响应性，其实就是把传递的值结合上文提及的 ref 或 reactive 一起使用： 1234567891011121314151617181920212223242526272829&lt;!-- Father.vue父组件 --&gt;&lt;template&gt; &lt;Child &#x2F;&gt; &lt;button @click&#x3D;&quot;changeNumFn&quot;&gt;修改num&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;provide, ref&#125; from &#39;vue&#39; &#x2F;&#x2F; 显式导入import Child from &#39;.&#x2F;Child.vue&#39;export default &#123; components: &#123; Child &#125;, setup()&#123; &#x2F;&#x2F; 使用ref来定义num的值 const num &#x3D; ref(123); &#x2F;&#x2F; 声明一个函数，专门用于修改num let changeNumFn &#x3D; () &#x3D;&gt; &#123; num.value &#x3D; 456; &#125; provide(&#39;num&#39;, num) &#x2F;&#x2F; 返回这个函数 return &#123;changeNumFn&#125; &#125;&#125;&lt;&#x2F;script&gt; 此时，当你点击按钮时，孙子组件接收到的 num 就会被修改了。 四、Teleport（传送门）【掌握】在vue2中，想要将子节点渲染到存在于父组件以外的 DOM 节点时，需要通过第三方库 portal-vue 去实现。而vue3中，Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术。 官方文档：《teleport》 举个最简单的例子： 我们在 index.html 中 #app 同级的地方新增一个 #test 元素： 12&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; 由于vue的 main.js 中规定了打包出来的代码都放入 #app 中： 1createApp(App).mount(&#x27;#app&#x27;) 因此，你现在没有办法将代码放入 #test 中。此时，我们可以使用传送门： App.vue 中： 12345678910111213&lt;template&gt; &lt;Home &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;export default &#123; name: &#39;App&#39;, components: &#123; Home &#125;&#125;&lt;&#x2F;script&gt; Home.vue 中： 123456789&lt;template&gt; &lt;p&gt;这段话是渲染在#app中的&lt;&#x2F;p&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--1&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt; &lt;teleport to&#x3D;&quot;#test&quot;&gt; &lt;p&gt;这段话是渲染在#test中的--2&lt;&#x2F;p&gt; &lt;&#x2F;teleport&gt;&lt;&#x2F;template&gt; 此时，你打开浏览器控制台，就可以看到第2、3个p标签已经被渲染到 #test 中。 备注： 1、标签身上都to属性，填写的是css选择器。 2、多个传送门书写时，会按照自上而下的顺序传送至另一个DOM元素。 五、Suspense（等待）【掌握】Suspense组件用于在等待某个异步组件解析时显示后备内容。 那我们什么时候需要使用异步组件呢？多了去了，比如： 在页面加载之前显示加载动画 显示占位符内容 处理延迟加载的图像 那么，让我们看看 Suspense 怎么使用，我们先来提一个需求： 在等待组件获取数据并解析时显示“玩命加载中…”之类的内容 OK，我们来写一个 Article.vue 组件： 12345678910111213141516171819&lt;template&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;export default&#123; async setup() &#123; let content &#x3D; ref(&#39;内容&#39;) content.value &#x3D; await new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 3秒后修改content resolve(&quot;你好世界&quot;); &#125;, 3000); &#125;) return &#123;content&#125; &#125;,&#125;&lt;&#x2F;script&gt; 用个 Home.vue 组件来调用它： 12345678910111213141516171819&lt;template &lt;Suspense&gt; &lt;template #default&gt; &lt;Article&gt;&lt;&#x2F;Article&gt; &lt;&#x2F;template&gt; &lt;template #fallback&gt; &lt;p&gt;玩命加载中...&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Suspense&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Article from &#39;.&#x2F;Article.vue&#39;export default &#123; components:&#123; Article &#125;&#125;&lt;&#x2F;script&gt; 可以看出，&lt;Suspense&gt; 中，包含了两个template标签，#default 定义了我们要写入的内容， #fallback 定义了我们要预显示的内容。 ⚠️ 注意： 作为template中的内容（即插槽），必须要有根元素。 六、Fragment（碎片）【了解】vue2中，如果你创建一个Vue组件，那么它只能有一个根节点。这意味着不能创建这样的组件： 1234&lt;template&gt; &lt;div&gt;你好&lt;&#x2F;div&gt; &lt;div&gt;世界&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 原因是代表任何Vue组件的Vue实例需要绑定到一个单一的DOM元素中。唯一可以创建一个具有多个DOM节点的组件的方法就是创建一个没有底层Vue实例的功能组件。 这情况同样存在于react，但react可以使用空标签 &lt;&gt;&lt;/&gt; 来包裹，或者是使用一个名为Fragment的虚拟元素： 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;你好&lt;/td&gt; &lt;td&gt;世界&lt;/td&gt; &lt;/React.Fragment&gt; ) &#125;&#125; 尽管Fragment看起来像一个普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。目前你可以在Vue 2中使用vue-fragments库来使用Fragments，而在Vue 3中，你直接使用就行了，无需引入任何库。 七、TreeShaking（消除未使用代码）【了解】TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。 文档参考：https://vue3js.cn/docs/zh/guide/migration/global-api-treeshaking.html#_2-x-%E8%AF%AD%E6%B3%95 举个例子： vue2中我们常使用 Vue.nextTick(()=&gt;&#123;&#125;) 来预操作DOM，但有时候我们不用这个 nextTick ，比如改用别的方式来代替（如setTimeout），那么项目打包时，vue 全局的 nextTick 就成为一个多余的代码，从而使你的项目打包体积变大。 在vue3中，官方团队重构了所有全局 API 的组织方式，让所有的 API 都支持了 TreeShaking。所以vue3中如果还想使用全局的 nextTick ，就需要引入： 12345import &#123; nextTick &#125; from &#x27;vue&#x27;; nextTick(() =&gt; &#123; // 和 DOM 有关的一些操作&#125;); 如果你在 Vue 3 中不引入而直接调用 Vue.nextTick() ，就会得到一个报错：undefined is not a function。 官方也给出了Vue 2.x 中的受此更改影响的全局 API： Vue.nextTick Vue.observable (用 Vue.reactive 替换) Vue.version Vue.compile (仅全构建) Vue.set (仅兼容构建) Vue.delete (仅兼容构建) 八、Performance（性能）【了解】vue3.0相对于vue2.0来说性能快1.2到1.5倍，主要原因如下： 1、diff方法优化 \u001dVue2 中的虚拟dom是进行全量的对比 Vue3 新增了静态标记（PatchFlag），只比对带有 PF 的节点，并且通过 Flag 的信息得知 当前节点要比对的具体内容。 2、静态提升 Vue2中无论元素是否参与更新, 每次都会重新创建, 然后再渲染 Vue3中对于不参与更新的元素, 会做静态提升, 只会被创建一次, 在渲染时直接复用即可 3、cacheHandlers 事件侦听器缓存 默认情况下onClick会被视为动态绑定, 所以每次都会去追踪它的变化 但是因为是同一个函数，所以没有追踪变化, 直接缓存起来复用即可 4、ssr渲染 当有大量静态的内容时候，这些内容会被当做纯字符串推进一个buffer里面， 即使存在动态的绑定，会通过模板插值嵌入进去。这样会比通过虚拟dmo来渲染的快上很多很多。 当静态内容大到一定量级时候，会用_createStaticVNode方法在客户端去生成一个static node， 这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。 九、Setup的生命周期【了解】组合式API需要在setup中使用，setup中含有的生命钩子与vue的大体一致： 具体参考：《setup生命周期钩子》 十、TypeScript支持【了解】vue3新增了对TS语法的支持。","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"}]},{"title":"davJs学习02","slug":"umi中，davjs学习02","date":"2021-02-23T16:00:00.000Z","updated":"2021-02-24T07:30:24.443Z","comments":true,"path":"2021/02/24/umi中，davjs学习02/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/24/umi%E4%B8%AD%EF%BC%8Cdavjs%E5%AD%A6%E4%B9%A002/","excerpt":"","text":"最近公司新项目用的UmiJs3.x，整个项目的数据，通过内置的Davjs来控制。 昨天自己分析了一下Davjs。但是脑海中的概念还是很模糊。今天再梳理一下。 第一步首先是在Models文件夹下创建一个JS文件 123456789101112131415161718192021222324252627282930313233const GlobalModel = &#123; //model的名称 namespace: &quot;global&quot;, state: &#123; //放数据的地方 user:&#123;&#125; &#125;, effects: &#123; // 异步获取数据，不能直接修改数据，需要通过put调用reducers的方法。 `其中call和普通是dva 提供的effect 函数内部的处理函数 call：执行异步函数， put：发出一个 Action，类似于 dispatch select获取数据，` *getTableData(&#123; payload &#125;, &#123; put, select, call &#125;) &#123; const tableList = yield select((state) =&gt; state.global.tableData); yield put(&#123; type: &quot;setTableParams&quot;, payload, &#125;); &#125;, reducers: &#123; //同步获取数据 setTableParams(state) &#123; return &#123; ...state &#125; &#125; &#125;,&#125;;export default GlobalModel; 第二步对应页面中 12345678910111213141516171819202122232425262728import React from &quot;react&quot;;import &#123; connect &#125; from &quot;umi&quot;;const TableDemo = (props) =&gt; &#123; //能直接获取到users const &#123;dispatch, users&#125; = props dispatch(&#123; //global这个model中，getTableData这个异步操作函数 type: &quot;global/getTableData&quot;, payload: &#123; &#125;, &#125;); return ( &lt;div&gt; &#123;users.name&#125; &lt;/div&gt; )&#125;//把global中state中的数据绑定到页面的props上export default connect((&#123; global &#125;) =&gt; (&#123; users: global.users&#125;))(TableDemo); 还可以调用Service文件夹里的接口，获取数据","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"}]},{"title":"Dav结构的分析","slug":"davjs学习","date":"2021-02-23T10:34:00.000Z","updated":"2021-03-06T01:55:47.053Z","comments":true,"path":"2021/02/23/davjs学习/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/23/davjs%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"下面是davjs models的一个基本结构 1234567891011121314151617181920212223242526272829303132333435export default &#123; //dav model的名字namespace: &#x27;example&#x27;,//数据state: &#123;num:1&#125;, //表示当前的example中的state状态，这里可以给初始值，这里num初始为1 //这里是做异步处理的相当于VueX的actioneffects: &#123; //payload是参数 put触发action ，select获取数据， call异步操作 *addByONe(&#123; payload&#125;, &#123; call, put,select &#125;) &#123; //这里使用selectconst num = yield select(state =&gt; state.num) //这里就获取到了当前state中的数据numlet param1; param1 = num + payload; 这里就可以使用num进行操作了yield put(&#123;type: &#x27;save&#x27;,num:param1&#125;);&#125;&#125;, //用来保存更新state值 上面的put方法调用这里的方法,reducers: &#123;save(state, action) &#123; //这里的state是当前总的state，这里的action包含了上面传递的参数和type return &#123; ...state, ...action.num &#125;; //这里用ES6语法来更新当前state中num的值&#125;&#125;, &#125;;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"}]},{"title":"关于我","slug":"关于我","date":"2021-02-11T16:00:00.000Z","updated":"2021-03-16T02:53:51.135Z","comments":true,"path":"2021/02/12/关于我/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/12/%E5%85%B3%E4%BA%8E%E6%88%91/","excerpt":"","text":"姓名：微光 学校：常州大学 公司： 万帮数字新能源星星充电 现居：江苏-常州 技术栈：Html5、Css3、JavaScript、Vue、React、Node.js、Express、微信小程序、Mongodb 熟练使用AntDesign ElementUI Vant deng 码云： https://gitee.com/shimmer612 github: https://github.com/Little-light1 路 很长 顺道寻光","categories":[],"tags":[{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]},{"title":"新年快乐","slug":"hello-world","date":"2021-02-10T16:00:00.000Z","updated":"2021-02-23T05:25:35.342Z","comments":true,"path":"2021/02/11/hello-world/","link":"","permalink":"https://gitee.com/shimmer612/myBlog/2021/02/11/hello-world/","excerpt":"","text":"大家新年快乐","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/shimmer612/myBlog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"vue3","slug":"vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/vue3/"},{"name":"Vue3","slug":"Vue3","permalink":"https://gitee.com/shimmer612/myBlog/tags/Vue3/"},{"name":"css","slug":"css","permalink":"https://gitee.com/shimmer612/myBlog/tags/css/"},{"name":"nodejs","slug":"nodejs","permalink":"https://gitee.com/shimmer612/myBlog/tags/nodejs/"},{"name":"express","slug":"express","permalink":"https://gitee.com/shimmer612/myBlog/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gitee.com/shimmer612/myBlog/tags/mongodb/"},{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/shimmer612/myBlog/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://gitee.com/shimmer612/myBlog/tags/React/"},{"name":"swiper","slug":"swiper","permalink":"https://gitee.com/shimmer612/myBlog/tags/swiper/"},{"name":"tips","slug":"tips","permalink":"https://gitee.com/shimmer612/myBlog/tags/tips/"},{"name":"React UmiJS","slug":"React-UmiJS","permalink":"https://gitee.com/shimmer612/myBlog/tags/React-UmiJS/"},{"name":"AntDesign","slug":"AntDesign","permalink":"https://gitee.com/shimmer612/myBlog/tags/AntDesign/"},{"name":"Davjs","slug":"Davjs","permalink":"https://gitee.com/shimmer612/myBlog/tags/Davjs/"},{"name":"UmiJs","slug":"UmiJs","permalink":"https://gitee.com/shimmer612/myBlog/tags/UmiJs/"},{"name":"Aboutme","slug":"Aboutme","permalink":"https://gitee.com/shimmer612/myBlog/tags/Aboutme/"}]}